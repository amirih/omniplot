<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>omniplot.plot API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>omniplot.plot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Union, Optional, Dict, List
import matplotlib.collections as mc
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd
from matplotlib import cm
from matplotlib.lines import Line2D
from scipy.cluster.hierarchy import leaves_list
from scipy.cluster import hierarchy
from collections import defaultdict
import matplotlib.colors
from natsort import natsort_keygen
from matplotlib.patches import Rectangle
import scipy.cluster.hierarchy as sch
import fastcluster as fcl
from sklearn.decomposition import TruncatedSVD
from sklearn.pipeline import make_pipeline
from sklearn.random_projection import SparseRandomProjection
import sys 
import matplotlib as mpl
from sklearn.cluster import KMeans, DBSCAN
from sklearn.metrics import silhouette_score
from scipy.spatial.distance import pdist, squareform
from sklearn.decomposition import PCA, NMF, LatentDirichletAllocation
from scipy.stats import fisher_exact
from scipy.stats import zscore
from itertools import combinations
import os
#script_dir = os.path.dirname( __file__ )
#sys.path.append( script_dir )
from omniplot.utils import _line_annotate, _dendrogram_threshold, _radialtree2,_get_cluster_classes,_calc_curveture, _draw_ci_pi,_calc_r2,_ci_pi, _save, _baumkuchen_xy
import scipy.stats as stats
from joblib import Parallel, delayed
from omniplot.chipseq_utils import _calc_pearson
import itertools as it

colormap_list=[&#34;nipy_spectral&#34;, &#34;terrain&#34;,&#34;tab20b&#34;,&#34;tab20c&#34;,&#34;gist_rainbow&#34;,&#34;hsv&#34;,&#34;CMRmap&#34;,&#34;coolwarm&#34;,&#34;gnuplot&#34;,&#34;gist_stern&#34;,&#34;brg&#34;,&#34;rainbow&#34;,&#34;jet&#34;]
plt.rcParams[&#39;font.family&#39;]= &#39;sans-serif&#39;
plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Arial&#39;]
plt.rcParams[&#39;svg.fonttype&#39;] = &#39;none&#39;
sns.set_theme(font=&#34;Arial&#34;)






def dotplot(df: pd.DataFrame,
            row: str=&#34;&#34;,
            col: str=&#34;&#34;,
            dfc=pd.DataFrame(),
            scaling: float=10,
            color_val: str=&#34;&#34;,
            size_val: str=&#34;&#34;,
            highlight: str=&#34;&#34;,
            color_title: str=&#34;&#34;,
            size_title: str=&#34;&#34;,
            figsize: list=[],
            save: str=&#34;&#34;,
            threshold: float=-np.log10(0.05),
            row_clustering: bool=True,
            xtickrotation: float=90,
            column_order: list=[],
            colorpalette=&#34;coolwarm&#34;,
            show: bool=False,
            ) -&gt; Dict[str, plt.Axes]:
    &#34;&#34;&#34;
    Drawing a dotplot that can represent two different variables as dot sizes and colors on a regular grid.
    This function is assumed to plot GO enrichment analysis with multiple gene sets.
    
    Parameters
    ----------
    df : pandas DataFrame
        dataframe containing two categories and corresponding values (such as p values and odds ratio).
        e.g.:
            Cluster                   Condensate      pval      odds       FDR
        54       C1                   Cajal body -0.000000  0.000000 -0.000000
        55       C1            *DNA repair focus -0.000000  0.000000 -0.000000
        56       C1  *DNA replication condensate -0.000000  0.000000 -0.000000
        57       C1                       P-body -0.000000  0.000000 -0.000000
        58       C1                     PML body -0.000000  0.000000 -0.000000
    row: string
        the column name of a category that is going to be placed in the row of the dotplot
    col: string
        the column name of a category that is going to be placed in the column of the dotplot
    color_val : string
        The column name for the values represented as dot colors.
    size_val : string
        The column name for the values represented as dot sizes. 
    scaling: float
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    highlight : string
        A dictionary to set color labels to leaves. The key is the name of the color label. 
        The value is the list of RGB color codes, each corresponds to the color of a leaf. 
        e.g., {&#34;color1&#34;:[[1,0,0,1], ....]}   
    size_title : string
        The title for size values. If not set, &#34;size_val&#34; will be used.
    
    color_title : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    show : bool
        Whether or not to show the figure.
    Returns
    -------
    axes: dict {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if size_val!=&#34;&#34;:
        _df=df.pivot_table(index=col,columns=row,values=size_val)
        if len(column_order)&gt;0:
            _df=_df.loc[column_order]
        else:
            _df=_df.sort_index(axis=0,key=natsort_keygen())
        _df=_df.fillna(0)
            
        if color_val!=&#34;&#34;:
            dfc=df.pivot_table(index=col,columns=row,values=color_val)
            if len(column_order)&gt;0:
                dfc=dfc.loc[column_order]
            else:
                dfc=dfc.sort_index(axis=0,key=natsort_keygen())
            dfc=dfc.fillna(0)
        if highlight !=&#34;&#34;:
            dfh=df.pivot_table(index=col,columns=row,values=highlight)
            if len(column_order)&gt;0:
                dfh=dfh.loc[column_order]
            else:
                dfh=dfh.sort_index(axis=0,key=natsort_keygen())
            dfh=dfh.fillna(0)
        
        if row_clustering==True:
            Y = fcl.linkage(_df.to_numpy().T, method=&#39;ward&#39;, metric=&#39;euclidean&#39;)
            Z1 = sch.dendrogram(Y,no_plot=True)
            idx1 = Z1[&#39;leaves&#39;]
            reorder=_df.columns[idx1]
            _df=_df[reorder]
            if color_val!=&#34;&#34;:
                dfc=dfc[reorder]
            if highlight !=&#34;&#34;:
                dfh=dfh[reorder]
        _x=_df.index
        _y=_df.columns
        mat=_df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    else:
        _x=df.index
        _y=df.columns
        mat=df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    #if minsize==0:
        #mat=mat+maxsize*0.01
    #minsize=np.amin(mat)
    
    maxsize=np.round(maxsize)
    middle0=np.round((minsize+maxsize)/3)
    middle1=np.round(2*(minsize+maxsize)/3)
    #plt.rcParams[&#34;figure.figsize&#34;] = [7.50, 3.50]
    #plt.rcParams[&#34;figure.autolayout&#34;] = True
    #x = np.arange(len(_x))
    #y = np.arange(len(_y))
    #X, Y = np.meshgrid(x, y)
    xy=[ [i,j] for i in range(len(_x)) for j in range(len(_y))]
    #num = 1000
    sizes = [mat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
    edge_colors=[]
    if highlight !=&#34;&#34;:
        hmat=dfh.to_numpy()
        hvals = [hmat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
       
        for s in hvals:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    else:
        for s in sizes:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    
    if len(dfc) !=0:
        viridis = cm.get_cmap(colorpalette, 12)
        cmat=dfc.to_numpy()
        cmat[cmat==np.inf]=0
        _cmat=cmat/np.amax(cmat)
        _colors = [viridis(_cmat[i,j]) for i in range(len(_x)) for j in range(len(_y))]
    else:
        _colors = [[0,1,0,1] for i in range(len(_x)) for j in range(len(_y))]
    #print(sizes)
    #xy = 10 * np.random.random((num, 2))
    #xy=XY
    #patches = [plt.Circle(center, size) for center, size in zip(xy, sizes)]
    
    #fig, ax = plt.subplots(ncols=2, gridspec_kw={&#39;width_ratios&#39;: [8, 2]})
    if len(figsize)==0:
        figsize=[mat.shape[0]*0.5+2,mat.shape[1]*0.5+1]
    
    fig = plt.figure(figsize=figsize)
    #fig.set_figheight(6)
    #fig.set_figwidth(6)
    
    ax1 = plt.subplot2grid(shape=(10, 6), loc=(0, 0), colspan=4, rowspan=10)
    ax2 = plt.subplot2grid(shape=(10, 6), loc=(1, 4), colspan=2, rowspan=4)
    ax3 = plt.subplot2grid(shape=(10, 6), loc=(6, 4), colspan=2, rowspan=1)
 
    collection = mc.CircleCollection(sizes,
                                     edgecolors=edge_colors, 
                                     offsets=xy, 
                                     transOffset=ax1.transData, 
                                     facecolors=_colors,
                                     linewidths=2)
    ax1.add_collection(collection)
    ax1.margins(0.1)
    ax1.set_xlim(-0.5,len(_x)-0.5)
    ax1.set_xticks(np.arange(len(_x)))
    ax1.set_xticklabels(_x,rotation=xtickrotation)
    ax1.set_yticks(np.arange(len(_y)))
    ax1.set_yticklabels(_y, rotation=0)
    if color_title==&#34;&#34;:
        color_title=color_val
    
    if len(dfc) !=0:
        norm = mpl.colors.Normalize(vmin=np.min(cmat), vmax=np.amax(cmat))
        
        cb1 = mpl.colorbar.ColorbarBase(ax3, cmap=viridis,
                                        norm=norm,
                                        orientation=&#39;horizontal&#39;)
        cb1.set_label(color_title)
    #ax[1]=fig.add_axes([1,0.3,0.1,1])
    
    lxy=[[0.5, i*0.5] for i in range(3)]
    collection2 = mc.CircleCollection([middle0*scaling,middle1*scaling, maxsize*scaling], 
                                      offsets=lxy, 
                                      transOffset=ax2.transData, 
                                      facecolors=&#39;lightgray&#39;,
                                      edgecolors=&#34;gray&#34;)
    ax2.add_collection(collection2)
    ax2.axis(&#39;off&#39;)
    ax2.margins(0.3)
    for text, (x, y) in zip([middle0,middle1, maxsize], lxy):
        ax2.text(x+0.01, y,str(text), ha=&#34;left&#34;,va=&#34;center&#34;,color=&#34;black&#34; )
    if size_title==&#34;&#34;:
        size_title=size_val
    ax2.text(0.5,-0.5, size_title,va=&#34;center&#34;,ha=&#34;center&#34;)
    #ax[1].set_yticks(np.arange(3))
    #ax[1].set_yticklabels([minsize,middle, maxsize], rotation=0)
    #plt.tight_layout()
    plt.subplots_adjust(left=0.3,bottom=0.2)
    #plt.tight_layout()
    _save(save, &#34;dotplot&#34;)
    if show==True:
        plt.show()
    return {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}


def radialtree(df: pd.DataFrame,
               n_clusters: int=3,
               category: Union[str, List[str]]=[], 
               save: str=&#34;&#34;, 
               **kwargs) -&gt; Dict:
    &#34;&#34;&#34;
    Drawing a radial dendrogram with color labels.
    
    Parameters
    ----------
    df : pandas DataFrame
        
    n_clusters: int
        Approximate number of clusters to produce
    category: str or list of str
        the column name of a category that is going to presented as colors around the dendrogram.
    show : bool
        Whether or not to show the figure.
    fontsize : float
        A float to specify the font size
    figsize : [x, y] array-like
        1D array-like of floats to specify the figure size
    palette : string
        Matlab colormap name.
    Returns
    -------
    dict: {&#34;axes&#34;:ax, &#34;clusters&#34;: clusters}

    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if len(category) !=0:
        if type(category)==str:
            category=[category]
        category_df=df[category]
        df=df.drop(category, axis=1)
        X = df.values
        #print(X)
        assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        X = df.values
        assert X.dtype==float, &#34;data must contain only float values.&#34;
    X=zscore(X, axis=0)
    D=squareform(pdist(X))
    Y = sch.linkage(D, method=&#39;ward&#39;)
    Z = sch.dendrogram(Y,labels=df.index,no_plot=True)
    t=_dendrogram_threshold(Z, n_clusters)
    Z=sch.dendrogram(Y,
                        labels = df.index,
                        color_threshold=t,no_plot=True)
    sample_classes={k: list(category_df[k]) for k in category_df.columns}
    ax=_radialtree2(Z, sample_classes=sample_classes,addlabels=False, **kwargs)
    _save(save, &#34;radialtree&#34;)
    clusters = _get_cluster_classes(Z)
    return {&#34;axes&#34;:ax, &#34;clusters&#34;:clusters}

# def _complex_clustermap(df: pd.DataFrame,
#                        row_colormap: dict={},
#                        col_colormap: dict={},
#                        row_plot: dict={},
#                        col_plot: dict={},
#                        row_color_legend: dict={},
#                        col_color_legend: dict={},
#                        approx_clusternum: int=10,
#                        approx_clusternum_col: int=3,
#                        color_var: int=0,
#                        merginalsum: bool=False,
#                        show: bool=False,
#                        method: str=&#34;ward&#34;,
#                        return_col_cluster: bool=True, 
#                        **kwargs):
#     &#34;&#34;&#34;
#     Drawing a clustered heatmap with merginal plots.
#
#     Parameters
#     ----------
#     df : pandas DataFrame
#     row_colormap: dict
#         the column name of a category that is going to be placed in the row of the dotplot
#     col_colormap: dict
#         the column name of a category that is going to be placed in the column of the dotplot
#     row_plot : dict
#         The column name for the values represented as dot colors.
#     col_plot : dict
#         The column name for the values represented as dot sizes. 
#     row_color_legend: dict
#         The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
#     col_color_legend: dict
#         The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
#
#     approx_clusternum : int
#         The approximate number of row clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.    
#     approx_clusternum_col : int
#         The approximate number of column clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.
#
#     color_var : int
#         The title for color values. If not set, &#34;color_val&#34; will be used.
#     merginalsum : bool
#         Whether or not to draw bar plots for merginal distribution.
#     show : bool
#         Whether or not to show the figure.
#     method : string
#         Method for hierarchical clustering.
#     return_col_cluster : string
#         The title for color values. If not set, &#34;color_val&#34; will be used.
#     Returns
#     -------
#         dict 
#         {&#34;row_clusters&#34;:pd.DataFrame,&#34;col_clusters&#34;:pd.DataFrame, &#34;grid&#34;:g}
#     Raises
#     ------
#     Notes
#     -----
#     References
#     ----------
#     See Also
#     --------
#     Examples
#     --------
#     &#34;&#34;&#34;#print(kwargs)
#
#     rnum, cnum=df.shape
#     sns.set(font_scale=1)
#
#     totalrowplot=0
#     if merginalsum==True:
#         totalrowplot+=1
#     totalrowplot+=len(row_plot)
#     totalrowplot+=len(row_colormap)
#     totalcolplot=0
#     if merginalsum==True:
#         totalcolplot+=1
#     totalcolplot+=len(col_plot) 
#     totalcolplot+=len(col_colormap)
#
#
#     if totalrowplot + totalcolplot &gt;0:
#         rowplotcount=0
#         colplotcount=0
#         row_colors=[]
#         row_colors_title=[]
#         col_colors=[]
#         col_colors_title=[]
#
#         if merginalsum:
#             row_colors.append(np.ones([rnum, 4]))
#             row_colors_title.append(&#34;Sum&#34;)
#             col_colors.append(np.ones([rnum, 4]))
#             col_colors_title.append(&#34;Sum&#34;)
#         if len(row_colormap)&gt;0:
#             for k, v in row_colormap.items():
#                 row_colors.append(v)
#                 row_colors_title.append(k)
#
#         if len(col_colormap)&gt;0:
#             for k, v in col_colormap.items():
#                 col_colors.append(v)
#                 col_colors_title.append(k)
#
#         if len(row_plot)&gt;0:
#             for k, v in row_plot.items():
#                 row_colors.append(np.ones([rnum, 4]))
#                 row_colors_title.append(k)
#         if len(col_plot)&gt;0:
#             for k, v in col_plot.items():
#                 col_colors.append(np.ones([rnum, 4]))
#                 col_colors_title.append(k)        
#
#
#
#
#
#         if len(row_colors) &gt;0 and len(col_colors) &gt;0:
#             g=sns.clustermap(df,col_colors=col_colors, row_colors=row_colors,method=method,**kwargs)
#             g.ax_col_colors.invert_yaxis()
#             g.ax_row_colors.invert_xaxis()
#         elif len(col_colors) &gt;0:
#
#             g=sns.clustermap(df,col_colors=col_colors,method=method,**kwargs)
#             g.ax_col_colors.invert_yaxis()
#         elif len(row_colors) &gt;0:
#             g=sns.clustermap(df,row_colors=row_colors,method=method,**kwargs)
#             g.ax_row_colors.invert_xaxis()
#
#         rowplotcount=0
#         colplotcount=0
#         if merginalsum:
#             mat=df.to_numpy()
#             r=np.sum(mat, axis=1)
#             g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r[leaves_list(g.dendrogram_row.linkage)]/np.amax(r))
#
#
#             c=np.sum(mat, axis=0)
#             #print(leaves_list(g.dendrogram_col.linkage))
#             g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c[leaves_list(g.dendrogram_col.linkage)]/np.amax(c))
#
#             rowplotcount=1
#             colplotcount=1
#         rowplotcount+=len(row_colormap)
#
#         if len(row_plot)&gt;0:
#             row_cluster=True
#             if &#34;row_cluster&#34; in kwargs:
#                 row_cluster=kwargs[&#34;row_cluster&#34;]
#
#             for i, (lname, r) in enumerate(row_plot.items()):
#                 r=np.array(r)
#                 if row_cluster==True:
#                     tmpindx=leaves_list(g.dendrogram_row.linkage)
#                     r=r[tmpindx]
#                     r=r-np.amin(r)
#                     r=r/np.amax(r)
#                     r=0.9*r
#                     g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
#                 else:
#                     g.ax_row_colors.plot(r/(np.amax(r)*1.1)+rowplotcount, np.arange(r.shape[0])+0.5)
#
#                 rowplotcount+=1
#
#
#         colplotcount+=len(col_colormap)
#
#         if len(col_plot)&gt;0:
#             col_cluster=True
#             if &#34;col_cluster&#34; in kwargs:
#                 col_cluster=kwargs[&#34;col_cluster&#34;]
#             for i, (lname, r) in enumerate(col_plot.items()):
#                 r=np.array(r)
#                 if col_cluster==True:
#                     g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]/(np.amax(r)*1.1)+colplotcount)
#                 else:
#                     g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r/(np.amax(r)*1.1)+colplotcount)
#
#                 colplotcount+=1
#
#         g.ax_row_colors.set_xticks(np.arange(len(row_colors_title))+0.5)
#         g.ax_row_colors.set_xticklabels(row_colors_title, rotation=90)
#         g.ax_col_colors.set_yticks(np.arange(len(col_colors_title))+0.5)
#         g.ax_col_colors.set_yticklabels(col_colors_title)
#
#         for title, colorlut in row_color_legend.items():
#             legendhandles=[]
#             for label, color in colorlut.items():
#                 legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))
#             #g.add_legend(legend_data=legendhandles,title=&#34;Aroma&#34;,label_order=[&#34;W&#34;,&#34;F&#34;,&#34;Y&#34;])
#             legend1=g.ax_col_dendrogram.legend(handles=legendhandles, loc=&#39;upper right&#39;, title=title)
#             g.ax_col_dendrogram.add_artist(legend1)
#         for title, colorlut in col_color_legend.items():
#             legendhandles=[]
#             for label, color in colorlut.items():
#                 legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))
#             #g.add_legend(legend_data=legendhandles,title=&#34;Aroma&#34;,label_order=[&#34;W&#34;,&#34;F&#34;,&#34;Y&#34;])
#             legend1=g.ax_col_dendrogram.legend(handles=legendhandles, loc=&#39;upper right&#39;, title=title)
#             g.ax_col_dendrogram.add_artist(legend1)
#
#     else:
#         g=sns.clustermap(df,method=method,**kwargs)
#     if color_var&gt;0:
#         cmap = cm.nipy_spectral(np.linspace(0, 1, color_var))
#     else:
#         cmap = cm.nipy_spectral(np.linspace(0, 1, approx_clusternum+5))
#     hierarchy.set_link_color_palette([mpl.colors.rgb2hex(rgb[:3]) for rgb in cmap])
#
#     &#34;&#34;&#34;coloring the row dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
#     if g.dendrogram_row != None:
#         t=_dendrogram_threshold(g.dendrogram_row.dendrogram)
#         # lbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,:2]
#         # rbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,2:]
#         # thre=np.linspace(0, np.amax(g.dendrogram_row.dendrogram[&#34;dcoord&#34;]), 100)[::-1]
#         # for t in thre:
#         #     #print(np.sum(lbranches[:,1]&gt;t),np.sum(rbranches[:,0]&gt;t),np.sum(lbranches[:,0]&gt;t),np.sum(rbranches[:,1]&gt;t))
#         #     crossbranches=np.sum(lbranches[:,1]&gt;t)+np.sum(rbranches[:,0]&gt;t)-np.sum(lbranches[:,0]&gt;t)-np.sum(rbranches[:,1]&gt;t)
#         #     #print(crossbranches)
#         #
#         #     if crossbranches&gt;approx_clusternum:
#         #         break
#
#         den=hierarchy.dendrogram(g.dendrogram_row.linkage,
#                                                  labels = g.data.index,
#                                                  color_threshold=t,ax=g.ax_row_dendrogram,
#                             orientation=&#34;left&#34;)  
#         g.ax_row_dendrogram.invert_yaxis()
#         clusters = _get_cluster_classes(den)
#         cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
#         keys=list(clusters.keys())
#         ckeys={}
#         i=1
#         for k in keys:
#             if k==&#34;C0&#34;:
#                 ckeys[k]=&#34;C0&#34;
#             else:
#                 ckeys[k]=&#34;C&#34;+str(i)
#                 i+=1
#         for c, v in clusters.items():
#             _c=ckeys[c]
#             for _v in v:
#                 cdata[&#34;Cluster&#34;].append(_c)
#                 cdata[&#34;Index&#34;].append(_v)
#                 cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
#         &#34;&#34;&#34;Setting the row dendrogram ends here&#34;&#34;&#34;
#
#
#     &#34;&#34;&#34;coloring the col dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
#     t=_dendrogram_threshold(g.dendrogram_col.dendrogram)
#     # lbranches=np.array(g.dendrogram_col.dendrogram[&#34;dcoord&#34;])[:,:2]
#     # rbranches=np.array(g.dendrogram_col.dendrogram[&#34;dcoord&#34;])[:,2:]
#     # thre=np.linspace(0, np.amax(g.dendrogram_col.dendrogram[&#34;dcoord&#34;]), 100)[::-1]
#     # for t in thre:
#     #     #print(np.sum(lbranches[:,1]&gt;t),np.sum(rbranches[:,0]&gt;t),np.sum(lbranches[:,0]&gt;t),np.sum(rbranches[:,1]&gt;t))
#     #     crossbranches=np.sum(lbranches[:,1]&gt;t)+np.sum(rbranches[:,0]&gt;t)-np.sum(lbranches[:,0]&gt;t)-np.sum(rbranches[:,1]&gt;t)
#     #     #print(crossbranches)
#     #
#     #     if crossbranches&gt;approx_clusternum_col:
#     #         break
#
#     den=hierarchy.dendrogram(g.dendrogram_col.linkage,
#                                              labels = g.data.columns,
#                                              color_threshold=t,ax=g.ax_col_dendrogram,
#                         orientation=&#34;top&#34;)  
#     #g.ax_col_dendrogram.invert_yaxis()
#     col_clusters = _get_cluster_classes(den)
#     col_cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
#     col_keys=list(col_clusters.keys())
#     col_ckeys={}
#     i=1
#     for k in col_keys:
#         if k==&#34;C0&#34;:
#             col_ckeys[k]=&#34;C0&#34;
#         else:
#             col_ckeys[k]=&#34;C&#34;+str(i)
#             i+=1
#     for c, v in col_clusters.items():
#         _c=col_ckeys[c]
#         for _v in v:
#             col_cdata[&#34;Cluster&#34;].append(_c)
#             col_cdata[&#34;Index&#34;].append(_v)
#             col_cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
#     &#34;&#34;&#34;Setting the col dendrogram ends here&#34;&#34;&#34;
#
#
#
#     if show:
#         plt.show()
#     else:
#         if return_col_cluster==True:
#             return {&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:pd.DataFrame(col_cdata), &#34;grid&#34;:g}
#         else:
#             return {&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:None, &#34;grid&#34;:g}


def complex_clustermap(df: pd.DataFrame,
                       heatmap_col: list,
                       dfcol: Optional[pd.DataFrame]=None, 
                       
                       row_colors: list=[],
                       col_colors: list=[],
                       row_plot: list=[],
                       col_plot: list=[],
                       row_scatter: list=[],
                       col_scatter: list=[],
                       row_bar: list=[],
                       col_bar: list=[],
                       
                       approx_clusternum: int=10,
                       approx_clusternum_col: int=3,
                       color_var: int=0,
                       merginalsum: bool=False,
                       show: bool=False,
                       method: str=&#34;ward&#34;,
                       return_col_cluster: bool=True,
                       ztranform=True,
                       xticklabels=True, 
                       yticklabels=False,
                       show_plot_labels=False,figsize=[],save: str=&#34;&#34;,
                       **kwargs):
    &#34;&#34;&#34;
    Drawing a clustered heatmap with merginal plots.
    
    Parameters
    ----------
    df : pandas DataFrame
    row_colormap: dict
        the column name of a category that is going to be placed in the row of the dotplot
    col_colormap: dict
        the column name of a category that is going to be placed in the column of the dotplot
    row_plot : dict
        The column name for the values represented as dot colors.
    col_plot : dict
        The column name for the values represented as dot sizes. 
    row_color_legend: dict
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    col_color_legend: dict
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    
    approx_clusternum : int
        The approximate number of row clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.    
    approx_clusternum_col : int
        The approximate number of column clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.
    
    color_var : int
        The title for color values. If not set, &#34;color_val&#34; will be used.
    merginalsum : bool
        Whether or not to draw bar plots for merginal distribution.
    show : bool
        Whether or not to show the figure.
    method : string
        Method for hierarchical clustering.
    return_col_cluster : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    Returns
    -------
        dict: {&#34;row_clusters&#34;:pd.DataFrame,&#34;col_clusters&#34;:pd.DataFrame, &#34;grid&#34;:g}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;#print(kwargs)
    rnum, cnum=df.shape
    cnum=len(heatmap_col)
    if len(figsize)==0:
        xsize=np.amin([2*cnum, 20])
        figsize=[xsize,10]
    scatterpointsize=5
    sns.set(font_scale=1)
    if ztranform:
        df[heatmap_col]=df[heatmap_col].apply(zscore)
    
    if len(col_plot)!=0 or len(col_scatter)!=0 or len(col_bar)!=0:
        if dfcol==None:
            raise Exception(&#34;if you want to plot along the x axis, you need provide dfcol option containing values to plot.&#34;)
    
    totalrowplot=0
    if merginalsum==True:
        totalrowplot+=1
    totalrowplot+=len(row_plot)
    totalrowplot+=len(row_colors)
    totalrowplot+=len(row_scatter)
    totalrowplot+=len(row_bar)
    totalcolplot=0
    if merginalsum==True:
        totalcolplot+=1
    totalcolplot+=len(col_plot) 
    totalcolplot+=len(col_colors)
    totalcolplot+=len(col_scatter)
    totalcolplot+=len(col_bar)
    _row_color_legend={}
    _col_color_legend={}
    colormap_index=0
    if totalrowplot + totalcolplot &gt;0:
        rowplotcount=0
        colplotcount=0
        _row_colors=[]
        _row_colors_title=[]
        _col_colors=[]
        _col_colors_title=[]
        
        if merginalsum:
            _row_colors.append(np.ones([rnum, 4]))
            _row_colors_title.append(&#34;Sum&#34;)
            _col_colors.append(np.ones([cnum, 4]))
            _col_colors_title.append(&#34;Sum&#34;)
        #print(np.shape(_col_colors))
        if len(row_colors)&gt;0:
            for k in row_colors:
                
                u=np.unique(df[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _row_color_legend[k]=lut
                colormap_index+=1
                _row_colors.append([lut[cat] for cat in df[k]])
                _row_colors_title.append(k)
                
        if len(col_colors)&gt;0:
            for k in col_colors:
                u=np.unique(dfcol[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _col_color_legend[k]=lut
                colormap_index+=1
                _col_colors.append([lut[cat] for cat in dfcol[k]])
                _col_colors_title.append(k)
        
        if len(row_plot)&gt;0:
            for k in row_plot:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_plot)&gt;0:
            for k in col_plot:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k)        
        
        if len(row_scatter)&gt;0:
            for k in row_scatter:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_scatter)&gt;0:
            for k in col_scatter:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(row_bar)&gt;0:
            for k in row_bar:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_bar)&gt;0:
            for k in col_bar:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(_row_colors) &gt;0 and len(_col_colors) &gt;0:
            #print(np.shape(_col_colors))
            g=sns.clustermap(df[heatmap_col],col_colors=_col_colors, 
                             row_colors=_row_colors,
                             method=method,xticklabels=xticklabels, yticklabels=yticklabels,
                             figsize=figsize,dendrogram_ratio=0.1,
                             **kwargs)
            g.ax_col_colors.invert_yaxis()
            g.ax_row_colors.invert_xaxis()
        elif len(_col_colors) &gt;0:
           
            g=sns.clustermap(df[heatmap_col],
                             col_colors=_col_colors,
                             method=method,
                             xticklabels=xticklabels, 
                             yticklabels=yticklabels,
                             dendrogram_ratio=0.1,
                             figsize=figsize,**kwargs)
            g.ax_col_colors.invert_yaxis()
        elif len(_row_colors) &gt;0:
            g=sns.clustermap(df[heatmap_col],row_colors=_row_colors,method=method,xticklabels=xticklabels, yticklabels=yticklabels,dendrogram_ratio=0.1,figsize=figsize,**kwargs)
            g.ax_row_colors.invert_xaxis()
        
        rowplotcount=0
        colplotcount=0
        tickpos=0.9
        row_labels=[]
        col_labels=[]
        row_ticks=[]
        col_ticks=[]
        if merginalsum:
            mat=df[heatmap_col].to_numpy()
            r=np.sum(mat, axis=1)
            row_labels.append(0)
            row_labels.append(np.amax(r))
            row_ticks.append(rowplotcount)
            row_ticks.append(rowplotcount+tickpos)
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            if row_cluster==True:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r[leaves_list(g.dendrogram_row.linkage)]/np.amax(r),height=1)
                
            else:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r/np.amax(r),height=1)
            #g.ax_row_colors.set_xticks([0,1],labels=[0,np.amax(r)])
            c=np.sum(mat, axis=0)
            #print(mat, c)
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            if col_cluster==True:
            
            #print(leaves_list(g.dendrogram_col.linkage))
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c[leaves_list(g.dendrogram_col.linkage)]/np.amax(c),width=1)
            else:
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c/np.amax(c),width=1)
            #g.ax_col_colors.set_yticks([0,1],labels=[0,np.amax(c)])
            col_labels.append(0)
            col_labels.append(np.amax(c))
            col_ticks.append(colplotcount)
            col_ticks.append(colplotcount+tickpos)
            rowplotcount=1
            colplotcount=1
        rowplotcount+=len(row_colors)
        colplotcount+=len(col_colors)
        if len(row_plot)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_plot):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)

                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
                else:
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
            
                rowplotcount+=1
                
        if len(col_plot)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_plot):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount)
                else:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r+colplotcount)
                
                colplotcount+=1
        if len(row_scatter)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_scatter):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
                else:
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
            
                rowplotcount+=1
        if len(col_scatter)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_scatter):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount,s=scatterpointsize)
                else:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r+colplotcount,s=scatterpointsize)
                
                colplotcount+=1
        
        if len(row_bar)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_bar):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                    
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    g.ax_row_colors.barh(y=np.arange(r.shape[0])+0.5, width=r[leaves_list(g.dendrogram_row.linkage)],left=[rowplotcount]*r.shape[0])
                else:
                    g.ax_row_colors.barh(r, np.arange(r.shape[0])+0.5,left=[rowplotcount]*r.shape[0])
            
                rowplotcount+=1
        if len(col_bar)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_bar):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)

                if col_cluster==True:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]/(np.amax(r)*1.1)+colplotcount)
                else:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r/(np.amax(r)*1.1)+colplotcount)
                
                colplotcount+=1
        if g.ax_row_colors!=None:
            
            g.ax_row_colors.set_xticks(np.arange(len(_row_colors_title))+0.5)
            g.ax_row_colors.set_xticklabels(_row_colors_title, rotation=90)
        if g.ax_col_colors!=None:
            colax_otherside = g.ax_col_colors.twinx()
            colax_otherside.set_yticks(0.5*(np.arange(len(_col_colors_title))+0.5),labels=_col_colors_title)
            colax_otherside.grid(False)
        if g.ax_col_dendrogram!=None:
            col = g.ax_col_dendrogram.get_position()
            g.ax_col_dendrogram.set_position([col.x0, col.y0, col.width*0.5, col.height*0.5])
        
        if show_plot_labels==True:
            
            rowax_otherside = g.ax_row_colors.twiny()
            rowax_otherside.invert_xaxis()
            rowax_otherside.grid(False)
            rowax_otherside.set_xticks(row_ticks, labels=np.round(row_labels,2), rotation=90, fontsize=8)
            col_ticks=np.array(col_ticks)
            g.ax_col_colors.set_yticks(col_ticks, labels=np.round(col_labels,2), fontsize=8)
        
        legend_num=0
        for title, colorlut in _row_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))
            #g.add_legend(legend_data=legendhandles,title=&#34;Aroma&#34;,label_order=[&#34;W&#34;,&#34;F&#34;,&#34;Y&#34;])
            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        for title, colorlut in _col_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))
            #g.add_legend(legend_data=legendhandles,title=&#34;Aroma&#34;,label_order=[&#34;W&#34;,&#34;F&#34;,&#34;Y&#34;])
            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        
    else:
        g=sns.clustermap(df,method=method,**kwargs)
    if color_var&gt;0:
        cmap = cm.nipy_spectral(np.linspace(0, 1, color_var))
    else:
        cmap = cm.nipy_spectral(np.linspace(0, 1, approx_clusternum+5))
    hierarchy.set_link_color_palette([mpl.colors.rgb2hex(rgb[:3]) for rgb in cmap])
    
    &#34;&#34;&#34;coloring the row dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    if g.dendrogram_row != None:
        t=_dendrogram_threshold(g.dendrogram_row.dendrogram,approx_clusternum)
        # lbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,:2]
        # rbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,2:]
        # thre=np.linspace(0, np.amax(g.dendrogram_row.dendrogram[&#34;dcoord&#34;]), 100)[::-1]
        # for t in thre:
        #     #print(np.sum(lbranches[:,1]&gt;t),np.sum(rbranches[:,0]&gt;t),np.sum(lbranches[:,0]&gt;t),np.sum(rbranches[:,1]&gt;t))
        #     crossbranches=np.sum(lbranches[:,1]&gt;t)+np.sum(rbranches[:,0]&gt;t)-np.sum(lbranches[:,0]&gt;t)-np.sum(rbranches[:,1]&gt;t)
        #     #print(crossbranches)
        #
        #     if crossbranches&gt;approx_clusternum:
        #         break
        
        den=hierarchy.dendrogram(g.dendrogram_row.linkage,
                                                 labels = g.data.index,
                                                 color_threshold=t,ax=g.ax_row_dendrogram,
                            orientation=&#34;left&#34;)  
        g.ax_row_dendrogram.invert_yaxis()
        clusters = _get_cluster_classes(den)
        cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        keys=list(clusters.keys())
        ckeys={}
        i=1
        for k in keys:
            if k==&#34;C0&#34;:
                ckeys[k]=&#34;C0&#34;
            else:
                ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in clusters.items():
            _c=ckeys[c]
            for _v in v:
                cdata[&#34;Cluster&#34;].append(_c)
                cdata[&#34;Index&#34;].append(_v)
                cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
        &#34;&#34;&#34;Setting the row dendrogram ends here&#34;&#34;&#34;
    
    
    &#34;&#34;&#34;coloring the col dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    if g.dendrogram_col != None:
        t=_dendrogram_threshold(g.dendrogram_col.dendrogram,approx_clusternum_col)
        den=hierarchy.dendrogram(g.dendrogram_col.linkage,
                                                 labels = g.data.columns,
                                                 color_threshold=t,ax=g.ax_col_dendrogram,
                            orientation=&#34;top&#34;)  
        #g.ax_col_dendrogram.invert_yaxis()
        col_clusters = _get_cluster_classes(den)
        col_cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        col_keys=list(col_clusters.keys())
        col_ckeys={}
        i=1
        for k in col_keys:
            if k==&#34;C0&#34;:
                col_ckeys[k]=&#34;C0&#34;
            else:
                col_ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in col_clusters.items():
            _c=col_ckeys[c]
            for _v in v:
                col_cdata[&#34;Cluster&#34;].append(_c)
                col_cdata[&#34;Index&#34;].append(_v)
                col_cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
    &#34;&#34;&#34;Setting the col dendrogram ends here&#34;&#34;&#34;
    
    plt.setp(g.ax_heatmap.xaxis.get_majorticklabels(), rotation=90)
    plt.subplots_adjust(bottom=0.165, right=0.75)
    if save!=&#34;&#34;:
        if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
            plt.savefig(save)
        else:
            plt.savefig(save+&#34;_complexheatmap.pdf&#34;)
    if show:
        plt.show()
    if return_col_cluster==True:
        return {&#34;data&#34;:g.data2d,&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:pd.DataFrame(col_cdata), &#34;grid&#34;:g}
    else:
        return {&#34;data&#34;:g.data2d,&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:None, &#34;grid&#34;:g}

def triangle_heatmap(df, 
                     grid_pos: list=[],
                     grid_labels: list=[],
                     show: bool=False, save: str=&#34;&#34;)-&gt; dict:
    
    &#34;&#34;&#34;
    Creating a heatmap with 45 degree rotation.
    
    Parameters
    ----------
    df : pandas DataFrame
    grid_pos: list
        the column name of a category that is going to be placed in the row of the dotplot
    grid_labels: list
        the column name of a category that is going to be placed in the column of the dotplot
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    dict {&#34;axes&#34;: ax}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    
    genes=df.index
    fig, ax = plt.subplots(figsize=[8,6])
    dmat=df.to_numpy()
    D = dmat
    N = dmat.shape[0]
    a=np.tril(np.zeros([N,N])-1000000, k=-1)
    # Get the lower triangle of the matrix. 
    C = np.triu(D)+a
    
    # Mask the upper triangle.
    C = np.ma.masked_array(C, C == -1000000)
    # Set the diagonal to zero.
    for i in range(N):
        C[i, i] = 0
    
    # Transformation matrix for rotating the heatmap.
    A = np.array([(y, x) for x in range(N, -1, -1) for y in range(N + 1)])
    t = np.array([[2**(-0.5), 2**(-0.5)], [-2**(-0.5), 2**(-0.5)]])
    A = np.dot(A, t)
    #t_ = np.array([[2**(-0.5), -2**(-0.5)], [2**(-0.5), 2**(-0.5)]])
    
    # -1.0 correlation is blue, 0.0 is white, 1.0 is red.
    cmap = plt.cm.Reds
    #norm = mp.colors.BoundaryNorm(np.linspace(0, 10, 14), cmap.N)
    
    # This MUST be before the call to pl.pcolormesh() to align properly.
    ax.set_xticks([])
    ax.set_yticks([])
    
    X = A[:, 1].reshape(N + 1, N + 1)
    Y = A[:, 0].reshape(N + 1, N + 1)
    caxes = plt.pcolormesh(X, Y, np.flipud(C), axes=ax, cmap=cmap, rasterized=True)
    x1s=[0]
    if len(grid_pos)&gt;0:
        for i,  grid in enumerate(grid_pos):
            x0=(grid)/(2**(0.5))
            x1=(grid)*(2**0.5)
            y0=(grid)/(2**(0.5))
            y1=0
            ax.plot([x0, x1], [y0, y1],color=&#39;gray&#39;, linewidth=1)
            ax.plot([(grid)*(2**0.5), (grid)*(2**0.5)+(N-grid)/(2**(0.5))], [0, (N-grid)/(2**(0.5))], color=&#39;gray&#39;, linewidth=1)
            x1s.append(x1)
    x1s.append(N*2**0.5)
    
    

    if len(genes) &gt;0: 
        leng=0
        for i, g in enumerate(genes):
            #ax.plot([(i+0.5)*(2**0.5), (i+0.5)*(2**0.5)], [-2**0.5, -(N/10)*2**0.5/2],color=&#39;b&#39;, linewidth=0.5)
            ax.text((i+0.5)*(2**0.5), -(N/10)*2**0.5/2*1.01, g, rotation=90,ha=&#39;center&#39;, va=&#39;top&#39;, fontsize=&#34;small&#34;)
            leng+=len(g)
        leng=leng/len(genes)
    else:
        leng=0
    spacing=(N/10)*leng*0.4
    
    
    rect=Rectangle([0, -spacing],N*(2**0.5), spacing, color=&#39;whitesmoke&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    
    rect=Rectangle([0, -(N/10)*2**0.5/2],N*(2**0.5), (N/10)*2**0.5/2, color=&#39;dimgray&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    if len(grid_labels)&gt;0:
        for i in range(len(x1s)-1):
            if i%2==1:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;silver&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            else:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;lavender&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            x=(x1s[i]+x1s[i+1])/2
            ax.text(x,-(N/10)*2**0.5/4, grid_labels[i], rotation=90,ha=&#39;center&#39;, va=&#39;center&#39;, color=&#34;w&#34;)
    

    
    
    cb = plt.colorbar(caxes, ax=ax, shrink=0.75)
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;bottom&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_visible(False)
    if save!=&#34;&#34;:
        if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
            plt.savefig(save)
        else:
            plt.savefig(save+&#34;_complexheatmap.pdf&#34;)
    if show:
        plt.show()
    return {&#34;axes&#34;: ax}
    
    

def decomplot(df,category: str=&#34;&#34;, 
              method: str=&#34;pca&#34;, 
              component: int=3,
              arrow_color: str=&#34;yellow&#34;,
              arrow_text_color: str=&#34;black&#34;,
              show: bool=False, 
              explained_variance: bool=True,
              arrow_num: int=3,
              figsize=[],
              regularization: bool=True,
              pcapram={&#34;random_state&#34;:0},
              nmfparam={&#34;random_state&#34;:0},
              save: str=&#34;&#34;,
              saveparam: dict={}) :
    
    &#34;&#34;&#34;
    Decomposing data and drawing a scatter plot and some plots for explained variables. 
    
    Parameters
    ----------
    df : pandas DataFrame
    category: str
        the column name of a known sample category (if exists). 
    method: str
        Method name for decomposition. Available methods: [&#34;pca&#34;, &#34;nmf&#34;]
    component: int
        The component number
    
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
        dict {&#34;data&#34;: dfpc_list,&#34;pca&#34;: pca, &#34;axes&#34;:axes, &#34;axes_explained&#34;:ax2} for pca method
        or {&#34;data&#34;: dfpc_list, &#34;W&#34;:W, &#34;H&#34;:H,&#34;axes&#34;:axes,&#34;axes_explained&#34;:axes2} for nmf method
            
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;    
    if category !=&#34;&#34;:
        category_val=df[category].values
        df=df.drop([category], axis=1)
        x = df.values
        assert x.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        x = df.values
        assert x.dtype==float, &#34;data must contain only float values.&#34;
    original_index=df.index
    features=df.columns
    dfpc_list=[]
    if method==&#34;pca&#34;:
        if regularization:
            x=zscore(x, axis=0)
        pca = PCA(n_components=component,**pcapram)
        pccomp = pca.fit_transform(x)
        
        comb=list(combinations(np.arange(component), 2))
        if len(comb)==1:
            fig, axes=plt.subplots()
            axes=[axes]
        else:
            nrows=len(comb)//2+int(len(comb)%2!=0)
            if len(figsize)==0:
                figsize=[8,3*nrows]
            
            fig, axes=plt.subplots(ncols=2, nrows=nrows, figsize=figsize)
            plt.subplots_adjust(top=0.9,right=0.8)
            axes=axes.flatten()
        loadings = pca.components_.T * np.sqrt(pca.explained_variance_)
        combnum=0
        for (i, j), ax in zip(comb, axes):
            xlabel, ylabel=&#39;pc&#39;+str(i+1), &#39;pc&#39;+str(j+1)
            dfpc = pd.DataFrame(data = np.array([pccomp[:,i],pccomp[:,j]]).T, columns = [xlabel, ylabel],index=original_index)
            if category!=&#34;&#34;:
                dfpc[category]=category_val
                if combnum==1:
                    sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, hue=category, ax=ax)
                    ax.legend(bbox_to_anchor=(1.02, 1), loc=&#39;upper left&#39;, borderaxespad=0)
                else:
                    sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, hue=category, ax=ax,
                                    legend=False)
            else:
                sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, ax=ax)
            _loadings=np.array([loadings[:,i],loadings[:,j]]).T
            a=np.sum(_loadings**2, axis=1)
            srtindx=np.argsort(a)[::-1][:arrow_num]
            _loadings=_loadings[srtindx]
            _features=np.array(features)[srtindx]
            for k, feature in enumerate(_features):
                
                #ax.plot([0,_loadings[k, 0] ], [0,_loadings[k, 1] ],color=arrow_color)
                ax.arrow(0, 0, _loadings[k, 0],_loadings[k, 1],color=arrow_color,width=0.005,head_width=0.1)
                ax.text(_loadings[k, 0],_loadings[k, 1],feature,color=arrow_text_color)
    
            dfpc_list.append(dfpc)
            combnum+=1
        plt.tight_layout(pad=0.5)
        if save!=&#34;&#34;:
            if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                h, ext=os.path.splitext(save)
                plt.savefig(h[0]+&#34;_PCA&#34;+ext, **saveparam)
            else:
                plt.savefig(save+&#34;_PCA.pdf&#34;,**saveparam) 
        if explained_variance==True:
            fig, ax2=plt.subplots()
            exp_var_pca = pca.explained_variance_ratio_
            #
            # Cumulative sum of eigenvalues; This will be used to create step plot
            # for visualizing the variance explained by each principal component.
            #
            cum_sum_eigenvalues = np.cumsum(exp_var_pca)
            #
            # Create the visualization plot
            #
            xlabel=[&#34;pc&#34;+str(i+1) for i in range(0,len(exp_var_pca))]
            plt.bar(xlabel, exp_var_pca, alpha=0.5, align=&#39;center&#39;, label=&#39;Individual explained variance&#39;)
            plt.step(range(0,len(cum_sum_eigenvalues)), cum_sum_eigenvalues, where=&#39;mid&#39;,label=&#39;Cumulative explained variance&#39;)
            plt.ylabel(&#39;Explained variance ratio&#39;)
            plt.xlabel(&#39;Principal component index&#39;)
            if save!=&#34;&#34;:
                if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                    h, ext=os.path.splitext(save)
                    plt.savefig(h[0]+&#34;_ExplainedVar&#34;+ext, **saveparam)
                else:
                    plt.savefig(save+&#34;_ExplainedVar.pdf&#34;,**saveparam) 
        if show==True:
            plt.show()
        else:
            return {&#34;data&#34;: dfpc_list,&#34;pca&#34;: pca, &#34;axes&#34;:axes, &#34;axes_explained&#34;:ax2}
    elif method==&#34;nmf&#34;:
        nmf=NMF(n_components=component,**nmfparam)
        if regularization:
            x=x/np.sum(x,axis=0)[None,:]
        W = nmf.fit_transform(x)
        H = nmf.components_
        comb=list(combinations(np.arange(component), 2))
        if len(comb)==1:
            fig, axes=plt.subplots()
            axes=[axes]
        else:
            nrows=len(comb)//2+int(len(comb)%2!=0)
            if len(figsize)==0:
                figsize=[8,3*nrows]
            
            fig, axes=plt.subplots(ncols=2, nrows=nrows, figsize=figsize)
            plt.subplots_adjust(top=0.9,right=0.8)
            axes=axes.flatten()

        for (i, j), ax in zip(comb, axes):
            xlabel, ylabel=&#39;p&#39;+str(i+1), &#39;p&#39;+str(j+1)
            dfpc = pd.DataFrame(data = np.array([W[:,i],W[:,j]]).T, columns = [xlabel, ylabel],index=original_index)
            dfpc[category]=category_val
            sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, hue=category, ax=ax)
            dfpc_list.append(dfpc)
        
        fig.tight_layout()
        if save!=&#34;&#34;:
            if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                h, ext=os.path.splitext(save)
                plt.savefig(h[0]+&#34;_NMF&#34;+ext, **saveparam)
            else:
                plt.savefig(save+&#34;_NMF.pdf&#34;,**saveparam) 
        if explained_variance==True:
            fig, axes2=plt.subplots(nrows=component, figsize=[5,5])
            axes2=axes2.flatten()
            for i, ax in enumerate(axes2):
                if i==0:
                    ax.set_title(&#34;Coefficients of matrix H&#34;)
                ax.bar(np.arange(len(features)),H[i])
                ax.set_ylabel(&#34;p&#34;+str(i+1))
                ax.set_xticks(np.arange(len(features)),labels=[])
            ax.set_xticks(np.arange(len(features)),labels=features, rotation=90)
            fig.tight_layout()
            
            # dfw={&#34;index&#34;:[],&#34;p&#34;:[],&#34;val&#34;:[]}
            # ps=[&#34;p&#34;+str(i+1) for i in range(component)]
            # originalindex=df.index
            # for i in range(W.shape[0]):
            #     for j in range(W.shape[1]):
            #         dfw[&#34;index&#34;].append(originalindex[i])
            #         dfw[&#34;p&#34;].append(ps[j])
            #         dfw[&#34;val&#34;].append(W[i,j])
            # dfw=pd.DataFrame(data=dfw)
            #
            # dfh={&#34;feature&#34;:[],&#34;p&#34;:[],&#34;val&#34;:[]}
            # for i in range(H.shape[0]):
            #     for j in range(H.shape[1]):
            #         dfh[&#34;p&#34;].append(ps[i])
            #         dfh[&#34;feature&#34;].append(features[j])
            #
            #         dfh[&#34;val&#34;].append(H[i,j])
            # dfw=pd.DataFrame(data=dfw)
            # dfh=pd.DataFrame(data=dfh)
            # #dotplot(dfw,row=&#34;index&#34;,col=&#34;p&#34;,size_val=&#34;val&#34;)
            # dotplot(dfh,row=&#34;p&#34;,col=&#34;feature&#34;,size_val=&#34;val&#34;,)
            
            if save!=&#34;&#34;:
                if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                    h, ext=os.path.splitext(save)
                    plt.savefig(h[0]+&#34;_Coefficients&#34;+ext, **saveparam)
                else:
                    plt.savefig(save+&#34;_Coefficients.pdf&#34;,**saveparam)    
                
            if show==True:
                plt.show()
            return {&#34;data&#34;: dfpc_list, &#34;W&#34;:W, &#34;H&#34;:H,&#34;axes&#34;:axes,&#34;axes_explained&#34;:axes2}
    elif method==&#34;lda&#34;:
        lda=LatentDirichletAllocation(n_components=component, random_state=0)
        if regularization:
            x=x/np.sum(x,axis=0)[None,:]
        
    else:
        raise Exception(&#39;{} is not in options. Available options are: pca, nmf&#39;.format(method))
def manifoldplot(df,category=&#34;&#34;, 
                 method=&#34;tsne&#34;,
                 n_components=2,
                 n_neighbors=4, show=False, **kwargs):
    &#34;&#34;&#34;
    Reducing the dimensionality of data and drawing a scatter plot. 
    
    Parameters
    ----------
    df : pandas DataFrame
    category: str
        the column name of a known sample category (if exists). 
    method: str
        Method name for decomposition. 
        Available methods: [&#34;tsne&#34;, 
                            &#34;isomap&#34;,
                            &#34;random_projection&#34;,
                            &#34;linear_discriminant&#34;,
                            &#34;lle&#34;,
                            &#34;modlle&#34;,
                            &#34;hessian_lle&#34;,
                            &#34;mds&#34;]
    component: int
        The number of components
    n_neighbors: int
        The number of neighbors related to isomap and lle methods.
    
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;    
    from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
    from sklearn.ensemble import RandomTreesEmbedding
    from sklearn.manifold import (
        Isomap,
        LocallyLinearEmbedding,
        MDS,
        SpectralEmbedding,
        TSNE,)
    from sklearn.neighbors import NeighborhoodComponentsAnalysis
    if category !=&#34;&#34;:
        category_val=df[category].values
        df=df.drop([category], axis=1)
        x = df.values
        assert x.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        x = df.values
        assert x.dtype==float, &#34;data must contain only float values.&#34;
    x=zscore(x, axis=0)
    features=df.columns
    original_index=df.index
    if method==&#34;random_projection&#34;: 
        embedding=SparseRandomProjection(
            n_components=n_components, random_state=42
        )
    elif method==&#34;linear_discriminant&#34;: 
        embedding=LinearDiscriminantAnalysis(
            n_components=n_components
        )
    elif method==&#34;isomap&#34;: 
        embedding=Isomap(n_neighbors=n_neighbors, n_components=n_components)
    
    elif method==&#34;lle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;standard&#34;
        )
    elif method==&#34;modlle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;modified&#34;
        )
    elif method==&#34;hessian_lle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;hessian&#34;
        )
    elif method==&#34;ltsa_lle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;ltsa&#34;
        )
    elif method==&#34;mds&#34;: 
        embedding=MDS(
            n_components=n_components, n_init=1, max_iter=120, n_jobs=2, normalized_stress=&#34;auto&#34;
        )
    elif method==&#34;random_trees&#34;: 
        embedding=make_pipeline(
            RandomTreesEmbedding(n_estimators=200, max_depth=5, random_state=0),
            TruncatedSVD(n_components=n_components),
        )
    elif method==&#34;spectral&#34;: 
        embedding=SpectralEmbedding(
            n_components=n_components, random_state=0, eigen_solver=&#34;arpack&#34;
        )
    elif method==&#34;tsne&#34;: 
        embedding=TSNE(
            n_components=n_components,
            n_iter=500,
            n_iter_without_progress=150,
            n_jobs=2,
            random_state=0,perplexity=10
        )
    elif method==&#34;nca&#34;: 
        embedding=NeighborhoodComponentsAnalysis(
            n_components=n_components, init=&#34;pca&#34;, random_state=0
        )
    elif method==&#34;umap&#34;:
        import umap 
        embedding=umap.UMAP(
            min_dist=0.25,n_neighbors=15
        )
    else:
        raise Exception(f&#34;Medthod {method} does not exist.&#34;)
    Xt=embedding.fit_transform(x)
    dft = pd.DataFrame(data = np.array([Xt[:,0],Xt[:,1]]).T, columns = [&#34;d1&#34;, &#34;d2&#34;],index=original_index)
    if category !=&#34;&#34;:
        fig, ax=plt.subplots()
        dft[category]=category_val
        sns.scatterplot(data=dft, x=&#34;d1&#34;, y=&#34;d2&#34;, hue=category, ax=ax,**kwargs)
    else:
        sns.scatterplot(data=dft, x=&#34;d1&#34;, y=&#34;d2&#34;, ax=ax,**kwargs)
    if show==True:
        plt.show()
    return {&#34;data&#34;: dft, &#34;axes&#34;: ax}

def clusterplot(df,category: Union[List[str], str]=&#34;&#34;, 
              method: str=&#34;kmeans&#34;,
              n_clusters: Union[str , int]=3,
              x: str=&#34;&#34;,
              y: str=&#34;&#34;,
              reduce_dimension: str=&#34;umap&#34;, 
              testrange=[1,20],
              show: bool=False,
              min_dist: float=0.25,
              n_neighbors: int=15,
              eps: Union[List[float], float]=0.5,
              pcacomponent: Optional[int]=None,
              ztranform=True,
              palette=[&#34;Spectral&#34;,&#34;cubehelix&#34;],save: str=&#34;&#34;,**kwargs)-&gt;Dict:
    &#34;&#34;&#34;
    Clustering data and draw them as a scatter plot optionally with dimensionality reduction.  
    
    Parameters
    ----------
    df : pandas DataFrame
    
    category: str
        the column name of a known sample category (if exists). 
    method: str
        Method name for clustering. 
        Available methods: [&#34;kmeans&#34;, 
                            &#34;hierarchical&#34;,
                            &#34;dbscan&#34;,
                            ]
    n_clusters: int or str
        The number of clusters to be created. If &#34;auto&#34; is provided, it will estimate optimal 
        cluster numbers with &#34;Sum of squared distances&#34; for k-mean clustering and silhouette method for others. 
    eps: int or list[int]
        DBSCAN&#39;s hyper parameter. It will affect the total number of clusters. 
    reduce_dimension: str
        Dimensionality reduction method. Default: umap. 
        if &#34;&#34; is passed, no reduction methods are applied. In this case, data must be 2 dimention or x and y options must be specified.
    
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34; 
    
    
    original_index=df.index
    
    if len(category) !=0:
        if type(category)==str:
            category=[category]
        category_val=df[category].values
        
        df=df.drop(category, axis=1)
        X = df.values
        assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        X = df.values
        assert X.dtype==float, &#34;data must contain only float values.&#34;
    
    if ztranform:
        X=zscore(X, axis=0)
    if pcacomponent==None:
            
        if 20&lt;X.shape[1]:
            pcacomponent=20
        elif 10&lt;X.shape[1]:
            pcacomponent=10
        else:
            pcacomponent=2
    pca=PCA(n_components=pcacomponent, random_state=1)
    xpca=pca.fit_transform(X)
    
    if reduce_dimension==&#34;umap&#34;:
        import umap
        u=umap.UMAP(random_state=42, min_dist=min_dist,n_neighbors=n_neighbors)
        X=u.fit_transform(xpca)
    
    if n_clusters==&#34;auto&#34; and method==&#34;kmeans&#34;:
        Sum_of_squared_distances = []
        K = list(range(*testrange))
        for k in K:
            km = KMeans(n_clusters=k,n_init=10)
            km = km.fit(X)
            Sum_of_squared_distances.append(km.inertia_)
        normy=np.array(Sum_of_squared_distances)/np.amax(Sum_of_squared_distances)
        normy=1-normy
        normx=np.linspace(0,1, len(K))
        perp=_calc_curveture(normx, normy)
        # perp=[]
        # for i, (nx, ny) in enumerate(zip(normx, normy)):
        #     if i==0:
        #         perp.append(0)
        #         continue
        #     r=(nx**2+ny**2)**0.5
        #     sina=ny/r
        #     cosa=nx/r
        #     sinamb=sina*np.cos(np.pi*0.25)-cosa*np.sin(np.pi*0.25)
        #     perp.append(r*sinamb)
        # perp=np.array(perp)
        srtindex=np.argsort(perp)[::-1]
        plt.subplots()
        plt.plot(K, Sum_of_squared_distances, &#39;-&#39;, label=&#39;Sum of squared distances&#39;)
        plt.plot(K, perp*np.amax(Sum_of_squared_distances), label=&#34;curveture&#34;)
        
        plt.plot([K[srtindex[0]],K[srtindex[0]]],[0,np.amax(Sum_of_squared_distances)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(K[srtindex[0]], np.amax(Sum_of_squared_distances)*0.95, &#34;N=&#34;+str(K[srtindex[0]]))
        plt.plot([K[srtindex[1]],K[srtindex[1]]],[0,np.amax(Sum_of_squared_distances)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(K[srtindex[1]], np.amax(Sum_of_squared_distances)*0.95, &#34;N=&#34;+str(K[srtindex[1]]))
        plt.xticks(K)
        plt.xlabel(&#39;K&#39;)
        plt.ylabel(&#39;Sum of squared distances&#39;)
        plt.title(&#39;Elbow method for optimal cluster number&#39;)    
        plt.legend()
        print(&#34;Top two optimal cluster No are: {}, {}&#34;.format(K[srtindex[0]],K[srtindex[1]]))
        n_clusters=[K[srtindex[0]],K[srtindex[1]]]
        
        _save(save)
    elif n_clusters==&#34;auto&#34; and method==&#34;hierarchical&#34;:
        import scipy.spatial.distance as ssd
        
        labels=df.index
        D=ssd.squareform(ssd.pdist(xpca))
        Y = sch.linkage(D, method=&#39;ward&#39;)
        Z = sch.dendrogram(Y,labels=labels,no_plot=True)
        
        K = list(range(*testrange))
        newK=[]
        scores=[]
        for k in K:
            t=_dendrogram_threshold(Z, k)
            Z2=sch.dendrogram(Y,
                                labels = labels,
                                color_threshold=t,no_plot=True) 
            clusters=_get_cluster_classes(Z2, label=&#39;ivl&#39;)
            _k=len(clusters)
            if not _k in newK:
                newK.append(_k)
                sample2cluster={}
                i=1
                for k, v in clusters.items():
                    for sample in v:
                        sample2cluster[sample]=&#34;C&#34;+str(i)
                    i+=1
                scores.append(silhouette_score(X, [sample2cluster[sample] for sample in labels], metric = &#39;euclidean&#39;)/_k)
        print(scores)
        scores=np.array(scores)
        srtindex=np.argsort(scores)[::-1]
        plt.subplots()
        plt.plot(newK, scores, &#39;-&#39;)
        plt.plot([newK[srtindex[0]],newK[srtindex[0]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[0]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[0]]))
        plt.plot([newK[srtindex[1]],newK[srtindex[1]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[1]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[1]]))
        plt.xticks(newK)
        plt.xlabel(&#39;K&#39;)
        plt.ylabel(&#39;Silhouette scores&#39;)
        plt.title(&#39;Optimal cluster number searches by silhouette method&#39;)    
        
        print(&#34;Top two optimal cluster No are: {}, {}&#34;.format(newK[srtindex[0]],newK[srtindex[1]]))
        n_clusters=[newK[srtindex[0]],newK[srtindex[1]]]
        
    elif n_clusters==&#34;auto&#34; and method==&#34;dbscan&#34;:
        # import scipy.spatial.distance as ssd
        # D=ssd.pdist(X)
        #
        from sklearn.neighbors import NearestNeighbors
        neigh = NearestNeighbors(n_neighbors=2)
        nbrs = neigh.fit(X)
        distances, indices = nbrs.kneighbors(X)
        distances = np.sort(distances[:,1], axis=0)
        #
        # plt.plot(distances)
        # plt.show()
        # sys.exit()
        print(np.amin(distances), np.amax(distances))
        K=np.linspace(np.amin(distances), np.amax(distances),20)
        newK=[]
        scores=[]
        _K=[]
        for k in K:
            db = DBSCAN(eps=k, min_samples=5, n_jobs=-1)
            dbX=db.fit(X)
            labels=np.unique(dbX.labels_[dbX.labels_&gt;=0])
            print(k,labels)
            if len(labels)&lt;2:
                continue
            _k=len(labels)
            if not _k in newK:
                newK.append(_k)
                _K.append(k)
                scores.append(silhouette_score(X[dbX.labels_&gt;=0], dbX.labels_[dbX.labels_&gt;=0], metric = &#39;euclidean&#39;)/_k)
        print(scores)
        scores=np.array(scores)
        
        _ksort=np.argsort(newK)
        _K=np.array(_K)[_ksort]
        newK=np.array(newK)[_ksort]
        scores=np.array(scores)[_ksort]
        srtindex=np.argsort(scores)[::-1]
        plt.subplots()
        plt.plot(newK, scores, &#39;-&#39;)
        plt.plot([newK[srtindex[0]],newK[srtindex[0]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[0]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[0]]))
        plt.plot([newK[srtindex[1]],newK[srtindex[1]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[1]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[1]]))
        plt.xticks(newK)
        plt.xlabel(&#39;eps&#39;)
        plt.ylabel(&#39;Silhouette scores&#39;)
        plt.title(&#39;Optimal cluster number searches by silhouette method&#39;)    
        
        print(&#34;Top two optimal cluster No are: {}, {}&#34;.format(newK[srtindex[0]],newK[srtindex[1]]))
        eps=[_K[srtindex[0]],_K[srtindex[1]]]
        
    else:
        n_clusters=[n_clusters]
    if method==&#34;kmeans&#34;:
        dfnews=[]
        if reduce_dimension==&#34;umap&#34;:
            x=&#34;UMAP1&#34;
            y=&#34;UMAP2&#34;
        for nc in n_clusters:
            kmean = KMeans(n_clusters=nc, random_state=0,n_init=10)
            kmX=kmean.fit(X)
            labels=np.unique(kmX.labels_)
            
            dfnew=pd.DataFrame(data = np.array([X[:,0],X[:,1]]).T, columns = [x, y], index=original_index)
            dfnew[&#34;kmeans&#34;]=kmX.labels_
            dfnews.append(dfnew)
        hue=&#34;kmeans&#34;
        
    elif method==&#34;hierarchical&#34;:
        import scipy.spatial.distance as ssd
        labels=df.index
        D=ssd.squareform(ssd.pdist(xpca))
        Y = sch.linkage(D, method=&#39;ward&#39;)
        Z = sch.dendrogram(Y,labels=labels,no_plot=True)
        if reduce_dimension==&#34;umap&#34;:
            x=&#34;UMAP1&#34;
            y=&#34;UMAP2&#34;
        dfnews=[]
        for nc in n_clusters:
            t=_dendrogram_threshold(Z, nc)
            Z2=sch.dendrogram(Y,
                                labels = labels,
                                color_threshold=t,no_plot=True) 
            clusters=_get_cluster_classes(Z2, label=&#39;ivl&#39;)
            sample2cluster={}
            i=1
            for k, v in clusters.items():
                for sample in v:
                    sample2cluster[sample]=&#34;C&#34;+str(i)
                i+=1
                
            dfnew=pd.DataFrame(data = np.array([X[:,0],X[:,1]]).T, columns = [x, y], index=original_index)
            dfnew[&#34;hierarchical&#34;]=[sample2cluster[sample] for sample in labels]       
            dfnews.append(dfnew)
        hue=&#34;hierarchical&#34;
    elif method==&#34;dbscan&#34;:
        dfnews=[]
        if reduce_dimension==&#34;umap&#34;:
            x=&#34;UMAP1&#34;
            y=&#34;UMAP2&#34;
        if type(eps)==float:
            eps=[eps]
        n_clusters=[]
        for e in eps:
            db = DBSCAN(eps=e, min_samples=5, n_jobs=-1)
            dbX=db.fit(X)
            labels=np.unique(dbX.labels_)
            
            dfnew=pd.DataFrame(data = np.array([X[:,0],X[:,1]]).T, columns = [x, y], index=original_index)
            dfnew[&#34;dbscan&#34;]=dbX.labels_
            dfnews.append(dfnew)
            tmp=0
            for c in set(dbX.labels_):
                if c &gt;=0:
                    tmp+=1
            n_clusters.append(str(tmp)+&#34;, eps=&#34;+str(np.round(e,2)))
            
            
        hue=&#34;dbscan&#34;
    _dfnews={}
    for dfnew, K in zip(dfnews, n_clusters): 
        if len(category)==0:
            axnum=1
            fig, ax=plt.subplots(ncols=1, figsize=[4,4])
            ax=[ax]
        else:
            fig, ax=plt.subplots(ncols=1+len(category), figsize=[4+4*len(category),4])
        sns.scatterplot(data=dfnew,x=x,y=y,hue=hue, ax=ax[0], palette=palette[0],**kwargs)
        ax[0].set_title(&#34;Cluster number=&#34;+str(K))
        if len(category)!=0:
            for i, cat in enumerate(category):
                dfnew[cat]=category_val[:,i]
                sns.scatterplot(data=dfnew,x=x,y=y,hue=cat, ax=ax[i+1], palette=palette[1],**kwargs)
        _dfnews[K]=dfnew 
    return {&#34;data&#34;: _dfnews, &#34;axes&#34;:ax}

def volcanoplot():
    pass


def regression_single(df, 
                      x: str=&#34;&#34;,
                      y: str=&#34;&#34;, 
                      method: str=&#34;ransac&#34;,
                      category: str=&#34;&#34;, 
                      figsize: List[int]=[5,5],
                      show=False, ransac_param={&#34;max_trials&#34;:1000},
                      robust_param={}) -&gt; Dict:
    &#34;&#34;&#34;
    Drawing a scatter plot with a single variable linear regression.  
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str
        the column name of x axis. 
    y: str
        the column name of y axis. 

    method: str
        Method name for regression. Default: ransac
        Available methods: [&#34;ransac&#34;, 
                            &#34;robust&#34;,
                            &#34;lasso&#34;,&#34;elastic_net&#34;
                            ]
    figsize: list[int]
        figure size
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    dict: dict {&#34;axes&#34;:ax, &#34;coefficient&#34;:coef,&#34;intercept&#34;:intercept,&#34;coefficient_pval&#34;:coef_p, &#34;r2&#34;:r2, &#34;fitted_model&#34;:fitted_model}
    
        fitted_model:
            this can be used like: y_predict=fitted_model.predict(_X)
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34; 
    
    
    Y=df[y]
    _X=np.array(df[x]).reshape([-1,1])
    X=np.array(df[x])
    plotline_X = np.arange(X.min(), X.max()).reshape(-1, 1)
    n = X.shape[0]
    plt.rcParams.update({&#39;font.size&#39;: 14})
    fig, ax = plt.subplots(figsize=figsize)
    plt.subplots_adjust(left=0.15)
    if method==&#34;ransac&#34;:
        from sklearn.linear_model import RANSACRegressor
        
        
        
        fit_df=pd.DataFrame()
        fitted_model = RANSACRegressor(random_state=42,**ransac_param).fit(_X,Y)
        fit_df[&#34;ransac_regression&#34;] = fitted_model.predict(plotline_X)
        coef = fitted_model.estimator_.coef_[0]
        intercept=fitted_model.estimator_.intercept_
        inlier_mask = fitted_model.inlier_mask_
        outlier_mask = ~inlier_mask
        
                                # number of samples
        y_model=fitted_model.predict(_X)

        r2 = _calc_r2(X,Y)
        # mean squared error
        MSE = 1/n * np.sum( (Y - y_model)**2 )
        
        # to plot the adjusted model
        x_line = plotline_X.flatten()
        y_line = fit_df[&#34;ransac_regression&#34;]
         
        ci, pi, std_error=_ci_pi(X,Y,plotline_X.flatten(),y_model)
        q=((X-X.mean()).transpose() @ (X-X.mean()))
        sigma=std_error*(q**-1)**(0.5)
        coef_p=stats.t.sf(abs(fitted_model.estimator_.coef_[0]/sigma), df=X.shape[0]-2)
        ############### Ploting

        _draw_ci_pi(ax, ci, pi,x_line, y_line)
        sns.scatterplot(x=X[inlier_mask], y=Y[inlier_mask], color=&#34;blue&#34;, label=&#34;Inliers&#34;)
        sns.scatterplot(x=X[outlier_mask], y=Y[outlier_mask], color=&#34;red&#34;, label=&#34;Outliers&#34;)
        plt.xlabel(x)
        plt.ylabel(y)
        #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
        plt.title(&#34;RANSAC regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(
            r2, MSE,coef,intercept,coef_p
            )
        )
        plt.plot(plotline_X.flatten(),fit_df[&#34;ransac_regression&#34;])
        if len(category)!=0:
            fig, ax=plt.subplots(figsize=figsize)
            plt.subplots_adjust(left=0.15)
            _draw_ci_pi(ax, ci, pi,x_line, y_line)
            sns.scatterplot(data=df,x=x, y=y, hue=category)
            
            plt.xlabel(x)
            plt.ylabel(y)
            #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
            plt.title(&#34;RANSAC regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(
                r2, MSE,coef,intercept,coef_p
                )
            )
            plt.plot(plotline_X.flatten(),fit_df[&#34;ransac_regression&#34;])
    elif method==&#34;robust&#34;:
        import statsmodels.api as sm
        rlm_model = sm.RLM(Y, sm.add_constant(X),
        M=sm.robust.norms.HuberT(),**robust_param)
        fitted_model = rlm_model.fit()
        summary=fitted_model.summary()
        coef=fitted_model.params[1]
        intercept=fitted_model.params[0]
        intercept_p=fitted_model.pvalues[0]
        coef_p=fitted_model.pvalues[1]
        y_model=fitted_model.predict(sm.add_constant(X))
        r2 = _calc_r2(X,Y)
        x_line = plotline_X.flatten()
        y_line = fitted_model.predict(sm.add_constant(x_line))
        
        ci, pi,std_error=_ci_pi(X,Y,plotline_X.flatten(),y_model)
        MSE = 1/n * np.sum( (Y - y_model)**2 )

        _draw_ci_pi(ax, ci, pi,x_line, y_line)
        sns.scatterplot(data=df,x=x, y=y, color=&#34;blue&#34;)
        #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
        plt.title(&#34;Robust linear regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x , p-values: coefficient {:.2f}, \
        intercept {:.2f}&#34;.format(
            r2, MSE,coef,intercept,coef_p,intercept_p
            )
        )
        plt.plot(plotline_X.flatten(),y_line)
        if len(category)!=0:
            fig, ax=plt.subplots(figsize=figsize)
            plt.subplots_adjust(left=0.15)
            _draw_ci_pi(ax, ci, pi,x_line, y_line)
            sns.scatterplot(data=df,x=x, y=y, hue=category)
            #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
            plt.title(&#34;Robust linear regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x , p-values: coefficient {:.2f}, \
            intercept {:.2f}&#34;.format(
                r2, MSE,coef,intercept,coef_p,intercept_p
                )
            )
            plt.plot(plotline_X.flatten(),y_line)
    elif method==&#34;lasso&#34; or method==&#34;elastic_net&#34; or method==&#34;ols&#34;:
        if method==&#34;lasso&#34;:
            method=&#34;sqrt_lasso&#34;
        import statsmodels.api as sm
        rlm_model = sm.OLS(Y, sm.add_constant(X))
        if method==&#34;ols&#34;:
            fitted_model = rlm_model.fit()
        else:
            fitted_model = rlm_model.fit_regularized(method)
        coef=fitted_model.params[1]
        intercept=fitted_model.params[0]
        y_model=fitted_model.predict(sm.add_constant(X))
        r2 = _calc_r2(X,Y)
        x_line = plotline_X.flatten()
        y_line = fitted_model.predict(sm.add_constant(x_line))
        ci, pi, std_error=_ci_pi(X,Y,plotline_X.flatten(),y_model)
        q=((X-X.mean()).transpose() @ (X-X.mean()))
        sigma=std_error*(q**-1)**(0.5)
        print(sigma,coef )
        coef_p=stats.t.sf(abs(coef/sigma), df=X.shape[0]-2)
        MSE = 1/n * np.sum( (Y - y_model)**2 )

        _draw_ci_pi(ax, ci, pi,x_line, y_line)   
        sns.scatterplot(data=df,x=x, y=y, color=&#34;blue&#34;)
        #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
        plt.title(&#34;OLS ({}), r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(method,
            r2, MSE,coef,intercept,coef_p
            )
        )
        plt.plot(plotline_X.flatten(),y_line)
        if len(category)!=0:
            fig, ax=plt.subplots(figsize=figsize)
            plt.subplots_adjust(left=0.15)
            _draw_ci_pi(ax, ci, pi,x_line, y_line)
            sns.scatterplot(data=df,x=x, y=y, color=&#34;blue&#34;,hue=category)
            #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
            plt.title(&#34;OLS ({}), r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(method,
                r2, MSE,coef,intercept,coef_p
                )
            )
            plt.plot(plotline_X.flatten(),y_line)
    return {&#34;axes&#34;:ax, &#34;coefficient&#34;:coef,&#34;intercept&#34;:intercept,&#34;coefficient_pval&#34;:coef_p, &#34;r2&#34;:r2, &#34;fitted_model&#34;:fitted_model}


def violinplot(df, 
               x: Optional[str]=None, 
               y: Optional[str]=None,
               pairs: list=[], 
               test: str=&#34;ttest_ind&#34;,
               alternative: str=&#34;two-sided&#34;,
               significance: str=&#34;numeric&#34;,
               significance_ranges: Dict[str, float]={&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10},
               swarm: bool=False,
               xorder: list=[],
               equal_var: bool=False,**kwargs):
    &#34;&#34;&#34;
    Draw a boxplot with a statistical test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x,y: str
        names of variables in data
    pairs: list, optional
        Category pairs for the statistical test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    test: str, optional
        Method name for the statistical test. Defalt: ttest_ind
        Available methods: [&#34;ttest_ind&#34;,
                            &#34;ttest_rel&#34;,
                            &#34;kruskal&#34;,
                            &#34;mannwhitneyu&#34;,
                            &#34;wilcoxon&#34;,
                            &#34;brunnermunzel&#34;,
                            &#34;median_test&#34;]
    alternative: str [&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;], optional
        Defines the alternative hypothesis. Defalt: &#34;two-sided&#34;
    
    show : bool, optional
        Whether or not to show the figure.
    significance: str [&#39;numeric&#39;, &#39;symbol&#39;], optional
        How to show the significance. &#39;numeric&#39; will show -log10(p values) in the plot and 
        &#39;symbol&#39; will represent significance as asterisks.
    significance_ranges: dict, optional 
        thresholds of -log10(p values) that each asterisk number represents. Ignored when  significance=&#34;numeric&#34;.
        example: {&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10}
    swarm: bool, optional
        Whether or not to superpose a swarm plot. Not recommended if the sample size is too large.
    xorder: list, optional
        The order of x axis labels
    equal_var: bool, optional
        Related to ttest_ind method. The default is True, which will produce a p value equal to t-test in R.
    kwargs: any options accepted by scipy statistical test functions
    
     
    Returns
    -------
    dict(&#34;p values&#34;:pvalues,&#34;axes&#34;:ax)
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    tests=[&#34;ttest_ind&#34;,&#34;ttest_rel&#34;,&#34;kruskal&#34;,&#34;mannwhitneyu&#34;,&#34;wilcoxon&#34;,&#34;brunnermunzel&#34;,&#34;median_test&#34;]
    
    import scipy.stats as stats
    if len(xorder)==0:
        xorder=sorted(list(set(df[x])))
    pvals=[]
    for p1,p2 in pairs:
        
        statstest=getattr(stats, test)
        if test==&#34;wilcoxon&#34; or test==&#34;ttest_rel&#34;:
            _, pval,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;median_test&#34;:
            _, pval,_,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;ttest_ind&#34;:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,equal_var=equal_var,**kwargs)
        
        else:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        
        p1ind=xorder.index(p1)
        p2ind=xorder.index(p2)
        if pval==0:
            pval=np.inf
        else:
            pval=-np.log10(pval)
        pvals.append([np.abs(p2ind-p1ind), np.amin([p2ind, p1ind]),np.amax([p2ind, p1ind]), pval])
    pvals = sorted(pvals, key = lambda x: (x[0], x[1]))
        
    fig, ax=plt.subplots()
    sns.violinplot(data=df, x=x,y=y,inner=&#34;quartile&#34;)
    if swarm==True:
        sns.swarmplot(data=df, x=x,y=y,color=&#34;black&#34;,alpha=0.5)
    ymax=np.amax(df[y])
    newpvals={}
    for i, pval in enumerate(pvals):
        plt.plot([pval[1],pval[2]], [ymax*(1.05+i*0.05),ymax*(1.05+i*0.05)], color=&#34;black&#34;)
        p=np.round(pval[-1],2)
        
        newpvals[xorder[pval[1]]+&#34;_&#34;+xorder[pval[2]]]=p
        if significance==&#34;numeric&#34;:
            annotate=&#34;-log10(p)=&#34;+str(p)
        elif significance==&#34;symbol&#34;:
            keys=sorted(significance_ranges.keys())
            annotate=&#34;NA&#34;
            for j in range(len(keys)):
                if j==0:
                    if p &lt;= significance_ranges[keys[j]]:
                        annotate=&#34;&#34;
                        break
                else:
                    if significance_ranges[keys[j-1]] &lt; p &lt;=significance_ranges[keys[j]]:
                        annotate=keys[i]
                        break
            if annotate==&#34;NA&#34;:
                annotate=keys[-1]
        plt.text((pval[1]+pval[2])/2, ymax*(1.055+i*0.05), annotate)
    if significance==&#34;symbol&#34;:
        ax.annotate(&#34;\n&#34;.join([&#34;{}: p &lt; {:.2E}&#34;.format(k, 10**(-significance_ranges[k])) for k in keys]),
            xy=(0.9,0.9), xycoords=&#39;axes fraction&#39;,
            textcoords=&#39;offset points&#39;,
            size=12,
            bbox=dict(boxstyle=&#34;round&#34;, fc=(0.9, 0.9, 0.9), ec=&#34;none&#34;))
        plt.subplots_adjust(right=0.850)
    
    return {&#34;p values&#34;:newpvals,&#34;axes&#34;:ax}


def stacked_barplot(df: pd.DataFrame,
                    x: Union[str, list],
                    hue: Union[str, list],
                    scale: str=&#34;fraction&#34;,
                    order: list=[],
                    hue_order: list=[],
                    test_pairs: List[List[str]]=[],
                    show_values: bool=True,
                    show: bool=False,
                    figsize: List[int]=[4,6])-&gt; Dict:
    
    &#34;&#34;&#34;
    Drawing a stacked barplot with or without the fisher&#39;s exact test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str or list
        The category to place in x axis. Only str values are accepted.
    hue: str or list
        Counting samples by the hue category. Only str values are accepted.
    order: list, optional
        The order of x axis labels
    hue_order: list, optional
        The order of hue labels
    scale: str, optional
        Scaling method. Available options are: fraction, percentage, absolute
    test_pairs : pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    show_number: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    show : bool, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
     
    Returns
    -------
    dict(&#34;p values&#34;:pvalues,&#34;axes&#34;:ax)
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    if df[x].isnull().values.any():
        df[x]=df[x].replace(np.nan, &#34;NA&#34;)
    
    if df[hue].isnull().values.any():
        df[hue]=df[hue].replace(np.nan, &#34;NA&#34;)
    
    data={}
    if len(order)==0:
        u=np.unique(df[x])
        keys=sorted(list(u))
    else:
        keys=order
    if len(hue_order)==0:
        u=np.unique(df[hue])
        hues=sorted(list(u))
    else:
    
        hues=hue_order
    for key in keys:
        data[key]=[]
        for h in hues:
            data[key].append(np.sum((df[x]==key) &amp; (df[hue]==h)))
    pvals={}
    if len(test_pairs) &gt;0:
        
        for i, h in enumerate(hues):
            pvals[h]=[]
            for p1,p2 in test_pairs:
                idx1=keys.index(p1)
                idx2=keys.index(p2)
                yes_total=np.sum(data[keys[idx1]])
                no_total=np.sum(data[keys[idx2]])
                yes_and_hue=data[keys[idx1]][i]
                no_and_hue=data[keys[idx2]][i]
                table=[[yes_and_hue, no_and_hue],
                       [yes_total-yes_and_hue, no_total-no_and_hue]]
                
                odd, pval=fisher_exact(table)
                pvals[h].append([idx1, idx2, pval])
    if scale==&#34;fraction&#34;:
        for key in keys:
            data[key]=np.array(data[key])/np.sum(data[key])
    elif scale==&#34;percentage&#34;:
        for key in keys:
            data[key]=np.array(data[key])/np.sum(data[key])*100
    bottom=np.zeros([len(keys)])
    cmap=plt.get_cmap(&#34;tab20b&#34;)
    fig, ax=plt.subplots(figsize=figsize)
    plt.subplots_adjust(left=0.2,right=0.6, bottom=0.17)
    if scale==&#34;absolute&#34;:
        unit=&#34;&#34;
    elif scale==&#34;fraction&#34;:
        unit=&#34;&#34;
    elif scale==&#34;percentage&#34;:
        unit=&#34;%&#34;
    pos={}
    for i, h in enumerate(hues):
        
        heights=np.array([data[key][i] for key in keys])
        
        
        plt.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h)
        if show_values==True:
            for j in range(len(keys)):
                if scale==&#34;absolute&#34;:
                    plt.text(j,bottom[j]+heights[j]/2,&#34;{}{}&#34;.format(heights[j],unit), 
                         bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                else:
                    plt.text(j,bottom[j]+heights[j]/2,&#34;{:.2f}{}&#34;.format(heights[j],unit), 
                         bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
        plt.xticks(rotation=90)
        pos[h]={key: [he, bo] for key, he, bo in zip(keys, heights, bottom)}
        bottom+=heights
    ax.legend(loc=[1.01,0])
    ax.set_xlabel(x)
    if scale==&#34;absolute&#34;:
        ylabel=&#34;Counts&#34;
    elif scale==&#34;fraction&#34;:
        ylabel=&#34;Fraction&#34;
    elif scale==&#34;percentage&#34;:
        ylabel=&#34;Percentage&#34;
    ax.set_ylabel(ylabel)
    
    if len(pvals)&gt;0:
        print(&#34;mlp stands for -log10(p value)&#34;)
        for i, h in enumerate(hues):
            _pos=pos[h]
            for idx1, idx2, pval in pvals[h]:
                if pval &lt; 0.05:
                    he1, bot1=_pos[keys[idx1]]
                    he2, bot2=_pos[keys[idx2]]
                    line, =plt.plot([idx1,idx2],[he1/2+bot1,he2/2+bot2],color=&#34;gray&#34;)
                    # r1=ax.transData.transform([idx1, he1/2+bot1])
                    # r2=ax.transData.transform([idx2, he2/2+bot2])
                    r1=np.array([idx1, he1/2+bot1])
                    r2=np.array([idx2, he2/2+bot2])
                    r=r2-r1
                    print(ax.get_xlim(),ax.get_ylim())
                    r=np.array([1,3])*r/np.array([ax.get_xlim()[1]-ax.get_xlim()[0],ax.get_ylim()[1]-ax.get_ylim()[0]])
                    #r=ax.transData.transform(r)
                    if idx2&lt;idx1:
                        r=-r
                    print(r)
                    r=r*(r @ r)**(-0.5)
                    print(h,r)
                    angle=np.arccos(r[0])
                    if r[1]&lt;0:
                        angle= -angle
                    print(angle)
                    _line_annotate( &#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)), line, (idx1+idx2)/2, color=&#34;magenta&#34;)
                    # plt.text((idx1+idx2)/2, 0.5*(he1/2+bot1+he2/2+bot2), &#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)), 
                    #          color=&#34;magenta&#34;, va=&#34;center&#34;,ha=&#34;center&#34;, rotation=360*angle/(2*np.pi),)
                    # plt.annotate(&#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)),[(r1[0]+r2[0])/2, 0.5*(r1[1]+r2[1])],   
                    #          color=&#34;magenta&#34;,ha=&#34;center&#34;, rotation=360*angle/(2*np.pi),xycoords=&#39;figure pixels&#39;)
                    #
    if show:
        plt.show()
    
    return {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}


def _stacked_barplot(df: pd.DataFrame,
                    x: Union[str, list],
                    hue: Union[str, list],
                    scale: str=&#34;fraction&#34;,
                    order: Optional[list]=None,
                    hue_order: Optional[list]=None,
                    test_pairs: List[List[str]]=[],
                    show_values: bool=True,
                    show: bool=False,
                    figsize: List[int]=[4,6])-&gt; Dict:
    
    &#34;&#34;&#34;
    Drawing a stacked barplot with or without the fisher&#39;s exact test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str or list
        The category to place in x axis. Only str values are accepted.
    hue: str or list
        Counting samples by the hue category. Only str values are accepted.
    order: list, optional
        The order of x axis labels
    hue_order: list, optional
        The order of hue labels
    scale: str, optional
        Scaling method. Available options are: fraction, percentage, absolute
    test_pairs : pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    show_number: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    show : bool, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
     
    Returns
    -------
    dict {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    if type(x)==str:
        x=[x]
        if order!=None:
            order=[order]
    if type(hue)==str:
        hue=[hue]
        if hue_order!=None:
            hue_order=[hue_order]
    for _x in x:
        if df[_x].isnull().values.any():
            df[_x]=df[_x].replace(np.nan, &#34;NA&#34;)
    for _hue in hue:
        if df[_hue].isnull().values.any():
            df[_hue]=df[_hue].replace(np.nan, &#34;NA&#34;)

    xkeys={}
    keysx={}
    for i, _x in enumerate(x):
        if order==None:
            u=np.unique(df[_x])
            keys=sorted(list(u))
        else:
            keys=order[i]
        xkeys[_x]=keys
        for k in keys:
            keysx[k]=_x
    huekeys={}
    for i, _hue in enumerate(hue):
        if hue_order==None:
            u=np.unique(df[_hue])
            hues=sorted(list(u))
        else:
        
            hues=hue_order[i]
        huekeys[_hue]=hues
    
    data={}
    for _x, keys in xkeys.items():
        data[_x]={}
        for key in keys:
            
            for _hue, hues in  huekeys.items():
                if _x==_hue:
                    continue
                if not _hue in data[_x]:
                    data[_x][_hue]={}
                data[_x][_hue][key]=[]
                for h in hues:
                    data[_x][_hue][key].append(np.sum((df[_x]==key) &amp; (df[_hue]==h)))

    
    pvals={}
    if len(test_pairs) &gt;0:
        for _hue in hue:
            
            for i, h in enumerate(huekeys[_hue]):
                
                for p1,p2 in test_pairs:
                    _x=keysx[p1]
                    __x=keysx[p2]
                    if _x!=__x:
                        raise Exception(&#34;{} and {} can not be compared.&#34;.format(p1, p2))
                    
                    if _x==_hue:
                        continue
                    
                    if not _x in pvals:
                        pvals[_x]={}
                    if not _hue in pvals[_x]:
                        pvals[_x][_hue]={}
                    if not h in pvals[_x][_hue]:
                        pvals[_x][_hue][h]=[]
                    keys=xkeys[_x]
                    idx1=xkeys[_x].index(p1)
                    idx2=xkeys[_x].index(p2)
                    yes_total=np.sum(data[_x][_hue][keys[idx1]])
                    no_total=np.sum(data[_x][_hue][keys[idx2]])
                    yes_and_hue=data[_x][_hue][keys[idx1]][i]
                    no_and_hue=data[_x][_hue][keys[idx2]][i]
                    table=[[yes_and_hue, no_and_hue],
                           [yes_total-yes_and_hue, no_total-no_and_hue]]
        
                    odd, pval=fisher_exact(table)
                    pvals[_x][_hue][h].append([idx1, idx2, pval])
    if scale==&#34;fraction&#34;:
        for _x in x:
            for _hue in hue:
                if _x==_hue:
                    continue
                for key in keys:
                    data[_x][_hue][key]=np.array(data[_x][_hue][key])/np.sum(data[_x][_hue][key])
    elif scale==&#34;percentage&#34;:
        for _x in x:
            for _hue in hue:
                if _x==_hue:
                    continue
                for key in keys:
                    data[_x][_hue][key]=np.array(data[_x][_hue][key])/np.sum(data[_x][_hue][key])*100
    
    cmap=plt.get_cmap(&#34;tab20b&#34;)
    ncols=len(x)*len(hue)-len(set(x)&amp;set(hue))
    figsize=[4*ncols, 6]
    fig, axes=plt.subplots(figsize=figsize,ncols=ncols)
    #plt.subplots_adjust(left=0.2,right=0.6, bottom=0.17)
    axes=axes.flatten()
    
    if scale==&#34;absolute&#34;:
        unit=&#34;&#34;
    elif scale==&#34;fraction&#34;:
        unit=&#34;&#34;
    elif scale==&#34;percentage&#34;:
        unit=&#34;%&#34;
    axindex=0
    pos={}
    for _x in x:
        pos[_x]={}
        for _hue in hue:
            if _x==_hue:
                continue
            pos[_x][_hue]={}
            keys=xkeys[_x]
            hues=huekeys[_hue]
            bottom=np.zeros([len(keys)])
            for i, h in enumerate(hues):
                ax=axes[axindex]
                
                heights=np.array([data[_x][_hue][key][i] for key in keys])
                
                
                ax.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h)
                if show_values==True:
                    for j in range(len(keys)):
                        if scale==&#34;absolute&#34;:
                            ax.text(j,bottom[j]+heights[j]/2,&#34;{}{}&#34;.format(heights[j],unit), 
                                 bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                        else:
                            ax.text(j,bottom[j]+heights[j]/2,&#34;{:.2f}{}&#34;.format(heights[j],unit), 
                                 bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                ax.set_xticks(ax.get_xticks())
                ax.set_xticklabels(ax.get_xticklabels(), rotation=90)
                pos[_x][_hue][h]={key: [he, bo] for key, he, bo in zip(keys, heights, bottom)}
                bottom+=heights
            ax.legend(loc=[1.01,0])
            ax.set_xlabel(_x)
            if scale==&#34;absolute&#34;:
                ylabel=&#34;Counts&#34;
            elif scale==&#34;fraction&#34;:
                ylabel=&#34;Fraction&#34;
            elif scale==&#34;percentage&#34;:
                ylabel=&#34;Percentage&#34;
            ax.set_ylabel(ylabel)
            axindex+=1
            if len(pvals)&gt;0 and _x in pvals:
                print(&#34;mlp stands for -log10(p value)&#34;)
                for _hue in hue:
                    if _x==_hue:
                        continue
                    if not _hue in pos[_x]:
                        continue
                    hues=huekeys[_hue]
                    for i, h in enumerate(hues):
                        print(pos)
                        print(pos[_x])
                        _pos=pos[_x][_hue][h]
                        for idx1, idx2, pval in pvals[_x][_hue][h]:
                            
                            he1, bot1=_pos[keys[idx1]]
                            he2, bot2=_pos[keys[idx2]]
                            line, =ax.plot([idx1,idx2],[he1/2+bot1,he2/2+bot2],color=&#34;gray&#34;)
                            # r1=ax.transData.transform([idx1, he1/2+bot1])
                            # r2=ax.transData.transform([idx2, he2/2+bot2])
                            r1=np.array([idx1, he1/2+bot1])
                            r2=np.array([idx2, he2/2+bot2])
                            r=r2-r1
                            print(ax.get_xlim(),ax.get_ylim())
                            r=np.array([1,3])*r/np.array([ax.get_xlim()[1]-ax.get_xlim()[0],ax.get_ylim()[1]-ax.get_ylim()[0]])
                            #r=ax.transData.transform(r)
                            if idx2&lt;idx1:
                                r=-r
                            print(r)
                            r=r*(r @ r)**(-0.5)
                            print(h,r)
                            angle=np.arccos(r[0])
                            if r[1]&lt;0:
                                angle= -angle
                            print(angle)
                            if pval &lt; 0.05:
                                pval_str=str(np.round(-np.log10(pval), decimals=1))
                            else:
                                pval_str=&#34;ns&#34;
                            _line_annotate( &#34;mlp=&#34;+pval_str, line, (idx1+idx2)/2, color=&#34;magenta&#34;)
                                
                                
    plt.tight_layout(w_pad=2)
    if show:
        plt.show()
    
    return {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}


def nice_piechart(df: pd.DataFrame, 
                  category: Union[str, List[str]],
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True) -&gt;Dict:
    
    if type(category)==str:
        category=[category]
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=[ncols*2,
                                                        nrows*2])
    axes=axes.flatten()
    for cat, ax in zip(category, axes):
        u, c=np.unique(df[cat], return_counts=True)
        
        srt=np.argsort(c)[::-1]
        u=u[srt]
        c=c[srt]
        _c=c/np.sum(c)
        
        
        
        _cmap=plt.get_cmap(palette, c.shape[0])
        colors=[_cmap(i) for i in range(c.shape[0])]
        for j in range(c.shape[0]):
            if _c[j]&lt;ignore:
                colors[j]=[0,0,0,1]
                u[j]=&#34;&#34;
                continue
            if show_values==True:
                u[j]=u[j]+&#34;\n(&#34;+str(100*np.round(_c[j],1))+&#34;%)&#34;
        
        ax.pie(c, labels=u, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=10)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.9)
    return {&#34;axes&#34;:ax}


def nice_piechart_num(df: pd.DataFrame,hue: List[str],
                      category: str=&#34;&#34; ,
                  
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True,
                  figsize=[]) -&gt;Dict:
    
    if category==&#34;&#34;:
        category=list(df.index)
    else:
        df=df.set_index(category)
        category=list(df.index)
        
    df=df[hue]
    srt=np.argsort(df.sum(axis=0))[::-1]
    df=df[df.columns[srt]]
    hue=list(df.columns)
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    if len(figsize)==0:
        figsize=[ncols*2,nrows*2]
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize)
    axes=axes.flatten()
    _cmap=plt.get_cmap(palette, len(hue))
    colors=[_cmap(i) for i in range(len(hue))]
    for cat, ax in zip(category, axes):
        c=df.loc[cat]
        _c=c/np.sum(c)
        ax.pie(c, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=8)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.95, right=0.81)
    
    legend_elements = [Line2D([0], [0], marker=&#39;o&#39;, color=&#39;lavender&#39;, label=huelabel,markerfacecolor=color, markersize=10)
                      for color, huelabel in zip(colors, hue)]
    
    fig.legend(handles=legend_elements,bbox_to_anchor=(1, 1))
    return {&#34;axes&#34;:ax}

def correlation(df: pd.DataFrame, 
                category: Union[str, list]=[],
                method=&#34;pearson&#34;,
                palette: str=&#34;coolwarm&#34;,
                figsize=[6,6],
                show_val=False,
                clustermap_param:dict={},
                ztransform: bool=True,
                xticklabels =False,
                yticklabels=False):
    &#34;&#34;&#34;
    Drawing a heatmap with correlations or distances between observations 
    
    Parameters
    ----------
    df : pandas DataFrame
        
    category: str or list, optional
        the names of categorical values to display as color labels
    mthod: str
        method for correlation/distance calculation. Defalt: &#34;pearson&#34;
        
    palette : str
        A colormap name
    show_val: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    clustermap_param : dict, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
    ztransform : bool, optional
        Whether to transform values to z-score
    xticklabels, yticklabels : bool
        Whether to show the label names in the heatmap
    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    original_index=df.index
    
    if len(category) !=0:

        if type(category)==str:
            category=[category]
        #df=df.drop(category, axis=1)
        valnames=list(set(df.columns) -set(category)) 
        X = df[valnames].values
        assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        X = df.values
        assert X.dtype==float, &#34;data must contain only float values.&#34;
    if ztransform==True:
        X=zscore(X, axis=0)
    if method==&#34;pearson&#34;:
        dmat=Parallel(n_jobs=-1)(delayed(_calc_pearson)(ind, X) for ind in list(it.combinations(range(X.shape[0]), 2)))
        dmat=np.array(dmat)
        dmat=squareform(dmat)
        print(dmat)
        dmat+=np.identity(dmat.shape[0])
    else:
        dmat=squareform(pdist(X, method))
    if method==&#34;pearson&#34;:
            title=&#34;Pearson correlation&#34;
    else:
        title=method+&#34; distance&#34;    
        
        
    if len(category) &gt;0:
        dfm=pd.DataFrame(data=dmat)
        colnames=dfm.columns
        for cat in category:
            dfm[cat]=df[cat].values
        res=complex_clustermap(dfm,
                               heatmap_col=colnames, 
                               row_colors=category,
                               ztranform=False,
                               xticklabels=xticklabels,
                               yticklabels=yticklabels,
                               figsize=figsize,
                               cbar_kws={&#34;label&#34;:title}, )
        return res
    else:
        
        g=sns.clustermap(data=dmat,xticklabels=xticklabels,yticklabels=yticklabels,
                   method=&#34;ward&#34;, cmap=palette,
                   col_cluster=True,
                   row_cluster=True,
                   figsize=figsize,
                   rasterized=True,
                    #cbar_kws={&#34;label&#34;:&#34;Pearson correlation&#34;}, 
                   annot=show_val,
                   **clustermap_param)
        
        g.cax.set_ylabel(title, rotation=-90,va=&#34;bottom&#34;)
        plt.setp(g.ax_heatmap.get_yticklabels(), rotation=0)  # For y axis
        plt.setp(g.ax_heatmap.get_xticklabels(), rotation=90) # For x axis
        return {&#34;grid&#34;:g}


def pie_scatter(df: pd.DataFrame,  
                x: str, 
                y: str, 
                category: list, 
                pie_palette: str=&#34;tab20c&#34;,
                xlabel: str=&#34;&#34;,
                ylabel: str=&#34;&#34;,
                piesize: float=0.01, 
                label: Union[List, str]=&#34;all&#34;,topn=10,
                logscalex: bool=False,
                logscaley: bool=False,
                ax: Optional[plt.Axes]=None,
                sizes: Union[List, str]=&#34;&#34;,
                save: str=&#34;&#34;,
                show: bool=False,
                edge_color: str=&#34;gray&#34;,
                min_piesize: float=0.3,
                figsize=[6,6]) -&gt; dict:
    &#34;&#34;&#34;
    Drawing a scatter plot of which points are represented by pie charts. 
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide form dataframe. Index names are used to label points
        e.g.) 
                    gas    coal    nuclear    population    GDP
            USA      20      20          5            20     50
            China    30      40          5            40     50
            India     5      10          1            40     10
            Japan     5       5          1            10     10
            
    x,y : str
        the names of columns to be x and y axes of the scatter plot.
        
    category: str or list
        the names of categorical values to display as pie charts
    
    pie_palette : str
        A colormap name
    xlabel: str, optional
        x axis label
    ylabel: str, optional
        y axis label
    piesize: float, optional (default: 0.01) 
        pie chart size. 
    label: str, optional (default: &#34;all&#34;)
        &#34;all&#34;: all 
        &#34;topn_of_sum&#34;:
    logscalex, logscaley: bool, optional (default: False)
        Whether to scale x an y axes with logarithm
    ax: Optional[plt.Axes] optional, (default: None)
        pyplot ax to add this scatter plot
    sizes: Union[List, str], optional (default: &#34;&#34;)
        pie chart sizes.
            &#34;sum_of_each&#34;: automatically set pie chart sizes to be proportional to the sum of all categories.
            list: the list of pie chart sizes
    edge_color: str=&#34;gray&#34;,
        The pie chart edge color
    min_piesize: float, optional (default: 0.3)
        Minimal pie chart size. This option is effective when the option sizes=&#34;sum_of_each&#34;. 
    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if type(pie_palette)== str:
        colors={}
        unique_labels=category
            
        cmap=plt.get_cmap(pie_palette)
        labelnum=len(unique_labels)
        for i, ul in enumerate(unique_labels):
            colors[ul]=cmap(i/labelnum)
    elif type(pie_palette)==dict:
        colors=pie_palette
        unique_labels=colors.keys()
    else:
        raise Exception(&#34;Unknown pie_palette type.&#34;)
    if ax ==None:
        fig, ax=plt.subplots(figsize=figsize)
    plt.subplots_adjust(right=0.80)
    X=df[x]
    Y=df[y]
    yscale=&#34;&#34;
    xscale=&#34;&#34;
    if logscaley==True:
        Y=np.log10(Y+1)
        yscale=&#34; (scaled by log10)&#34;
    if logscalex==True:
        X=np.log10(X+1)
        xscale=&#34; (scaled by log10)&#34;
    Frac=df[category]
    
    index=df.index
    piesize=np.amax([np.amax(X), np.amax(Y)])*piesize
    
    if sizes==&#34;sum_of_each&#34;:
        sums=Frac.sum(axis=1)
        sumsrt=np.argsort(sums)[::-1]
        sumsrt=set(sumsrt[:topn])
        sums=sums/np.amax(sums)
        sums=piesize*(sums+min_piesize)
    _colors=[colors[f] for f in unique_labels]
    for i, (_x, _y, _ind) in enumerate(zip(X, Y, index)):
        _frac=Frac.loc[_ind].values 
        _frac=2*np.pi*np.array(_frac)/np.sum(_frac)
        
        angle=0
        #print(sums.loc[_ind])
        for fr, co in zip(_frac, _colors):
            if type(sizes)==str:
                if sizes==&#34;sum_of_each&#34;:
                    _baumkuchen_xy(ax, _x, _y, angle, fr, 0, sums.loc[_ind],20, co, edge_color=edge_color)
                elif sizes==&#34;&#34;:
                    _baumkuchen_xy(ax, _x, _y, angle, fr, 0, piesize,20, co, edge_color=edge_color)
                else:
                    pass
            elif type(sizes)==list and len(sizes) !=0:
                _baumkuchen_xy(ax, _x, _y, angle, fr, 0, piesize*sizes[i],20, co, edge_color=edge_color)
            else:
                _baumkuchen_xy(ax, _x, _y, angle, fr, 0, piesize,20, co, edge_color=edge_color)
            angle+=fr
        
        if type(label)==str:
            if label==&#34;all&#34;:
                ax.text(_x, _y,_ind)
            elif label==&#34;topn_of_sum&#34;:
                if i in sumsrt:
                    ax.text(_x, _y,_ind)
                
            elif label==&#34;&#34;:
                pass
        elif type(label)==list:
            if _ind in label:
                ax.text(_x, _y,_ind)
            
            
    if xlabel!=&#34;&#34;:
        x=xlabel
    if ylabel!=&#34;&#34;:
        y=ylabel
    plt.xlabel(x+xscale)
    plt.ylabel(y+yscale)
    legend_elements = [Line2D([0], [0], marker=&#39;o&#39;, color=&#39;lavender&#39;, label=ul,markerfacecolor=colors[ul], markersize=10)
                      for ul in unique_labels]
    
    ax.legend(handles=legend_elements,bbox_to_anchor=(0.95, 1))
    _save(save, &#34;pie_scatter&#34;)
    return {&#34;axes&#34;:ax}

def stackedlines(df: pd.DataFrame, 
                x: str,
                y: list,
                sort: bool=True,
                title: str=&#34;&#34;,
                inverse: bool=False,
                show_val: bool=False,
                remove_all_zero: bool=False,
                palette: str=&#34;tab20c&#34;,
                figsize=[7,4],
                ax: Optional[plt.Axes]=None,
                alpha: float=0.75,
                bbox_to_anchor: list=[1.7, 1],
                right: float=0.7,
                bottom: float=0.120,
                show_legend: bool=True,
                xlabel: str=&#34;&#34;,
                ylabel: str=&#34;&#34;,):
    &#34;&#34;&#34;
    Drawing a scatter plot of which points are represented by pie charts. 
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide form dataframe. Index names are used to label points
        e.g.) 
              year    biofuel_consumption    coal_consumption    gas_consumption    hydro_consumption    nuclear_consumption    oil_consumption
        90    1990                 16.733            5337.998           5170.609              864.271               1723.004           9306.913
        91    1991                 19.389            5287.613           5283.972              849.620               1829.645           9108.509
        92    1992                 22.045            5324.031           5463.509              743.463               1848.197           9297.387
        93    1993                 25.759            5522.452           5599.419              825.742               1822.853           9376.045
        94    1994                 28.846            5543.144           5731.081              766.870               1912.903           9619.746
        95    1995                 30.942            5593.053           5979.829              920.274               2011.356           9597.527            
    x : str
        the name of a column to be the x axis of the plot.
        
    y: list
        the names of categorical values to display as stacked lines
    sort: bool, optional (default: True)
        Whether to sort lines based on their values
    show_val: bool, optional (default: False)
        Whether to show percentages at the end of lines.
    
    remove_all_zero: bool, optional (default: False)    
    
    pie_palette : str
        A colormap name
    xlabel: str, optional
        x axis label
    ylabel: str, optional
        y axis label
    ax: Optional[plt.Axes] optional, (default: None)
        pyplot ax to add this scatter plot


    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    df=df.fillna(0)
    X=np.array(df[x])
    Y=[]
    for col in y:
        Y.append(np.array(df[col]))
    Y=np.array(Y)
    if remove_all_zero==True:
        filter=Y.sum(axis=0)!=0
        Y=Y[:,filter]
        X=X[filter]
    Ydict={col:[] for col in y}
    if sort==True:
        for i, _x in enumerate(X):
            
            srtidx=np.argsort(Y[:,i])
            _bottom=0
            for _idx in srtidx:
                _col=y[_idx]
                yval=Y[_idx,i]
                Ydict[_col].append([_bottom, yval+_bottom])
                _bottom+=yval
    else:
        for i, _x in enumerate(X):

            _bottom=0
            for _idx,_col in enumerate(y):
                yval=Y[_idx,i]
                Ydict[_col].append([_bottom, yval+_bottom])
                _bottom+=yval
    if ax ==None:
        fig, ax=plt.subplots(figsize=figsize)
        
    cmap=plt.get_cmap(palette, len(y))
    colorlut={col: cmap(i) for i, col in enumerate(y)}
    last_vals=[]
    last_pos=[]
    for col, vals in Ydict.items():
        vals=np.array(vals)
        ax.fill_between(X, vals[:,0], vals[:,1], label=col, alpha=alpha, color=colorlut[col])
        last_vals.append(vals[-1,1]-vals[-1,0])
        last_pos.append(vals[-1,1]/2+vals[-1,0]/2)
    if show_val==True:
        last_vals=100*np.array(last_vals)/np.sum(last_vals)
        for val, pos in zip(last_vals, last_pos):
            ax.text(X[-1], pos, str(np.round(val, 1))+&#34;%&#34;)
            
    if show_legend==True:
        plt.legend(bbox_to_anchor=bbox_to_anchor)
    plt.subplots_adjust(right=right, bottom=bottom)
    if xlabel !=&#34;&#34;:
        ax.set_xlabel(xlabel)
    else:
        ax.set_xlabel(x)
    ax.set_ylabel(ylabel)
    ax.set_title(title)
    
if __name__==&#34;__main__&#34;:
    
    
    
    #test=&#34;dotplot&#34;
    #test=&#34;triangle_heatmap&#34;
    test=&#34;decomp&#34;
    test=&#34;manifold&#34;
    test=&#34;triangle_heatmap&#34;
    
    test=&#34;decomp&#34;
    
    
    test=&#34;radialtree&#34;
    
    test=&#34;violinplot&#34;
    test=&#34;cluster&#34;
    test=&#34;regression&#34;
    
    test=&#34;complex_clustermap&#34;
    test=&#34;stacked&#34;
    test=&#34;dotplot&#34;
    test=&#34;regression&#34;
    
    test=&#34;nice_piechart_num&#34;
    test=&#34;pie_scatter&#34;
    test=&#34;stackedlines&#34;
    if test==&#34;stackedlines&#34;:
        f=&#34;/media/koh/grasnas/home/data/omniplot/energy/owid-energy-data.csv&#34;
        df=pd.read_csv(f)
        _df=df.loc[df[&#34;country&#34;]==&#34;United States&#34;]
        cols=[&#39;biofuel_consumption&#39;,
             &#39;coal_consumption&#39;,
             &#39;gas_consumption&#39;,
             &#39;hydro_consumption&#39;,
             &#39;nuclear_consumption&#39;,
             &#39;oil_consumption&#39;,
             &#39;other_renewable_consumption&#39;,
             &#39;solar_consumption&#39;,
             &#39;wind_consumption&#39;]
        stackedlines(df=_df, x=&#34;year&#34;,y=cols,title=&#34;United States&#34;, remove_all_zero=True,show_val=True)
        plt.show()
    elif test==&#34;correlation&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        
            
        correlation(df, category=[&#34;species&#34;, &#34;island&#34;,&#34;sex&#34;], method=&#34;pearson&#34;, ztransform=True)
        plt.show()
    elif test==&#34;nice_piechart&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        tmp=[]
        for num, (sp, i ,se) in enumerate(zip(df[&#34;species&#34;], df[&#34;island&#34;],df[&#34;sex&#34;])):
            if num/df.shape[0] &gt; 0.98:
                tmp.append(&#34;NA&#34;)
            else:
                tmp.append(sp[0]+&#34;_&#34;+i[0]+&#34;_&#34;+se[0])
        df[&#34;combine&#34;]=tmp
        print(df)
        nice_piechart(df, category=[&#34;species&#34;, &#34;island&#34;,&#34;sex&#34;,&#34;species&#34;, &#34;island&#34;,&#34;sex&#34;,&#34;combine&#34;],ncols=4)
        plt.show()
    elif test==&#34;regression&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        regression_single(df, x=&#34;bill_length_mm&#34;,y=&#34;body_mass_g&#34;, method=&#34;robust&#34;,category=&#34;species&#34;)
        plt.show()
    elif test==&#34;dotplot&#34;:
        df=pd.DataFrame({&#34;Experiments&#34;:[&#34;exp1&#34;,&#34;exp1&#34;,&#34;exp1&#34;,&#34;exp1&#34;,&#34;exp2&#34;,&#34;exp2&#34;,&#34;exp3&#34;],
                         &#34;GO&#34;:[&#34;nucleus&#34;,&#34;cytoplasm&#34;,&#34;chromosome&#34;,&#34;DNA binding&#34;,&#34;chromosome&#34;,&#34;RNA binding&#34;,&#34;RNA binding&#34;],
                         &#34;FDR&#34;:[10,1,5,3,1,2,0.5],
                         &#34;odds&#34;:[3.3,1.1,2.5,2.1,0.8,2.3,0.9]})
        dotplot(df, row=&#34;GO&#34;,col=&#34;Experiments&#34;, size_val=&#34;FDR&#34;,color_val=&#34;odds&#34;, highlight=&#34;FDR&#34;,
        color_title=&#34;Odds&#34;, size_title=&#34;-log10 p&#34;,scaling=20)
        # df=pd.read_csv(&#34;/home/koh/ews/idr_revision/clustering_analysis/cellloc_longform.csv&#34;)
        # print(df.columns)
        # df=df.fillna(0)
        # #dotplot(df, size_val=&#34;pval&#34;,color_val=&#34;odds&#34;, highlight=&#34;FDR&#34;,color_title=&#34;Odds ratio&#34;, size_title=&#34;-log10 p value&#34;,scaling=20)
        #
        # dotplot(df, row=&#34;Condensate&#34;,col=&#34;Cluster&#34;, size_val=&#34;pval&#34;,color_val=&#34;odds&#34;, highlight=&#34;FDR&#34;,
        #         color_title=&#34;Odds&#34;, size_title=&#34;-log10 p value&#34;,scaling=20)
        plt.show()
    elif test==&#34;triangle_heatmap&#34;:
        s=20
        mat=np.arange(s*s).reshape([s,s])
        import string, random
        letters = string.ascii_letters+string.digits
        labels=[&#39;&#39;.join(random.choice(letters) for i in range(10)) for _ in range(s)]
        df=pd.DataFrame(data=mat, index=labels, columns=labels)
        triangle_heatmap(df,grid_pos=[2*s//10,5*s//10,7*s//10],grid_labels=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;D&#34;])
    elif test==&#34;complex_clustermap&#34;:
        # _df=pd.DataFrame(np.arange(100).reshape([10,10]))
        # cmap=plt.get_cmap(&#34;tab20b&#34;)
        # complex_clustermap(_df,
        #                    row_colormap={&#34;test1&#34;:[cmap(v) for v in np.linspace(0,1,10)]},
        #                    row_plot={&#34;sine&#34;:np.sin(np.linspace(0,np.pi,10))},
        #                    approx_clusternum=3,
        #                    merginalsum=True)
        df=sns.load_dataset(&#34;penguins&#34;)
        
        df=df.dropna(axis=0)
        dfcol=pd.DataFrame({&#34;features&#34;:[&#34;bill&#34;,&#34;bill&#34;,&#34;flipper&#34;]})
        complex_clustermap(df,
                           dfcol=dfcol,
                           
                            heatmap_col=[&#34;bill_length_mm&#34;,&#34;bill_depth_mm&#34;,&#34;flipper_length_mm&#34;],
                            row_colors=[&#34;species&#34;,&#34;sex&#34;],
                            row_scatter=[&#34;body_mass_g&#34;],
                            row_plot=[&#34;body_mass_g&#34;],
                            row_bar=[&#34;body_mass_g&#34;],
                            col_colors=[&#34;features&#34;],
                            approx_clusternum=3,
                            merginalsum=True)
        plt.show()
    elif test==&#34;radialtree&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        radialtree(df, category=[&#34;species&#34;,&#34;island&#34;,&#34;sex&#34;])
        plt.show()
    elif test==&#34;decomp&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        features=[&#34;species&#34;,&#34;bill_length_mm&#34;,&#34;bill_depth_mm&#34;,&#34;flipper_length_mm&#34;,&#34;body_mass_g&#34;]
        df=df[features]
        decomplot(df,category=&#34;species&#34;,method=&#34;pca&#34;)
        plt.show()
    elif test==&#34;manifold&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        features=[&#34;species&#34;,&#34;bill_length_mm&#34;,&#34;bill_depth_mm&#34;,&#34;flipper_length_mm&#34;,&#34;body_mass_g&#34;]
        df=df[features]
        manifoldplot(df,category=&#34;species&#34;,method=&#34;tsne&#34;)
        plt.show()
    elif test==&#34;cluster&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        features=[&#34;species&#34;,&#34;sex&#34;,&#34;bill_length_mm&#34;,&#34;bill_depth_mm&#34;,&#34;flipper_length_mm&#34;,&#34;body_mass_g&#34;]
        df=df[features]
        clusterplot(df,category=[&#34;species&#34;,&#34;sex&#34;],method=&#34;kmeans&#34;,n_clusters=&#34;auto&#34;)
        #clusterplot(df,category=&#34;species&#34;,method=&#34;dbscan&#34;,eps=0.35)
        plt.show()
    elif test==&#34;violinplot&#34;:
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        violinplot(df,x=&#34;species&#34;,y=&#34;bill_length_mm&#34;, 
                   pairs=[[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],[&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],[&#34;Adelie&#34;,&#34;Gentoo&#34; ]],
                   test=&#34;mannwhitneyu&#34;,
                   significance=&#34;symbol&#34;,swarm=True)
        plt.show()
    elif test==&#34;stacked&#34;: 
        df=sns.load_dataset(&#34;penguins&#34;)
        df=df.dropna(axis=0)
        _stacked_barplot(df, x=[&#34;species&#34;,&#34;island&#34;],hue=[&#34;sex&#34;,&#34;island&#34;], scale=&#34;absolute&#34;, test_pairs=[[&#34;Adelie&#34;,&#34;Gentoo&#34;]])
        plt.show()
    elif test==&#34;pie_scatter&#34;:
        f=&#34;/home/koh/ews/omniplot/data/energy_vs_gdp.csv&#34;
        df=pd.read_csv(f, comment=&#39;#&#39;)
        df=df.set_index(&#34;country&#34;)
        pie_scatter(df, x=&#34;gdppc&#34;,y=&#34;pop&#34;, category=[&#39;biofuel_electricity&#39;,
                                                     &#39;coal_electricity&#39;,
                                                     &#39;gas_electricity&#39;,
                                                     &#39;hydro_electricity&#39;,
                                                     &#39;nuclear_electricity&#39;,
                                                     &#39;oil_electricity&#39;,
                                                     &#39;other_renewable_electricity&#39;,
                                                     &#39;solar_electricity&#39;,
                                                     &#39;wind_electricity&#39;],logscalex=True,logscaley=True,
                                                    sizes=&#34;sum_of_each&#34;,
                                                    min_piesize=0.1,piesize=0.05, label=&#34;topn_of_sum&#34;)
        
        
        plt.show()
    
    elif test==&#34;nice_piechart_num&#34;:
        f=&#34;/home/koh/ews/omniplot/data/energy_vs_gdp.csv&#34;
        df=pd.read_csv(f)
        df=df.set_index(&#34;country&#34;, comment=&#39;#&#39;)
        nice_piechart_num(df, hue=[&#39;biofuel_electricity&#39;,
                                                     &#39;coal_electricity&#39;,
                                                     &#39;gas_electricity&#39;,
                                                     &#39;hydro_electricity&#39;,
                                                     &#39;nuclear_electricity&#39;,
                                                     &#39;oil_electricity&#39;,
                                                     &#39;other_renewable_electricity&#39;,
                                                     &#39;solar_electricity&#39;,
                                                     &#39;wind_electricity&#39;],ncols=10)
        
        
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="omniplot.plot.clusterplot"><code class="name flex">
<span>def <span class="ident">clusterplot</span></span>(<span>df, category: Union[List[str], str] = '', method: str = 'kmeans', n_clusters: Union[str, int] = 3, x: str = '', y: str = '', reduce_dimension: str = 'umap', testrange=[1, 20], show: bool = False, min_dist: float = 0.25, n_neighbors: int = 15, eps: Union[List[float], float] = 0.5, pcacomponent: Optional[int] = None, ztranform=True, palette=['Spectral', 'cubehelix'], save: str = '', **kwargs) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Clustering data and draw them as a scatter plot optionally with dimensionality reduction.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>the column name of a known sample category (if exists).</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Method name for clustering.
Available methods: ["kmeans",
"hierarchical",
"dbscan",
]</dd>
<dt><strong><code>n_clusters</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>The number of clusters to be created. If "auto" is provided, it will estimate optimal
cluster numbers with "Sum of squared distances" for k-mean clustering and silhouette method for others.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>int</code> or <code>list[int]</code></dt>
<dd>DBSCAN's hyper parameter. It will affect the total number of clusters.</dd>
<dt><strong><code>reduce_dimension</code></strong> :&ensp;<code>str</code></dt>
<dd>Dimensionality reduction method. Default: umap.
if "" is passed, no reduction methods are applied. In this case, data must be 2 dimention or x and y options must be specified.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clusterplot(df,category: Union[List[str], str]=&#34;&#34;, 
              method: str=&#34;kmeans&#34;,
              n_clusters: Union[str , int]=3,
              x: str=&#34;&#34;,
              y: str=&#34;&#34;,
              reduce_dimension: str=&#34;umap&#34;, 
              testrange=[1,20],
              show: bool=False,
              min_dist: float=0.25,
              n_neighbors: int=15,
              eps: Union[List[float], float]=0.5,
              pcacomponent: Optional[int]=None,
              ztranform=True,
              palette=[&#34;Spectral&#34;,&#34;cubehelix&#34;],save: str=&#34;&#34;,**kwargs)-&gt;Dict:
    &#34;&#34;&#34;
    Clustering data and draw them as a scatter plot optionally with dimensionality reduction.  
    
    Parameters
    ----------
    df : pandas DataFrame
    
    category: str
        the column name of a known sample category (if exists). 
    method: str
        Method name for clustering. 
        Available methods: [&#34;kmeans&#34;, 
                            &#34;hierarchical&#34;,
                            &#34;dbscan&#34;,
                            ]
    n_clusters: int or str
        The number of clusters to be created. If &#34;auto&#34; is provided, it will estimate optimal 
        cluster numbers with &#34;Sum of squared distances&#34; for k-mean clustering and silhouette method for others. 
    eps: int or list[int]
        DBSCAN&#39;s hyper parameter. It will affect the total number of clusters. 
    reduce_dimension: str
        Dimensionality reduction method. Default: umap. 
        if &#34;&#34; is passed, no reduction methods are applied. In this case, data must be 2 dimention or x and y options must be specified.
    
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34; 
    
    
    original_index=df.index
    
    if len(category) !=0:
        if type(category)==str:
            category=[category]
        category_val=df[category].values
        
        df=df.drop(category, axis=1)
        X = df.values
        assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        X = df.values
        assert X.dtype==float, &#34;data must contain only float values.&#34;
    
    if ztranform:
        X=zscore(X, axis=0)
    if pcacomponent==None:
            
        if 20&lt;X.shape[1]:
            pcacomponent=20
        elif 10&lt;X.shape[1]:
            pcacomponent=10
        else:
            pcacomponent=2
    pca=PCA(n_components=pcacomponent, random_state=1)
    xpca=pca.fit_transform(X)
    
    if reduce_dimension==&#34;umap&#34;:
        import umap
        u=umap.UMAP(random_state=42, min_dist=min_dist,n_neighbors=n_neighbors)
        X=u.fit_transform(xpca)
    
    if n_clusters==&#34;auto&#34; and method==&#34;kmeans&#34;:
        Sum_of_squared_distances = []
        K = list(range(*testrange))
        for k in K:
            km = KMeans(n_clusters=k,n_init=10)
            km = km.fit(X)
            Sum_of_squared_distances.append(km.inertia_)
        normy=np.array(Sum_of_squared_distances)/np.amax(Sum_of_squared_distances)
        normy=1-normy
        normx=np.linspace(0,1, len(K))
        perp=_calc_curveture(normx, normy)
        # perp=[]
        # for i, (nx, ny) in enumerate(zip(normx, normy)):
        #     if i==0:
        #         perp.append(0)
        #         continue
        #     r=(nx**2+ny**2)**0.5
        #     sina=ny/r
        #     cosa=nx/r
        #     sinamb=sina*np.cos(np.pi*0.25)-cosa*np.sin(np.pi*0.25)
        #     perp.append(r*sinamb)
        # perp=np.array(perp)
        srtindex=np.argsort(perp)[::-1]
        plt.subplots()
        plt.plot(K, Sum_of_squared_distances, &#39;-&#39;, label=&#39;Sum of squared distances&#39;)
        plt.plot(K, perp*np.amax(Sum_of_squared_distances), label=&#34;curveture&#34;)
        
        plt.plot([K[srtindex[0]],K[srtindex[0]]],[0,np.amax(Sum_of_squared_distances)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(K[srtindex[0]], np.amax(Sum_of_squared_distances)*0.95, &#34;N=&#34;+str(K[srtindex[0]]))
        plt.plot([K[srtindex[1]],K[srtindex[1]]],[0,np.amax(Sum_of_squared_distances)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(K[srtindex[1]], np.amax(Sum_of_squared_distances)*0.95, &#34;N=&#34;+str(K[srtindex[1]]))
        plt.xticks(K)
        plt.xlabel(&#39;K&#39;)
        plt.ylabel(&#39;Sum of squared distances&#39;)
        plt.title(&#39;Elbow method for optimal cluster number&#39;)    
        plt.legend()
        print(&#34;Top two optimal cluster No are: {}, {}&#34;.format(K[srtindex[0]],K[srtindex[1]]))
        n_clusters=[K[srtindex[0]],K[srtindex[1]]]
        
        _save(save)
    elif n_clusters==&#34;auto&#34; and method==&#34;hierarchical&#34;:
        import scipy.spatial.distance as ssd
        
        labels=df.index
        D=ssd.squareform(ssd.pdist(xpca))
        Y = sch.linkage(D, method=&#39;ward&#39;)
        Z = sch.dendrogram(Y,labels=labels,no_plot=True)
        
        K = list(range(*testrange))
        newK=[]
        scores=[]
        for k in K:
            t=_dendrogram_threshold(Z, k)
            Z2=sch.dendrogram(Y,
                                labels = labels,
                                color_threshold=t,no_plot=True) 
            clusters=_get_cluster_classes(Z2, label=&#39;ivl&#39;)
            _k=len(clusters)
            if not _k in newK:
                newK.append(_k)
                sample2cluster={}
                i=1
                for k, v in clusters.items():
                    for sample in v:
                        sample2cluster[sample]=&#34;C&#34;+str(i)
                    i+=1
                scores.append(silhouette_score(X, [sample2cluster[sample] for sample in labels], metric = &#39;euclidean&#39;)/_k)
        print(scores)
        scores=np.array(scores)
        srtindex=np.argsort(scores)[::-1]
        plt.subplots()
        plt.plot(newK, scores, &#39;-&#39;)
        plt.plot([newK[srtindex[0]],newK[srtindex[0]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[0]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[0]]))
        plt.plot([newK[srtindex[1]],newK[srtindex[1]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[1]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[1]]))
        plt.xticks(newK)
        plt.xlabel(&#39;K&#39;)
        plt.ylabel(&#39;Silhouette scores&#39;)
        plt.title(&#39;Optimal cluster number searches by silhouette method&#39;)    
        
        print(&#34;Top two optimal cluster No are: {}, {}&#34;.format(newK[srtindex[0]],newK[srtindex[1]]))
        n_clusters=[newK[srtindex[0]],newK[srtindex[1]]]
        
    elif n_clusters==&#34;auto&#34; and method==&#34;dbscan&#34;:
        # import scipy.spatial.distance as ssd
        # D=ssd.pdist(X)
        #
        from sklearn.neighbors import NearestNeighbors
        neigh = NearestNeighbors(n_neighbors=2)
        nbrs = neigh.fit(X)
        distances, indices = nbrs.kneighbors(X)
        distances = np.sort(distances[:,1], axis=0)
        #
        # plt.plot(distances)
        # plt.show()
        # sys.exit()
        print(np.amin(distances), np.amax(distances))
        K=np.linspace(np.amin(distances), np.amax(distances),20)
        newK=[]
        scores=[]
        _K=[]
        for k in K:
            db = DBSCAN(eps=k, min_samples=5, n_jobs=-1)
            dbX=db.fit(X)
            labels=np.unique(dbX.labels_[dbX.labels_&gt;=0])
            print(k,labels)
            if len(labels)&lt;2:
                continue
            _k=len(labels)
            if not _k in newK:
                newK.append(_k)
                _K.append(k)
                scores.append(silhouette_score(X[dbX.labels_&gt;=0], dbX.labels_[dbX.labels_&gt;=0], metric = &#39;euclidean&#39;)/_k)
        print(scores)
        scores=np.array(scores)
        
        _ksort=np.argsort(newK)
        _K=np.array(_K)[_ksort]
        newK=np.array(newK)[_ksort]
        scores=np.array(scores)[_ksort]
        srtindex=np.argsort(scores)[::-1]
        plt.subplots()
        plt.plot(newK, scores, &#39;-&#39;)
        plt.plot([newK[srtindex[0]],newK[srtindex[0]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[0]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[0]]))
        plt.plot([newK[srtindex[1]],newK[srtindex[1]]],[0,np.amax(scores)], &#34;--&#34;, color=&#34;r&#34;)
        plt.text(newK[srtindex[1]], np.amax(scores)*0.95, &#34;N=&#34;+str(newK[srtindex[1]]))
        plt.xticks(newK)
        plt.xlabel(&#39;eps&#39;)
        plt.ylabel(&#39;Silhouette scores&#39;)
        plt.title(&#39;Optimal cluster number searches by silhouette method&#39;)    
        
        print(&#34;Top two optimal cluster No are: {}, {}&#34;.format(newK[srtindex[0]],newK[srtindex[1]]))
        eps=[_K[srtindex[0]],_K[srtindex[1]]]
        
    else:
        n_clusters=[n_clusters]
    if method==&#34;kmeans&#34;:
        dfnews=[]
        if reduce_dimension==&#34;umap&#34;:
            x=&#34;UMAP1&#34;
            y=&#34;UMAP2&#34;
        for nc in n_clusters:
            kmean = KMeans(n_clusters=nc, random_state=0,n_init=10)
            kmX=kmean.fit(X)
            labels=np.unique(kmX.labels_)
            
            dfnew=pd.DataFrame(data = np.array([X[:,0],X[:,1]]).T, columns = [x, y], index=original_index)
            dfnew[&#34;kmeans&#34;]=kmX.labels_
            dfnews.append(dfnew)
        hue=&#34;kmeans&#34;
        
    elif method==&#34;hierarchical&#34;:
        import scipy.spatial.distance as ssd
        labels=df.index
        D=ssd.squareform(ssd.pdist(xpca))
        Y = sch.linkage(D, method=&#39;ward&#39;)
        Z = sch.dendrogram(Y,labels=labels,no_plot=True)
        if reduce_dimension==&#34;umap&#34;:
            x=&#34;UMAP1&#34;
            y=&#34;UMAP2&#34;
        dfnews=[]
        for nc in n_clusters:
            t=_dendrogram_threshold(Z, nc)
            Z2=sch.dendrogram(Y,
                                labels = labels,
                                color_threshold=t,no_plot=True) 
            clusters=_get_cluster_classes(Z2, label=&#39;ivl&#39;)
            sample2cluster={}
            i=1
            for k, v in clusters.items():
                for sample in v:
                    sample2cluster[sample]=&#34;C&#34;+str(i)
                i+=1
                
            dfnew=pd.DataFrame(data = np.array([X[:,0],X[:,1]]).T, columns = [x, y], index=original_index)
            dfnew[&#34;hierarchical&#34;]=[sample2cluster[sample] for sample in labels]       
            dfnews.append(dfnew)
        hue=&#34;hierarchical&#34;
    elif method==&#34;dbscan&#34;:
        dfnews=[]
        if reduce_dimension==&#34;umap&#34;:
            x=&#34;UMAP1&#34;
            y=&#34;UMAP2&#34;
        if type(eps)==float:
            eps=[eps]
        n_clusters=[]
        for e in eps:
            db = DBSCAN(eps=e, min_samples=5, n_jobs=-1)
            dbX=db.fit(X)
            labels=np.unique(dbX.labels_)
            
            dfnew=pd.DataFrame(data = np.array([X[:,0],X[:,1]]).T, columns = [x, y], index=original_index)
            dfnew[&#34;dbscan&#34;]=dbX.labels_
            dfnews.append(dfnew)
            tmp=0
            for c in set(dbX.labels_):
                if c &gt;=0:
                    tmp+=1
            n_clusters.append(str(tmp)+&#34;, eps=&#34;+str(np.round(e,2)))
            
            
        hue=&#34;dbscan&#34;
    _dfnews={}
    for dfnew, K in zip(dfnews, n_clusters): 
        if len(category)==0:
            axnum=1
            fig, ax=plt.subplots(ncols=1, figsize=[4,4])
            ax=[ax]
        else:
            fig, ax=plt.subplots(ncols=1+len(category), figsize=[4+4*len(category),4])
        sns.scatterplot(data=dfnew,x=x,y=y,hue=hue, ax=ax[0], palette=palette[0],**kwargs)
        ax[0].set_title(&#34;Cluster number=&#34;+str(K))
        if len(category)!=0:
            for i, cat in enumerate(category):
                dfnew[cat]=category_val[:,i]
                sns.scatterplot(data=dfnew,x=x,y=y,hue=cat, ax=ax[i+1], palette=palette[1],**kwargs)
        _dfnews[K]=dfnew 
    return {&#34;data&#34;: _dfnews, &#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.complex_clustermap"><code class="name flex">
<span>def <span class="ident">complex_clustermap</span></span>(<span>df: pandas.core.frame.DataFrame, heatmap_col: list, dfcol: Optional[pandas.core.frame.DataFrame] = None, row_colors: list = [], col_colors: list = [], row_plot: list = [], col_plot: list = [], row_scatter: list = [], col_scatter: list = [], row_bar: list = [], col_bar: list = [], approx_clusternum: int = 10, approx_clusternum_col: int = 3, color_var: int = 0, merginalsum: bool = False, show: bool = False, method: str = 'ward', return_col_cluster: bool = True, ztranform=True, xticklabels=True, yticklabels=False, show_plot_labels=False, figsize=[], save: str = '', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a clustered heatmap with merginal plots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>row_colormap</code></strong> :&ensp;<code>dict</code></dt>
<dd>the column name of a category that is going to be placed in the row of the dotplot</dd>
<dt><strong><code>col_colormap</code></strong> :&ensp;<code>dict</code></dt>
<dd>the column name of a category that is going to be placed in the column of the dotplot</dd>
<dt><strong><code>row_plot</code></strong> :&ensp;<code>dict</code></dt>
<dd>The column name for the values represented as dot colors.</dd>
<dt><strong><code>col_plot</code></strong> :&ensp;<code>dict</code></dt>
<dd>The column name for the values represented as dot sizes.</dd>
<dt><strong><code>row_color_legend</code></strong> :&ensp;<code>dict</code></dt>
<dd>The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.</dd>
<dt><strong><code>col_color_legend</code></strong> :&ensp;<code>dict</code></dt>
<dd>The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.</dd>
<dt><strong><code>approx_clusternum</code></strong> :&ensp;<code>int</code></dt>
<dd>The approximate number of row clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won't change.</dd>
<dt><strong><code>approx_clusternum_col</code></strong> :&ensp;<code>int</code></dt>
<dd>The approximate number of column clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won't change.</dd>
<dt><strong><code>color_var</code></strong> :&ensp;<code>int</code></dt>
<dd>The title for color values. If not set, "color_val" will be used.</dd>
<dt><strong><code>merginalsum</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to draw bar plots for merginal distribution.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>string</code></dt>
<dd>Method for hierarchical clustering.</dd>
<dt><strong><code>return_col_cluster</code></strong> :&ensp;<code>string</code></dt>
<dd>The title for color values. If not set, "color_val" will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>dict: {"row_clusters":pd.DataFrame,"col_clusters":pd.DataFrame, "grid":g}
</code></pre>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complex_clustermap(df: pd.DataFrame,
                       heatmap_col: list,
                       dfcol: Optional[pd.DataFrame]=None, 
                       
                       row_colors: list=[],
                       col_colors: list=[],
                       row_plot: list=[],
                       col_plot: list=[],
                       row_scatter: list=[],
                       col_scatter: list=[],
                       row_bar: list=[],
                       col_bar: list=[],
                       
                       approx_clusternum: int=10,
                       approx_clusternum_col: int=3,
                       color_var: int=0,
                       merginalsum: bool=False,
                       show: bool=False,
                       method: str=&#34;ward&#34;,
                       return_col_cluster: bool=True,
                       ztranform=True,
                       xticklabels=True, 
                       yticklabels=False,
                       show_plot_labels=False,figsize=[],save: str=&#34;&#34;,
                       **kwargs):
    &#34;&#34;&#34;
    Drawing a clustered heatmap with merginal plots.
    
    Parameters
    ----------
    df : pandas DataFrame
    row_colormap: dict
        the column name of a category that is going to be placed in the row of the dotplot
    col_colormap: dict
        the column name of a category that is going to be placed in the column of the dotplot
    row_plot : dict
        The column name for the values represented as dot colors.
    col_plot : dict
        The column name for the values represented as dot sizes. 
    row_color_legend: dict
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    col_color_legend: dict
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    
    approx_clusternum : int
        The approximate number of row clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.    
    approx_clusternum_col : int
        The approximate number of column clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.
    
    color_var : int
        The title for color values. If not set, &#34;color_val&#34; will be used.
    merginalsum : bool
        Whether or not to draw bar plots for merginal distribution.
    show : bool
        Whether or not to show the figure.
    method : string
        Method for hierarchical clustering.
    return_col_cluster : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    Returns
    -------
        dict: {&#34;row_clusters&#34;:pd.DataFrame,&#34;col_clusters&#34;:pd.DataFrame, &#34;grid&#34;:g}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;#print(kwargs)
    rnum, cnum=df.shape
    cnum=len(heatmap_col)
    if len(figsize)==0:
        xsize=np.amin([2*cnum, 20])
        figsize=[xsize,10]
    scatterpointsize=5
    sns.set(font_scale=1)
    if ztranform:
        df[heatmap_col]=df[heatmap_col].apply(zscore)
    
    if len(col_plot)!=0 or len(col_scatter)!=0 or len(col_bar)!=0:
        if dfcol==None:
            raise Exception(&#34;if you want to plot along the x axis, you need provide dfcol option containing values to plot.&#34;)
    
    totalrowplot=0
    if merginalsum==True:
        totalrowplot+=1
    totalrowplot+=len(row_plot)
    totalrowplot+=len(row_colors)
    totalrowplot+=len(row_scatter)
    totalrowplot+=len(row_bar)
    totalcolplot=0
    if merginalsum==True:
        totalcolplot+=1
    totalcolplot+=len(col_plot) 
    totalcolplot+=len(col_colors)
    totalcolplot+=len(col_scatter)
    totalcolplot+=len(col_bar)
    _row_color_legend={}
    _col_color_legend={}
    colormap_index=0
    if totalrowplot + totalcolplot &gt;0:
        rowplotcount=0
        colplotcount=0
        _row_colors=[]
        _row_colors_title=[]
        _col_colors=[]
        _col_colors_title=[]
        
        if merginalsum:
            _row_colors.append(np.ones([rnum, 4]))
            _row_colors_title.append(&#34;Sum&#34;)
            _col_colors.append(np.ones([cnum, 4]))
            _col_colors_title.append(&#34;Sum&#34;)
        #print(np.shape(_col_colors))
        if len(row_colors)&gt;0:
            for k in row_colors:
                
                u=np.unique(df[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _row_color_legend[k]=lut
                colormap_index+=1
                _row_colors.append([lut[cat] for cat in df[k]])
                _row_colors_title.append(k)
                
        if len(col_colors)&gt;0:
            for k in col_colors:
                u=np.unique(dfcol[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _col_color_legend[k]=lut
                colormap_index+=1
                _col_colors.append([lut[cat] for cat in dfcol[k]])
                _col_colors_title.append(k)
        
        if len(row_plot)&gt;0:
            for k in row_plot:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_plot)&gt;0:
            for k in col_plot:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k)        
        
        if len(row_scatter)&gt;0:
            for k in row_scatter:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_scatter)&gt;0:
            for k in col_scatter:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(row_bar)&gt;0:
            for k in row_bar:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_bar)&gt;0:
            for k in col_bar:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(_row_colors) &gt;0 and len(_col_colors) &gt;0:
            #print(np.shape(_col_colors))
            g=sns.clustermap(df[heatmap_col],col_colors=_col_colors, 
                             row_colors=_row_colors,
                             method=method,xticklabels=xticklabels, yticklabels=yticklabels,
                             figsize=figsize,dendrogram_ratio=0.1,
                             **kwargs)
            g.ax_col_colors.invert_yaxis()
            g.ax_row_colors.invert_xaxis()
        elif len(_col_colors) &gt;0:
           
            g=sns.clustermap(df[heatmap_col],
                             col_colors=_col_colors,
                             method=method,
                             xticklabels=xticklabels, 
                             yticklabels=yticklabels,
                             dendrogram_ratio=0.1,
                             figsize=figsize,**kwargs)
            g.ax_col_colors.invert_yaxis()
        elif len(_row_colors) &gt;0:
            g=sns.clustermap(df[heatmap_col],row_colors=_row_colors,method=method,xticklabels=xticklabels, yticklabels=yticklabels,dendrogram_ratio=0.1,figsize=figsize,**kwargs)
            g.ax_row_colors.invert_xaxis()
        
        rowplotcount=0
        colplotcount=0
        tickpos=0.9
        row_labels=[]
        col_labels=[]
        row_ticks=[]
        col_ticks=[]
        if merginalsum:
            mat=df[heatmap_col].to_numpy()
            r=np.sum(mat, axis=1)
            row_labels.append(0)
            row_labels.append(np.amax(r))
            row_ticks.append(rowplotcount)
            row_ticks.append(rowplotcount+tickpos)
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            if row_cluster==True:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r[leaves_list(g.dendrogram_row.linkage)]/np.amax(r),height=1)
                
            else:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r/np.amax(r),height=1)
            #g.ax_row_colors.set_xticks([0,1],labels=[0,np.amax(r)])
            c=np.sum(mat, axis=0)
            #print(mat, c)
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            if col_cluster==True:
            
            #print(leaves_list(g.dendrogram_col.linkage))
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c[leaves_list(g.dendrogram_col.linkage)]/np.amax(c),width=1)
            else:
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c/np.amax(c),width=1)
            #g.ax_col_colors.set_yticks([0,1],labels=[0,np.amax(c)])
            col_labels.append(0)
            col_labels.append(np.amax(c))
            col_ticks.append(colplotcount)
            col_ticks.append(colplotcount+tickpos)
            rowplotcount=1
            colplotcount=1
        rowplotcount+=len(row_colors)
        colplotcount+=len(col_colors)
        if len(row_plot)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_plot):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)

                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
                else:
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
            
                rowplotcount+=1
                
        if len(col_plot)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_plot):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount)
                else:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r+colplotcount)
                
                colplotcount+=1
        if len(row_scatter)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_scatter):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
                else:
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
            
                rowplotcount+=1
        if len(col_scatter)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_scatter):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount,s=scatterpointsize)
                else:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r+colplotcount,s=scatterpointsize)
                
                colplotcount+=1
        
        if len(row_bar)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_bar):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                    
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    g.ax_row_colors.barh(y=np.arange(r.shape[0])+0.5, width=r[leaves_list(g.dendrogram_row.linkage)],left=[rowplotcount]*r.shape[0])
                else:
                    g.ax_row_colors.barh(r, np.arange(r.shape[0])+0.5,left=[rowplotcount]*r.shape[0])
            
                rowplotcount+=1
        if len(col_bar)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_bar):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)

                if col_cluster==True:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]/(np.amax(r)*1.1)+colplotcount)
                else:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r/(np.amax(r)*1.1)+colplotcount)
                
                colplotcount+=1
        if g.ax_row_colors!=None:
            
            g.ax_row_colors.set_xticks(np.arange(len(_row_colors_title))+0.5)
            g.ax_row_colors.set_xticklabels(_row_colors_title, rotation=90)
        if g.ax_col_colors!=None:
            colax_otherside = g.ax_col_colors.twinx()
            colax_otherside.set_yticks(0.5*(np.arange(len(_col_colors_title))+0.5),labels=_col_colors_title)
            colax_otherside.grid(False)
        if g.ax_col_dendrogram!=None:
            col = g.ax_col_dendrogram.get_position()
            g.ax_col_dendrogram.set_position([col.x0, col.y0, col.width*0.5, col.height*0.5])
        
        if show_plot_labels==True:
            
            rowax_otherside = g.ax_row_colors.twiny()
            rowax_otherside.invert_xaxis()
            rowax_otherside.grid(False)
            rowax_otherside.set_xticks(row_ticks, labels=np.round(row_labels,2), rotation=90, fontsize=8)
            col_ticks=np.array(col_ticks)
            g.ax_col_colors.set_yticks(col_ticks, labels=np.round(col_labels,2), fontsize=8)
        
        legend_num=0
        for title, colorlut in _row_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))
            #g.add_legend(legend_data=legendhandles,title=&#34;Aroma&#34;,label_order=[&#34;W&#34;,&#34;F&#34;,&#34;Y&#34;])
            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        for title, colorlut in _col_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))
            #g.add_legend(legend_data=legendhandles,title=&#34;Aroma&#34;,label_order=[&#34;W&#34;,&#34;F&#34;,&#34;Y&#34;])
            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        
    else:
        g=sns.clustermap(df,method=method,**kwargs)
    if color_var&gt;0:
        cmap = cm.nipy_spectral(np.linspace(0, 1, color_var))
    else:
        cmap = cm.nipy_spectral(np.linspace(0, 1, approx_clusternum+5))
    hierarchy.set_link_color_palette([mpl.colors.rgb2hex(rgb[:3]) for rgb in cmap])
    
    &#34;&#34;&#34;coloring the row dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    if g.dendrogram_row != None:
        t=_dendrogram_threshold(g.dendrogram_row.dendrogram,approx_clusternum)
        # lbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,:2]
        # rbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,2:]
        # thre=np.linspace(0, np.amax(g.dendrogram_row.dendrogram[&#34;dcoord&#34;]), 100)[::-1]
        # for t in thre:
        #     #print(np.sum(lbranches[:,1]&gt;t),np.sum(rbranches[:,0]&gt;t),np.sum(lbranches[:,0]&gt;t),np.sum(rbranches[:,1]&gt;t))
        #     crossbranches=np.sum(lbranches[:,1]&gt;t)+np.sum(rbranches[:,0]&gt;t)-np.sum(lbranches[:,0]&gt;t)-np.sum(rbranches[:,1]&gt;t)
        #     #print(crossbranches)
        #
        #     if crossbranches&gt;approx_clusternum:
        #         break
        
        den=hierarchy.dendrogram(g.dendrogram_row.linkage,
                                                 labels = g.data.index,
                                                 color_threshold=t,ax=g.ax_row_dendrogram,
                            orientation=&#34;left&#34;)  
        g.ax_row_dendrogram.invert_yaxis()
        clusters = _get_cluster_classes(den)
        cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        keys=list(clusters.keys())
        ckeys={}
        i=1
        for k in keys:
            if k==&#34;C0&#34;:
                ckeys[k]=&#34;C0&#34;
            else:
                ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in clusters.items():
            _c=ckeys[c]
            for _v in v:
                cdata[&#34;Cluster&#34;].append(_c)
                cdata[&#34;Index&#34;].append(_v)
                cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
        &#34;&#34;&#34;Setting the row dendrogram ends here&#34;&#34;&#34;
    
    
    &#34;&#34;&#34;coloring the col dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    if g.dendrogram_col != None:
        t=_dendrogram_threshold(g.dendrogram_col.dendrogram,approx_clusternum_col)
        den=hierarchy.dendrogram(g.dendrogram_col.linkage,
                                                 labels = g.data.columns,
                                                 color_threshold=t,ax=g.ax_col_dendrogram,
                            orientation=&#34;top&#34;)  
        #g.ax_col_dendrogram.invert_yaxis()
        col_clusters = _get_cluster_classes(den)
        col_cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        col_keys=list(col_clusters.keys())
        col_ckeys={}
        i=1
        for k in col_keys:
            if k==&#34;C0&#34;:
                col_ckeys[k]=&#34;C0&#34;
            else:
                col_ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in col_clusters.items():
            _c=col_ckeys[c]
            for _v in v:
                col_cdata[&#34;Cluster&#34;].append(_c)
                col_cdata[&#34;Index&#34;].append(_v)
                col_cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
    &#34;&#34;&#34;Setting the col dendrogram ends here&#34;&#34;&#34;
    
    plt.setp(g.ax_heatmap.xaxis.get_majorticklabels(), rotation=90)
    plt.subplots_adjust(bottom=0.165, right=0.75)
    if save!=&#34;&#34;:
        if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
            plt.savefig(save)
        else:
            plt.savefig(save+&#34;_complexheatmap.pdf&#34;)
    if show:
        plt.show()
    if return_col_cluster==True:
        return {&#34;data&#34;:g.data2d,&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:pd.DataFrame(col_cdata), &#34;grid&#34;:g}
    else:
        return {&#34;data&#34;:g.data2d,&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:None, &#34;grid&#34;:g}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.correlation"><code class="name flex">
<span>def <span class="ident">correlation</span></span>(<span>df: pandas.core.frame.DataFrame, category: Union[str, list] = [], method='pearson', palette: str = 'coolwarm', figsize=[6, 6], show_val=False, clustermap_param: dict = {}, ztransform: bool = True, xticklabels=False, yticklabels=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a heatmap with correlations or distances between observations </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code> or <code>list</code>, optional</dt>
<dd>the names of categorical values to display as color labels</dd>
<dt><strong><code>mthod</code></strong> :&ensp;<code>str</code></dt>
<dd>method for correlation/distance calculation. Defalt: "pearson"</dd>
<dt><strong><code>palette</code></strong> :&ensp;<code>str</code></dt>
<dd>A colormap name</dd>
<dt><strong><code>show_val</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheter to exhibit the values of fractions/counts/percentages.</dd>
<dt><strong><code>clustermap_param</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>List[int]</code>, optional</dt>
<dd>The figure size, e.g., [4, 6].</dd>
<dt><strong><code>ztransform</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to transform values to z-score</dd>
<dt><strong><code>xticklabels</code></strong>, <strong><code>yticklabels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the label names in the heatmap</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correlation(df: pd.DataFrame, 
                category: Union[str, list]=[],
                method=&#34;pearson&#34;,
                palette: str=&#34;coolwarm&#34;,
                figsize=[6,6],
                show_val=False,
                clustermap_param:dict={},
                ztransform: bool=True,
                xticklabels =False,
                yticklabels=False):
    &#34;&#34;&#34;
    Drawing a heatmap with correlations or distances between observations 
    
    Parameters
    ----------
    df : pandas DataFrame
        
    category: str or list, optional
        the names of categorical values to display as color labels
    mthod: str
        method for correlation/distance calculation. Defalt: &#34;pearson&#34;
        
    palette : str
        A colormap name
    show_val: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    clustermap_param : dict, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
    ztransform : bool, optional
        Whether to transform values to z-score
    xticklabels, yticklabels : bool
        Whether to show the label names in the heatmap
    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    original_index=df.index
    
    if len(category) !=0:

        if type(category)==str:
            category=[category]
        #df=df.drop(category, axis=1)
        valnames=list(set(df.columns) -set(category)) 
        X = df[valnames].values
        assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        X = df.values
        assert X.dtype==float, &#34;data must contain only float values.&#34;
    if ztransform==True:
        X=zscore(X, axis=0)
    if method==&#34;pearson&#34;:
        dmat=Parallel(n_jobs=-1)(delayed(_calc_pearson)(ind, X) for ind in list(it.combinations(range(X.shape[0]), 2)))
        dmat=np.array(dmat)
        dmat=squareform(dmat)
        print(dmat)
        dmat+=np.identity(dmat.shape[0])
    else:
        dmat=squareform(pdist(X, method))
    if method==&#34;pearson&#34;:
            title=&#34;Pearson correlation&#34;
    else:
        title=method+&#34; distance&#34;    
        
        
    if len(category) &gt;0:
        dfm=pd.DataFrame(data=dmat)
        colnames=dfm.columns
        for cat in category:
            dfm[cat]=df[cat].values
        res=complex_clustermap(dfm,
                               heatmap_col=colnames, 
                               row_colors=category,
                               ztranform=False,
                               xticklabels=xticklabels,
                               yticklabels=yticklabels,
                               figsize=figsize,
                               cbar_kws={&#34;label&#34;:title}, )
        return res
    else:
        
        g=sns.clustermap(data=dmat,xticklabels=xticklabels,yticklabels=yticklabels,
                   method=&#34;ward&#34;, cmap=palette,
                   col_cluster=True,
                   row_cluster=True,
                   figsize=figsize,
                   rasterized=True,
                    #cbar_kws={&#34;label&#34;:&#34;Pearson correlation&#34;}, 
                   annot=show_val,
                   **clustermap_param)
        
        g.cax.set_ylabel(title, rotation=-90,va=&#34;bottom&#34;)
        plt.setp(g.ax_heatmap.get_yticklabels(), rotation=0)  # For y axis
        plt.setp(g.ax_heatmap.get_xticklabels(), rotation=90) # For x axis
        return {&#34;grid&#34;:g}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.decomplot"><code class="name flex">
<span>def <span class="ident">decomplot</span></span>(<span>df, category: str = '', method: str = 'pca', component: int = 3, arrow_color: str = 'yellow', arrow_text_color: str = 'black', show: bool = False, explained_variance: bool = True, arrow_num: int = 3, figsize=[], regularization: bool = True, pcapram={'random_state': 0}, nmfparam={'random_state': 0}, save: str = '', saveparam: dict = {})</span>
</code></dt>
<dd>
<div class="desc"><p>Decomposing data and drawing a scatter plot and some plots for explained variables. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>the column name of a known sample category (if exists).</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Method name for decomposition. Available methods: ["pca", "nmf"]</dd>
<dt><strong><code>component</code></strong> :&ensp;<code>int</code></dt>
<dd>The component number</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>dict {"data": dfpc_list,"pca": pca, "axes":axes, "axes_explained":ax2} for pca method
or {"data": dfpc_list, "W":W, "H":H,"axes":axes,"axes_explained":axes2} for nmf method
</code></pre>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decomplot(df,category: str=&#34;&#34;, 
              method: str=&#34;pca&#34;, 
              component: int=3,
              arrow_color: str=&#34;yellow&#34;,
              arrow_text_color: str=&#34;black&#34;,
              show: bool=False, 
              explained_variance: bool=True,
              arrow_num: int=3,
              figsize=[],
              regularization: bool=True,
              pcapram={&#34;random_state&#34;:0},
              nmfparam={&#34;random_state&#34;:0},
              save: str=&#34;&#34;,
              saveparam: dict={}) :
    
    &#34;&#34;&#34;
    Decomposing data and drawing a scatter plot and some plots for explained variables. 
    
    Parameters
    ----------
    df : pandas DataFrame
    category: str
        the column name of a known sample category (if exists). 
    method: str
        Method name for decomposition. Available methods: [&#34;pca&#34;, &#34;nmf&#34;]
    component: int
        The component number
    
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
        dict {&#34;data&#34;: dfpc_list,&#34;pca&#34;: pca, &#34;axes&#34;:axes, &#34;axes_explained&#34;:ax2} for pca method
        or {&#34;data&#34;: dfpc_list, &#34;W&#34;:W, &#34;H&#34;:H,&#34;axes&#34;:axes,&#34;axes_explained&#34;:axes2} for nmf method
            
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;    
    if category !=&#34;&#34;:
        category_val=df[category].values
        df=df.drop([category], axis=1)
        x = df.values
        assert x.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        x = df.values
        assert x.dtype==float, &#34;data must contain only float values.&#34;
    original_index=df.index
    features=df.columns
    dfpc_list=[]
    if method==&#34;pca&#34;:
        if regularization:
            x=zscore(x, axis=0)
        pca = PCA(n_components=component,**pcapram)
        pccomp = pca.fit_transform(x)
        
        comb=list(combinations(np.arange(component), 2))
        if len(comb)==1:
            fig, axes=plt.subplots()
            axes=[axes]
        else:
            nrows=len(comb)//2+int(len(comb)%2!=0)
            if len(figsize)==0:
                figsize=[8,3*nrows]
            
            fig, axes=plt.subplots(ncols=2, nrows=nrows, figsize=figsize)
            plt.subplots_adjust(top=0.9,right=0.8)
            axes=axes.flatten()
        loadings = pca.components_.T * np.sqrt(pca.explained_variance_)
        combnum=0
        for (i, j), ax in zip(comb, axes):
            xlabel, ylabel=&#39;pc&#39;+str(i+1), &#39;pc&#39;+str(j+1)
            dfpc = pd.DataFrame(data = np.array([pccomp[:,i],pccomp[:,j]]).T, columns = [xlabel, ylabel],index=original_index)
            if category!=&#34;&#34;:
                dfpc[category]=category_val
                if combnum==1:
                    sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, hue=category, ax=ax)
                    ax.legend(bbox_to_anchor=(1.02, 1), loc=&#39;upper left&#39;, borderaxespad=0)
                else:
                    sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, hue=category, ax=ax,
                                    legend=False)
            else:
                sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, ax=ax)
            _loadings=np.array([loadings[:,i],loadings[:,j]]).T
            a=np.sum(_loadings**2, axis=1)
            srtindx=np.argsort(a)[::-1][:arrow_num]
            _loadings=_loadings[srtindx]
            _features=np.array(features)[srtindx]
            for k, feature in enumerate(_features):
                
                #ax.plot([0,_loadings[k, 0] ], [0,_loadings[k, 1] ],color=arrow_color)
                ax.arrow(0, 0, _loadings[k, 0],_loadings[k, 1],color=arrow_color,width=0.005,head_width=0.1)
                ax.text(_loadings[k, 0],_loadings[k, 1],feature,color=arrow_text_color)
    
            dfpc_list.append(dfpc)
            combnum+=1
        plt.tight_layout(pad=0.5)
        if save!=&#34;&#34;:
            if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                h, ext=os.path.splitext(save)
                plt.savefig(h[0]+&#34;_PCA&#34;+ext, **saveparam)
            else:
                plt.savefig(save+&#34;_PCA.pdf&#34;,**saveparam) 
        if explained_variance==True:
            fig, ax2=plt.subplots()
            exp_var_pca = pca.explained_variance_ratio_
            #
            # Cumulative sum of eigenvalues; This will be used to create step plot
            # for visualizing the variance explained by each principal component.
            #
            cum_sum_eigenvalues = np.cumsum(exp_var_pca)
            #
            # Create the visualization plot
            #
            xlabel=[&#34;pc&#34;+str(i+1) for i in range(0,len(exp_var_pca))]
            plt.bar(xlabel, exp_var_pca, alpha=0.5, align=&#39;center&#39;, label=&#39;Individual explained variance&#39;)
            plt.step(range(0,len(cum_sum_eigenvalues)), cum_sum_eigenvalues, where=&#39;mid&#39;,label=&#39;Cumulative explained variance&#39;)
            plt.ylabel(&#39;Explained variance ratio&#39;)
            plt.xlabel(&#39;Principal component index&#39;)
            if save!=&#34;&#34;:
                if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                    h, ext=os.path.splitext(save)
                    plt.savefig(h[0]+&#34;_ExplainedVar&#34;+ext, **saveparam)
                else:
                    plt.savefig(save+&#34;_ExplainedVar.pdf&#34;,**saveparam) 
        if show==True:
            plt.show()
        else:
            return {&#34;data&#34;: dfpc_list,&#34;pca&#34;: pca, &#34;axes&#34;:axes, &#34;axes_explained&#34;:ax2}
    elif method==&#34;nmf&#34;:
        nmf=NMF(n_components=component,**nmfparam)
        if regularization:
            x=x/np.sum(x,axis=0)[None,:]
        W = nmf.fit_transform(x)
        H = nmf.components_
        comb=list(combinations(np.arange(component), 2))
        if len(comb)==1:
            fig, axes=plt.subplots()
            axes=[axes]
        else:
            nrows=len(comb)//2+int(len(comb)%2!=0)
            if len(figsize)==0:
                figsize=[8,3*nrows]
            
            fig, axes=plt.subplots(ncols=2, nrows=nrows, figsize=figsize)
            plt.subplots_adjust(top=0.9,right=0.8)
            axes=axes.flatten()

        for (i, j), ax in zip(comb, axes):
            xlabel, ylabel=&#39;p&#39;+str(i+1), &#39;p&#39;+str(j+1)
            dfpc = pd.DataFrame(data = np.array([W[:,i],W[:,j]]).T, columns = [xlabel, ylabel],index=original_index)
            dfpc[category]=category_val
            sns.scatterplot(data=dfpc, x=xlabel, y=ylabel, hue=category, ax=ax)
            dfpc_list.append(dfpc)
        
        fig.tight_layout()
        if save!=&#34;&#34;:
            if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                h, ext=os.path.splitext(save)
                plt.savefig(h[0]+&#34;_NMF&#34;+ext, **saveparam)
            else:
                plt.savefig(save+&#34;_NMF.pdf&#34;,**saveparam) 
        if explained_variance==True:
            fig, axes2=plt.subplots(nrows=component, figsize=[5,5])
            axes2=axes2.flatten()
            for i, ax in enumerate(axes2):
                if i==0:
                    ax.set_title(&#34;Coefficients of matrix H&#34;)
                ax.bar(np.arange(len(features)),H[i])
                ax.set_ylabel(&#34;p&#34;+str(i+1))
                ax.set_xticks(np.arange(len(features)),labels=[])
            ax.set_xticks(np.arange(len(features)),labels=features, rotation=90)
            fig.tight_layout()
            
            # dfw={&#34;index&#34;:[],&#34;p&#34;:[],&#34;val&#34;:[]}
            # ps=[&#34;p&#34;+str(i+1) for i in range(component)]
            # originalindex=df.index
            # for i in range(W.shape[0]):
            #     for j in range(W.shape[1]):
            #         dfw[&#34;index&#34;].append(originalindex[i])
            #         dfw[&#34;p&#34;].append(ps[j])
            #         dfw[&#34;val&#34;].append(W[i,j])
            # dfw=pd.DataFrame(data=dfw)
            #
            # dfh={&#34;feature&#34;:[],&#34;p&#34;:[],&#34;val&#34;:[]}
            # for i in range(H.shape[0]):
            #     for j in range(H.shape[1]):
            #         dfh[&#34;p&#34;].append(ps[i])
            #         dfh[&#34;feature&#34;].append(features[j])
            #
            #         dfh[&#34;val&#34;].append(H[i,j])
            # dfw=pd.DataFrame(data=dfw)
            # dfh=pd.DataFrame(data=dfh)
            # #dotplot(dfw,row=&#34;index&#34;,col=&#34;p&#34;,size_val=&#34;val&#34;)
            # dotplot(dfh,row=&#34;p&#34;,col=&#34;feature&#34;,size_val=&#34;val&#34;,)
            
            if save!=&#34;&#34;:
                if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
                    h, ext=os.path.splitext(save)
                    plt.savefig(h[0]+&#34;_Coefficients&#34;+ext, **saveparam)
                else:
                    plt.savefig(save+&#34;_Coefficients.pdf&#34;,**saveparam)    
                
            if show==True:
                plt.show()
            return {&#34;data&#34;: dfpc_list, &#34;W&#34;:W, &#34;H&#34;:H,&#34;axes&#34;:axes,&#34;axes_explained&#34;:axes2}
    elif method==&#34;lda&#34;:
        lda=LatentDirichletAllocation(n_components=component, random_state=0)
        if regularization:
            x=x/np.sum(x,axis=0)[None,:]
        
    else:
        raise Exception(&#39;{} is not in options. Available options are: pca, nmf&#39;.format(method))</code></pre>
</details>
</dd>
<dt id="omniplot.plot.dotplot"><code class="name flex">
<span>def <span class="ident">dotplot</span></span>(<span>df: pandas.core.frame.DataFrame, row: str = '', col: str = '', dfc=Empty DataFrame
Columns: []
Index: [], scaling: float = 10, color_val: str = '', size_val: str = '', highlight: str = '', color_title: str = '', size_title: str = '', figsize: list = [], save: str = '', threshold: float = 1.3010299956639813, row_clustering: bool = True, xtickrotation: float = 90, column_order: list = [], colorpalette='coolwarm', show: bool = False) ‑> Dict[str, matplotlib.axes._axes.Axes]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a dotplot that can represent two different variables as dot sizes and colors on a regular grid.
This function is assumed to plot GO enrichment analysis with multiple gene sets.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>dataframe containing two categories and corresponding values (such as p values and odds ratio).
e.g.:
Cluster
Condensate
pval
odds
FDR
54
C1
Cajal body -0.000000
0.000000 -0.000000
55
C1
<em>DNA repair focus -0.000000
0.000000 -0.000000
56
C1
</em>DNA replication condensate -0.000000
0.000000 -0.000000
57
C1
P-body -0.000000
0.000000 -0.000000
58
C1
PML body -0.000000
0.000000 -0.000000</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>string</code></dt>
<dd>the column name of a category that is going to be placed in the row of the dotplot</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>string</code></dt>
<dd>the column name of a category that is going to be placed in the column of the dotplot</dd>
<dt><strong><code>color_val</code></strong> :&ensp;<code>string</code></dt>
<dd>The column name for the values represented as dot colors.</dd>
<dt><strong><code>size_val</code></strong> :&ensp;<code>string</code></dt>
<dd>The column name for the values represented as dot sizes.</dd>
<dt><strong><code>scaling</code></strong> :&ensp;<code>float</code></dt>
<dd>The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.</dd>
<dt><strong><code>highlight</code></strong> :&ensp;<code>string</code></dt>
<dd>A dictionary to set color labels to leaves. The key is the name of the color label.
The value is the list of RGB color codes, each corresponds to the color of a leaf.
e.g., {"color1":[[1,0,0,1], ....]}</dd>
<dt><strong><code>size_title</code></strong> :&ensp;<code>string</code></dt>
<dd>The title for size values. If not set, "size_val" will be used.</dd>
<dt><strong><code>color_title</code></strong> :&ensp;<code>string</code></dt>
<dd>The title for color values. If not set, "color_val" will be used.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>axes</code></strong> :&ensp;<code>dict {"axes1":ax1,"axes2":ax2,"axes3":ax3}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dotplot(df: pd.DataFrame,
            row: str=&#34;&#34;,
            col: str=&#34;&#34;,
            dfc=pd.DataFrame(),
            scaling: float=10,
            color_val: str=&#34;&#34;,
            size_val: str=&#34;&#34;,
            highlight: str=&#34;&#34;,
            color_title: str=&#34;&#34;,
            size_title: str=&#34;&#34;,
            figsize: list=[],
            save: str=&#34;&#34;,
            threshold: float=-np.log10(0.05),
            row_clustering: bool=True,
            xtickrotation: float=90,
            column_order: list=[],
            colorpalette=&#34;coolwarm&#34;,
            show: bool=False,
            ) -&gt; Dict[str, plt.Axes]:
    &#34;&#34;&#34;
    Drawing a dotplot that can represent two different variables as dot sizes and colors on a regular grid.
    This function is assumed to plot GO enrichment analysis with multiple gene sets.
    
    Parameters
    ----------
    df : pandas DataFrame
        dataframe containing two categories and corresponding values (such as p values and odds ratio).
        e.g.:
            Cluster                   Condensate      pval      odds       FDR
        54       C1                   Cajal body -0.000000  0.000000 -0.000000
        55       C1            *DNA repair focus -0.000000  0.000000 -0.000000
        56       C1  *DNA replication condensate -0.000000  0.000000 -0.000000
        57       C1                       P-body -0.000000  0.000000 -0.000000
        58       C1                     PML body -0.000000  0.000000 -0.000000
    row: string
        the column name of a category that is going to be placed in the row of the dotplot
    col: string
        the column name of a category that is going to be placed in the column of the dotplot
    color_val : string
        The column name for the values represented as dot colors.
    size_val : string
        The column name for the values represented as dot sizes. 
    scaling: float
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    highlight : string
        A dictionary to set color labels to leaves. The key is the name of the color label. 
        The value is the list of RGB color codes, each corresponds to the color of a leaf. 
        e.g., {&#34;color1&#34;:[[1,0,0,1], ....]}   
    size_title : string
        The title for size values. If not set, &#34;size_val&#34; will be used.
    
    color_title : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    show : bool
        Whether or not to show the figure.
    Returns
    -------
    axes: dict {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if size_val!=&#34;&#34;:
        _df=df.pivot_table(index=col,columns=row,values=size_val)
        if len(column_order)&gt;0:
            _df=_df.loc[column_order]
        else:
            _df=_df.sort_index(axis=0,key=natsort_keygen())
        _df=_df.fillna(0)
            
        if color_val!=&#34;&#34;:
            dfc=df.pivot_table(index=col,columns=row,values=color_val)
            if len(column_order)&gt;0:
                dfc=dfc.loc[column_order]
            else:
                dfc=dfc.sort_index(axis=0,key=natsort_keygen())
            dfc=dfc.fillna(0)
        if highlight !=&#34;&#34;:
            dfh=df.pivot_table(index=col,columns=row,values=highlight)
            if len(column_order)&gt;0:
                dfh=dfh.loc[column_order]
            else:
                dfh=dfh.sort_index(axis=0,key=natsort_keygen())
            dfh=dfh.fillna(0)
        
        if row_clustering==True:
            Y = fcl.linkage(_df.to_numpy().T, method=&#39;ward&#39;, metric=&#39;euclidean&#39;)
            Z1 = sch.dendrogram(Y,no_plot=True)
            idx1 = Z1[&#39;leaves&#39;]
            reorder=_df.columns[idx1]
            _df=_df[reorder]
            if color_val!=&#34;&#34;:
                dfc=dfc[reorder]
            if highlight !=&#34;&#34;:
                dfh=dfh[reorder]
        _x=_df.index
        _y=_df.columns
        mat=_df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    else:
        _x=df.index
        _y=df.columns
        mat=df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    #if minsize==0:
        #mat=mat+maxsize*0.01
    #minsize=np.amin(mat)
    
    maxsize=np.round(maxsize)
    middle0=np.round((minsize+maxsize)/3)
    middle1=np.round(2*(minsize+maxsize)/3)
    #plt.rcParams[&#34;figure.figsize&#34;] = [7.50, 3.50]
    #plt.rcParams[&#34;figure.autolayout&#34;] = True
    #x = np.arange(len(_x))
    #y = np.arange(len(_y))
    #X, Y = np.meshgrid(x, y)
    xy=[ [i,j] for i in range(len(_x)) for j in range(len(_y))]
    #num = 1000
    sizes = [mat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
    edge_colors=[]
    if highlight !=&#34;&#34;:
        hmat=dfh.to_numpy()
        hvals = [hmat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
       
        for s in hvals:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    else:
        for s in sizes:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    
    if len(dfc) !=0:
        viridis = cm.get_cmap(colorpalette, 12)
        cmat=dfc.to_numpy()
        cmat[cmat==np.inf]=0
        _cmat=cmat/np.amax(cmat)
        _colors = [viridis(_cmat[i,j]) for i in range(len(_x)) for j in range(len(_y))]
    else:
        _colors = [[0,1,0,1] for i in range(len(_x)) for j in range(len(_y))]
    #print(sizes)
    #xy = 10 * np.random.random((num, 2))
    #xy=XY
    #patches = [plt.Circle(center, size) for center, size in zip(xy, sizes)]
    
    #fig, ax = plt.subplots(ncols=2, gridspec_kw={&#39;width_ratios&#39;: [8, 2]})
    if len(figsize)==0:
        figsize=[mat.shape[0]*0.5+2,mat.shape[1]*0.5+1]
    
    fig = plt.figure(figsize=figsize)
    #fig.set_figheight(6)
    #fig.set_figwidth(6)
    
    ax1 = plt.subplot2grid(shape=(10, 6), loc=(0, 0), colspan=4, rowspan=10)
    ax2 = plt.subplot2grid(shape=(10, 6), loc=(1, 4), colspan=2, rowspan=4)
    ax3 = plt.subplot2grid(shape=(10, 6), loc=(6, 4), colspan=2, rowspan=1)
 
    collection = mc.CircleCollection(sizes,
                                     edgecolors=edge_colors, 
                                     offsets=xy, 
                                     transOffset=ax1.transData, 
                                     facecolors=_colors,
                                     linewidths=2)
    ax1.add_collection(collection)
    ax1.margins(0.1)
    ax1.set_xlim(-0.5,len(_x)-0.5)
    ax1.set_xticks(np.arange(len(_x)))
    ax1.set_xticklabels(_x,rotation=xtickrotation)
    ax1.set_yticks(np.arange(len(_y)))
    ax1.set_yticklabels(_y, rotation=0)
    if color_title==&#34;&#34;:
        color_title=color_val
    
    if len(dfc) !=0:
        norm = mpl.colors.Normalize(vmin=np.min(cmat), vmax=np.amax(cmat))
        
        cb1 = mpl.colorbar.ColorbarBase(ax3, cmap=viridis,
                                        norm=norm,
                                        orientation=&#39;horizontal&#39;)
        cb1.set_label(color_title)
    #ax[1]=fig.add_axes([1,0.3,0.1,1])
    
    lxy=[[0.5, i*0.5] for i in range(3)]
    collection2 = mc.CircleCollection([middle0*scaling,middle1*scaling, maxsize*scaling], 
                                      offsets=lxy, 
                                      transOffset=ax2.transData, 
                                      facecolors=&#39;lightgray&#39;,
                                      edgecolors=&#34;gray&#34;)
    ax2.add_collection(collection2)
    ax2.axis(&#39;off&#39;)
    ax2.margins(0.3)
    for text, (x, y) in zip([middle0,middle1, maxsize], lxy):
        ax2.text(x+0.01, y,str(text), ha=&#34;left&#34;,va=&#34;center&#34;,color=&#34;black&#34; )
    if size_title==&#34;&#34;:
        size_title=size_val
    ax2.text(0.5,-0.5, size_title,va=&#34;center&#34;,ha=&#34;center&#34;)
    #ax[1].set_yticks(np.arange(3))
    #ax[1].set_yticklabels([minsize,middle, maxsize], rotation=0)
    #plt.tight_layout()
    plt.subplots_adjust(left=0.3,bottom=0.2)
    #plt.tight_layout()
    _save(save, &#34;dotplot&#34;)
    if show==True:
        plt.show()
    return {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.manifoldplot"><code class="name flex">
<span>def <span class="ident">manifoldplot</span></span>(<span>df, category='', method='tsne', n_components=2, n_neighbors=4, show=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reducing the dimensionality of data and drawing a scatter plot. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>the column name of a known sample category (if exists).</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Method name for decomposition.
Available methods: ["tsne",
"isomap",
"random_projection",
"linear_discriminant",
"lle",
"modlle",
"hessian_lle",
"mds"]</dd>
<dt><strong><code>component</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of components</dd>
<dt><strong><code>n_neighbors</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of neighbors related to isomap and lle methods.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manifoldplot(df,category=&#34;&#34;, 
                 method=&#34;tsne&#34;,
                 n_components=2,
                 n_neighbors=4, show=False, **kwargs):
    &#34;&#34;&#34;
    Reducing the dimensionality of data and drawing a scatter plot. 
    
    Parameters
    ----------
    df : pandas DataFrame
    category: str
        the column name of a known sample category (if exists). 
    method: str
        Method name for decomposition. 
        Available methods: [&#34;tsne&#34;, 
                            &#34;isomap&#34;,
                            &#34;random_projection&#34;,
                            &#34;linear_discriminant&#34;,
                            &#34;lle&#34;,
                            &#34;modlle&#34;,
                            &#34;hessian_lle&#34;,
                            &#34;mds&#34;]
    component: int
        The number of components
    n_neighbors: int
        The number of neighbors related to isomap and lle methods.
    
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;    
    from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
    from sklearn.ensemble import RandomTreesEmbedding
    from sklearn.manifold import (
        Isomap,
        LocallyLinearEmbedding,
        MDS,
        SpectralEmbedding,
        TSNE,)
    from sklearn.neighbors import NeighborhoodComponentsAnalysis
    if category !=&#34;&#34;:
        category_val=df[category].values
        df=df.drop([category], axis=1)
        x = df.values
        assert x.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        x = df.values
        assert x.dtype==float, &#34;data must contain only float values.&#34;
    x=zscore(x, axis=0)
    features=df.columns
    original_index=df.index
    if method==&#34;random_projection&#34;: 
        embedding=SparseRandomProjection(
            n_components=n_components, random_state=42
        )
    elif method==&#34;linear_discriminant&#34;: 
        embedding=LinearDiscriminantAnalysis(
            n_components=n_components
        )
    elif method==&#34;isomap&#34;: 
        embedding=Isomap(n_neighbors=n_neighbors, n_components=n_components)
    
    elif method==&#34;lle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;standard&#34;
        )
    elif method==&#34;modlle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;modified&#34;
        )
    elif method==&#34;hessian_lle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;hessian&#34;
        )
    elif method==&#34;ltsa_lle&#34;: 
        embedding=LocallyLinearEmbedding(
            n_neighbors=n_neighbors, n_components=n_components, method=&#34;ltsa&#34;
        )
    elif method==&#34;mds&#34;: 
        embedding=MDS(
            n_components=n_components, n_init=1, max_iter=120, n_jobs=2, normalized_stress=&#34;auto&#34;
        )
    elif method==&#34;random_trees&#34;: 
        embedding=make_pipeline(
            RandomTreesEmbedding(n_estimators=200, max_depth=5, random_state=0),
            TruncatedSVD(n_components=n_components),
        )
    elif method==&#34;spectral&#34;: 
        embedding=SpectralEmbedding(
            n_components=n_components, random_state=0, eigen_solver=&#34;arpack&#34;
        )
    elif method==&#34;tsne&#34;: 
        embedding=TSNE(
            n_components=n_components,
            n_iter=500,
            n_iter_without_progress=150,
            n_jobs=2,
            random_state=0,perplexity=10
        )
    elif method==&#34;nca&#34;: 
        embedding=NeighborhoodComponentsAnalysis(
            n_components=n_components, init=&#34;pca&#34;, random_state=0
        )
    elif method==&#34;umap&#34;:
        import umap 
        embedding=umap.UMAP(
            min_dist=0.25,n_neighbors=15
        )
    else:
        raise Exception(f&#34;Medthod {method} does not exist.&#34;)
    Xt=embedding.fit_transform(x)
    dft = pd.DataFrame(data = np.array([Xt[:,0],Xt[:,1]]).T, columns = [&#34;d1&#34;, &#34;d2&#34;],index=original_index)
    if category !=&#34;&#34;:
        fig, ax=plt.subplots()
        dft[category]=category_val
        sns.scatterplot(data=dft, x=&#34;d1&#34;, y=&#34;d2&#34;, hue=category, ax=ax,**kwargs)
    else:
        sns.scatterplot(data=dft, x=&#34;d1&#34;, y=&#34;d2&#34;, ax=ax,**kwargs)
    if show==True:
        plt.show()
    return {&#34;data&#34;: dft, &#34;axes&#34;: ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.nice_piechart"><code class="name flex">
<span>def <span class="ident">nice_piechart</span></span>(<span>df: pandas.core.frame.DataFrame, category: Union[List[str], str], palette: str = 'tab20c', ncols: int = 2, ignore: float = 0.05, show_values: bool = True) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nice_piechart(df: pd.DataFrame, 
                  category: Union[str, List[str]],
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True) -&gt;Dict:
    
    if type(category)==str:
        category=[category]
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=[ncols*2,
                                                        nrows*2])
    axes=axes.flatten()
    for cat, ax in zip(category, axes):
        u, c=np.unique(df[cat], return_counts=True)
        
        srt=np.argsort(c)[::-1]
        u=u[srt]
        c=c[srt]
        _c=c/np.sum(c)
        
        
        
        _cmap=plt.get_cmap(palette, c.shape[0])
        colors=[_cmap(i) for i in range(c.shape[0])]
        for j in range(c.shape[0]):
            if _c[j]&lt;ignore:
                colors[j]=[0,0,0,1]
                u[j]=&#34;&#34;
                continue
            if show_values==True:
                u[j]=u[j]+&#34;\n(&#34;+str(100*np.round(_c[j],1))+&#34;%)&#34;
        
        ax.pie(c, labels=u, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=10)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.9)
    return {&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.nice_piechart_num"><code class="name flex">
<span>def <span class="ident">nice_piechart_num</span></span>(<span>df: pandas.core.frame.DataFrame, hue: List[str], category: str = '', palette: str = 'tab20c', ncols: int = 2, ignore: float = 0.05, show_values: bool = True, figsize=[]) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nice_piechart_num(df: pd.DataFrame,hue: List[str],
                      category: str=&#34;&#34; ,
                  
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True,
                  figsize=[]) -&gt;Dict:
    
    if category==&#34;&#34;:
        category=list(df.index)
    else:
        df=df.set_index(category)
        category=list(df.index)
        
    df=df[hue]
    srt=np.argsort(df.sum(axis=0))[::-1]
    df=df[df.columns[srt]]
    hue=list(df.columns)
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    if len(figsize)==0:
        figsize=[ncols*2,nrows*2]
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize)
    axes=axes.flatten()
    _cmap=plt.get_cmap(palette, len(hue))
    colors=[_cmap(i) for i in range(len(hue))]
    for cat, ax in zip(category, axes):
        c=df.loc[cat]
        _c=c/np.sum(c)
        ax.pie(c, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=8)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.95, right=0.81)
    
    legend_elements = [Line2D([0], [0], marker=&#39;o&#39;, color=&#39;lavender&#39;, label=huelabel,markerfacecolor=color, markersize=10)
                      for color, huelabel in zip(colors, hue)]
    
    fig.legend(handles=legend_elements,bbox_to_anchor=(1, 1))
    return {&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.pie_scatter"><code class="name flex">
<span>def <span class="ident">pie_scatter</span></span>(<span>df: pandas.core.frame.DataFrame, x: str, y: str, category: list, pie_palette: str = 'tab20c', xlabel: str = '', ylabel: str = '', piesize: float = 0.01, label: Union[List[~T], str] = 'all', topn=10, logscalex: bool = False, logscaley: bool = False, ax: Optional[matplotlib.axes._axes.Axes] = None, sizes: Union[List[~T], str] = '', save: str = '', show: bool = False, edge_color: str = 'gray', min_piesize: float = 0.3, figsize=[6, 6]) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a scatter plot of which points are represented by pie charts. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>A wide form dataframe. Index names are used to label points
e.g.)
gas
coal
nuclear
population
GDP
USA
20
20
5
20
50
China
30
40
5
40
50
India
5
10
1
40
10
Japan
5
5
1
10
10</dd>
</dl>
<p>x,y : str
the names of columns to be x and y axes of the scatter plot.</p>
<dl>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>the names of categorical values to display as pie charts</dd>
<dt><strong><code>pie_palette</code></strong> :&ensp;<code>str</code></dt>
<dd>A colormap name</dd>
<dt><strong><code>xlabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>x axis label</dd>
<dt><strong><code>ylabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>y axis label</dd>
<dt><strong><code>piesize</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.01)</code></dt>
<dd>pie chart size.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional <code>(default: "all")</code></dt>
<dd>"all": all
"topn_of_sum":</dd>
<dt><strong><code>logscalex</code></strong>, <strong><code>logscaley</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Whether to scale x an y axes with logarithm</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>Optional[plt.Axes] optional, (default: None)</code></dt>
<dd>pyplot ax to add this scatter plot</dd>
<dt><strong><code>sizes</code></strong> :&ensp;<code>Union[List, str]</code>, optional <code>(default: "")</code></dt>
<dd>pie chart sizes.
"sum_of_each": automatically set pie chart sizes to be proportional to the sum of all categories.
list: the list of pie chart sizes</dd>
<dt><strong><code>edge_color</code></strong> :&ensp;<code>str="gray",</code></dt>
<dd>The pie chart edge color</dd>
<dt><strong><code>min_piesize</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.3)</code></dt>
<dd>Minimal pie chart size. This option is effective when the option sizes="sum_of_each".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pie_scatter(df: pd.DataFrame,  
                x: str, 
                y: str, 
                category: list, 
                pie_palette: str=&#34;tab20c&#34;,
                xlabel: str=&#34;&#34;,
                ylabel: str=&#34;&#34;,
                piesize: float=0.01, 
                label: Union[List, str]=&#34;all&#34;,topn=10,
                logscalex: bool=False,
                logscaley: bool=False,
                ax: Optional[plt.Axes]=None,
                sizes: Union[List, str]=&#34;&#34;,
                save: str=&#34;&#34;,
                show: bool=False,
                edge_color: str=&#34;gray&#34;,
                min_piesize: float=0.3,
                figsize=[6,6]) -&gt; dict:
    &#34;&#34;&#34;
    Drawing a scatter plot of which points are represented by pie charts. 
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide form dataframe. Index names are used to label points
        e.g.) 
                    gas    coal    nuclear    population    GDP
            USA      20      20          5            20     50
            China    30      40          5            40     50
            India     5      10          1            40     10
            Japan     5       5          1            10     10
            
    x,y : str
        the names of columns to be x and y axes of the scatter plot.
        
    category: str or list
        the names of categorical values to display as pie charts
    
    pie_palette : str
        A colormap name
    xlabel: str, optional
        x axis label
    ylabel: str, optional
        y axis label
    piesize: float, optional (default: 0.01) 
        pie chart size. 
    label: str, optional (default: &#34;all&#34;)
        &#34;all&#34;: all 
        &#34;topn_of_sum&#34;:
    logscalex, logscaley: bool, optional (default: False)
        Whether to scale x an y axes with logarithm
    ax: Optional[plt.Axes] optional, (default: None)
        pyplot ax to add this scatter plot
    sizes: Union[List, str], optional (default: &#34;&#34;)
        pie chart sizes.
            &#34;sum_of_each&#34;: automatically set pie chart sizes to be proportional to the sum of all categories.
            list: the list of pie chart sizes
    edge_color: str=&#34;gray&#34;,
        The pie chart edge color
    min_piesize: float, optional (default: 0.3)
        Minimal pie chart size. This option is effective when the option sizes=&#34;sum_of_each&#34;. 
    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if type(pie_palette)== str:
        colors={}
        unique_labels=category
            
        cmap=plt.get_cmap(pie_palette)
        labelnum=len(unique_labels)
        for i, ul in enumerate(unique_labels):
            colors[ul]=cmap(i/labelnum)
    elif type(pie_palette)==dict:
        colors=pie_palette
        unique_labels=colors.keys()
    else:
        raise Exception(&#34;Unknown pie_palette type.&#34;)
    if ax ==None:
        fig, ax=plt.subplots(figsize=figsize)
    plt.subplots_adjust(right=0.80)
    X=df[x]
    Y=df[y]
    yscale=&#34;&#34;
    xscale=&#34;&#34;
    if logscaley==True:
        Y=np.log10(Y+1)
        yscale=&#34; (scaled by log10)&#34;
    if logscalex==True:
        X=np.log10(X+1)
        xscale=&#34; (scaled by log10)&#34;
    Frac=df[category]
    
    index=df.index
    piesize=np.amax([np.amax(X), np.amax(Y)])*piesize
    
    if sizes==&#34;sum_of_each&#34;:
        sums=Frac.sum(axis=1)
        sumsrt=np.argsort(sums)[::-1]
        sumsrt=set(sumsrt[:topn])
        sums=sums/np.amax(sums)
        sums=piesize*(sums+min_piesize)
    _colors=[colors[f] for f in unique_labels]
    for i, (_x, _y, _ind) in enumerate(zip(X, Y, index)):
        _frac=Frac.loc[_ind].values 
        _frac=2*np.pi*np.array(_frac)/np.sum(_frac)
        
        angle=0
        #print(sums.loc[_ind])
        for fr, co in zip(_frac, _colors):
            if type(sizes)==str:
                if sizes==&#34;sum_of_each&#34;:
                    _baumkuchen_xy(ax, _x, _y, angle, fr, 0, sums.loc[_ind],20, co, edge_color=edge_color)
                elif sizes==&#34;&#34;:
                    _baumkuchen_xy(ax, _x, _y, angle, fr, 0, piesize,20, co, edge_color=edge_color)
                else:
                    pass
            elif type(sizes)==list and len(sizes) !=0:
                _baumkuchen_xy(ax, _x, _y, angle, fr, 0, piesize*sizes[i],20, co, edge_color=edge_color)
            else:
                _baumkuchen_xy(ax, _x, _y, angle, fr, 0, piesize,20, co, edge_color=edge_color)
            angle+=fr
        
        if type(label)==str:
            if label==&#34;all&#34;:
                ax.text(_x, _y,_ind)
            elif label==&#34;topn_of_sum&#34;:
                if i in sumsrt:
                    ax.text(_x, _y,_ind)
                
            elif label==&#34;&#34;:
                pass
        elif type(label)==list:
            if _ind in label:
                ax.text(_x, _y,_ind)
            
            
    if xlabel!=&#34;&#34;:
        x=xlabel
    if ylabel!=&#34;&#34;:
        y=ylabel
    plt.xlabel(x+xscale)
    plt.ylabel(y+yscale)
    legend_elements = [Line2D([0], [0], marker=&#39;o&#39;, color=&#39;lavender&#39;, label=ul,markerfacecolor=colors[ul], markersize=10)
                      for ul in unique_labels]
    
    ax.legend(handles=legend_elements,bbox_to_anchor=(0.95, 1))
    _save(save, &#34;pie_scatter&#34;)
    return {&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.radialtree"><code class="name flex">
<span>def <span class="ident">radialtree</span></span>(<span>df: pandas.core.frame.DataFrame, n_clusters: int = 3, category: Union[List[str], str] = [], save: str = '', **kwargs) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a radial dendrogram with color labels.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>n_clusters</code></strong> :&ensp;<code>int</code></dt>
<dd>Approximate number of clusters to produce</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>the column name of a category that is going to presented as colors around the dendrogram.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code></dt>
<dd>A float to specify the font size</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>[x, y] array-like</code></dt>
<dd>1D array-like of floats to specify the figure size</dd>
<dt><strong><code>palette</code></strong> :&ensp;<code>string</code></dt>
<dd>Matlab colormap name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong> :&ensp;<code>{"axes":ax, "clusters": clusters}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radialtree(df: pd.DataFrame,
               n_clusters: int=3,
               category: Union[str, List[str]]=[], 
               save: str=&#34;&#34;, 
               **kwargs) -&gt; Dict:
    &#34;&#34;&#34;
    Drawing a radial dendrogram with color labels.
    
    Parameters
    ----------
    df : pandas DataFrame
        
    n_clusters: int
        Approximate number of clusters to produce
    category: str or list of str
        the column name of a category that is going to presented as colors around the dendrogram.
    show : bool
        Whether or not to show the figure.
    fontsize : float
        A float to specify the font size
    figsize : [x, y] array-like
        1D array-like of floats to specify the figure size
    palette : string
        Matlab colormap name.
    Returns
    -------
    dict: {&#34;axes&#34;:ax, &#34;clusters&#34;: clusters}

    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if len(category) !=0:
        if type(category)==str:
            category=[category]
        category_df=df[category]
        df=df.drop(category, axis=1)
        X = df.values
        #print(X)
        assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
        
    else:    
        X = df.values
        assert X.dtype==float, &#34;data must contain only float values.&#34;
    X=zscore(X, axis=0)
    D=squareform(pdist(X))
    Y = sch.linkage(D, method=&#39;ward&#39;)
    Z = sch.dendrogram(Y,labels=df.index,no_plot=True)
    t=_dendrogram_threshold(Z, n_clusters)
    Z=sch.dendrogram(Y,
                        labels = df.index,
                        color_threshold=t,no_plot=True)
    sample_classes={k: list(category_df[k]) for k in category_df.columns}
    ax=_radialtree2(Z, sample_classes=sample_classes,addlabels=False, **kwargs)
    _save(save, &#34;radialtree&#34;)
    clusters = _get_cluster_classes(Z)
    return {&#34;axes&#34;:ax, &#34;clusters&#34;:clusters}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.regression_single"><code class="name flex">
<span>def <span class="ident">regression_single</span></span>(<span>df, x: str = '', y: str = '', method: str = 'ransac', category: str = '', figsize: List[int] = [5, 5], show=False, ransac_param={'max_trials': 1000}, robust_param={}) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a scatter plot with a single variable linear regression.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code></dt>
<dd>the column name of x axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>str</code></dt>
<dd>the column name of y axis.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Method name for regression. Default: ransac
Available methods: ["ransac",
"robust",
"lasso","elastic_net"
]</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>figure size</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong> :&ensp;<code>dict {"axes":ax, "coefficient":coef,"intercept":intercept,"coefficient_pval":coef_p, "r2":r2, "fitted_model":fitted_model}</code></dt>
<dd>fitted_model:
this can be used like: y_predict=fitted_model.predict(_X)</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regression_single(df, 
                      x: str=&#34;&#34;,
                      y: str=&#34;&#34;, 
                      method: str=&#34;ransac&#34;,
                      category: str=&#34;&#34;, 
                      figsize: List[int]=[5,5],
                      show=False, ransac_param={&#34;max_trials&#34;:1000},
                      robust_param={}) -&gt; Dict:
    &#34;&#34;&#34;
    Drawing a scatter plot with a single variable linear regression.  
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str
        the column name of x axis. 
    y: str
        the column name of y axis. 

    method: str
        Method name for regression. Default: ransac
        Available methods: [&#34;ransac&#34;, 
                            &#34;robust&#34;,
                            &#34;lasso&#34;,&#34;elastic_net&#34;
                            ]
    figsize: list[int]
        figure size
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    dict: dict {&#34;axes&#34;:ax, &#34;coefficient&#34;:coef,&#34;intercept&#34;:intercept,&#34;coefficient_pval&#34;:coef_p, &#34;r2&#34;:r2, &#34;fitted_model&#34;:fitted_model}
    
        fitted_model:
            this can be used like: y_predict=fitted_model.predict(_X)
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34; 
    
    
    Y=df[y]
    _X=np.array(df[x]).reshape([-1,1])
    X=np.array(df[x])
    plotline_X = np.arange(X.min(), X.max()).reshape(-1, 1)
    n = X.shape[0]
    plt.rcParams.update({&#39;font.size&#39;: 14})
    fig, ax = plt.subplots(figsize=figsize)
    plt.subplots_adjust(left=0.15)
    if method==&#34;ransac&#34;:
        from sklearn.linear_model import RANSACRegressor
        
        
        
        fit_df=pd.DataFrame()
        fitted_model = RANSACRegressor(random_state=42,**ransac_param).fit(_X,Y)
        fit_df[&#34;ransac_regression&#34;] = fitted_model.predict(plotline_X)
        coef = fitted_model.estimator_.coef_[0]
        intercept=fitted_model.estimator_.intercept_
        inlier_mask = fitted_model.inlier_mask_
        outlier_mask = ~inlier_mask
        
                                # number of samples
        y_model=fitted_model.predict(_X)

        r2 = _calc_r2(X,Y)
        # mean squared error
        MSE = 1/n * np.sum( (Y - y_model)**2 )
        
        # to plot the adjusted model
        x_line = plotline_X.flatten()
        y_line = fit_df[&#34;ransac_regression&#34;]
         
        ci, pi, std_error=_ci_pi(X,Y,plotline_X.flatten(),y_model)
        q=((X-X.mean()).transpose() @ (X-X.mean()))
        sigma=std_error*(q**-1)**(0.5)
        coef_p=stats.t.sf(abs(fitted_model.estimator_.coef_[0]/sigma), df=X.shape[0]-2)
        ############### Ploting

        _draw_ci_pi(ax, ci, pi,x_line, y_line)
        sns.scatterplot(x=X[inlier_mask], y=Y[inlier_mask], color=&#34;blue&#34;, label=&#34;Inliers&#34;)
        sns.scatterplot(x=X[outlier_mask], y=Y[outlier_mask], color=&#34;red&#34;, label=&#34;Outliers&#34;)
        plt.xlabel(x)
        plt.ylabel(y)
        #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
        plt.title(&#34;RANSAC regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(
            r2, MSE,coef,intercept,coef_p
            )
        )
        plt.plot(plotline_X.flatten(),fit_df[&#34;ransac_regression&#34;])
        if len(category)!=0:
            fig, ax=plt.subplots(figsize=figsize)
            plt.subplots_adjust(left=0.15)
            _draw_ci_pi(ax, ci, pi,x_line, y_line)
            sns.scatterplot(data=df,x=x, y=y, hue=category)
            
            plt.xlabel(x)
            plt.ylabel(y)
            #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
            plt.title(&#34;RANSAC regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(
                r2, MSE,coef,intercept,coef_p
                )
            )
            plt.plot(plotline_X.flatten(),fit_df[&#34;ransac_regression&#34;])
    elif method==&#34;robust&#34;:
        import statsmodels.api as sm
        rlm_model = sm.RLM(Y, sm.add_constant(X),
        M=sm.robust.norms.HuberT(),**robust_param)
        fitted_model = rlm_model.fit()
        summary=fitted_model.summary()
        coef=fitted_model.params[1]
        intercept=fitted_model.params[0]
        intercept_p=fitted_model.pvalues[0]
        coef_p=fitted_model.pvalues[1]
        y_model=fitted_model.predict(sm.add_constant(X))
        r2 = _calc_r2(X,Y)
        x_line = plotline_X.flatten()
        y_line = fitted_model.predict(sm.add_constant(x_line))
        
        ci, pi,std_error=_ci_pi(X,Y,plotline_X.flatten(),y_model)
        MSE = 1/n * np.sum( (Y - y_model)**2 )

        _draw_ci_pi(ax, ci, pi,x_line, y_line)
        sns.scatterplot(data=df,x=x, y=y, color=&#34;blue&#34;)
        #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
        plt.title(&#34;Robust linear regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x , p-values: coefficient {:.2f}, \
        intercept {:.2f}&#34;.format(
            r2, MSE,coef,intercept,coef_p,intercept_p
            )
        )
        plt.plot(plotline_X.flatten(),y_line)
        if len(category)!=0:
            fig, ax=plt.subplots(figsize=figsize)
            plt.subplots_adjust(left=0.15)
            _draw_ci_pi(ax, ci, pi,x_line, y_line)
            sns.scatterplot(data=df,x=x, y=y, hue=category)
            #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
            plt.title(&#34;Robust linear regression, r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x , p-values: coefficient {:.2f}, \
            intercept {:.2f}&#34;.format(
                r2, MSE,coef,intercept,coef_p,intercept_p
                )
            )
            plt.plot(plotline_X.flatten(),y_line)
    elif method==&#34;lasso&#34; or method==&#34;elastic_net&#34; or method==&#34;ols&#34;:
        if method==&#34;lasso&#34;:
            method=&#34;sqrt_lasso&#34;
        import statsmodels.api as sm
        rlm_model = sm.OLS(Y, sm.add_constant(X))
        if method==&#34;ols&#34;:
            fitted_model = rlm_model.fit()
        else:
            fitted_model = rlm_model.fit_regularized(method)
        coef=fitted_model.params[1]
        intercept=fitted_model.params[0]
        y_model=fitted_model.predict(sm.add_constant(X))
        r2 = _calc_r2(X,Y)
        x_line = plotline_X.flatten()
        y_line = fitted_model.predict(sm.add_constant(x_line))
        ci, pi, std_error=_ci_pi(X,Y,plotline_X.flatten(),y_model)
        q=((X-X.mean()).transpose() @ (X-X.mean()))
        sigma=std_error*(q**-1)**(0.5)
        print(sigma,coef )
        coef_p=stats.t.sf(abs(coef/sigma), df=X.shape[0]-2)
        MSE = 1/n * np.sum( (Y - y_model)**2 )

        _draw_ci_pi(ax, ci, pi,x_line, y_line)   
        sns.scatterplot(data=df,x=x, y=y, color=&#34;blue&#34;)
        #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
        plt.title(&#34;OLS ({}), r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(method,
            r2, MSE,coef,intercept,coef_p
            )
        )
        plt.plot(plotline_X.flatten(),y_line)
        if len(category)!=0:
            fig, ax=plt.subplots(figsize=figsize)
            plt.subplots_adjust(left=0.15)
            _draw_ci_pi(ax, ci, pi,x_line, y_line)
            sns.scatterplot(data=df,x=x, y=y, color=&#34;blue&#34;,hue=category)
            #print(r2, MSE,ransac_coef,ransac.estimator_.intercept_)
            plt.title(&#34;OLS ({}), r2: {:.2f}, MSE: {:.2f}\ny = {:.2f} + {:.2f}x, coefficient p-value: {:.2E}&#34;.format(method,
                r2, MSE,coef,intercept,coef_p
                )
            )
            plt.plot(plotline_X.flatten(),y_line)
    return {&#34;axes&#34;:ax, &#34;coefficient&#34;:coef,&#34;intercept&#34;:intercept,&#34;coefficient_pval&#34;:coef_p, &#34;r2&#34;:r2, &#34;fitted_model&#34;:fitted_model}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.stacked_barplot"><code class="name flex">
<span>def <span class="ident">stacked_barplot</span></span>(<span>df: pandas.core.frame.DataFrame, x: Union[str, list], hue: Union[str, list], scale: str = 'fraction', order: list = [], hue_order: list = [], test_pairs: List[List[str]] = [], show_values: bool = True, show: bool = False, figsize: List[int] = [4, 6]) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a stacked barplot with or without the fisher's exact test </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>The category to place in x axis. Only str values are accepted.</dd>
<dt><strong><code>hue</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>Counting samples by the hue category. Only str values are accepted.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The order of x axis labels</dd>
<dt><strong><code>hue_order</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The order of hue labels</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Scaling method. Available options are: fraction, percentage, absolute</dd>
<dt>test_pairs : pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.</dt>
<dt>Examples: [["Adelie","Chinstrap" ],</dt>
<dt>["Gentoo","Chinstrap" ],</dt>
<dt>["Adelie","Gentoo" ]]</dt>
<dt><strong><code>show_number</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheter to exhibit the values of fractions/counts/percentages.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>List[int]</code>, optional</dt>
<dd>The figure size, e.g., [4, 6].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict("p values":pvalues,"axes":ax)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stacked_barplot(df: pd.DataFrame,
                    x: Union[str, list],
                    hue: Union[str, list],
                    scale: str=&#34;fraction&#34;,
                    order: list=[],
                    hue_order: list=[],
                    test_pairs: List[List[str]]=[],
                    show_values: bool=True,
                    show: bool=False,
                    figsize: List[int]=[4,6])-&gt; Dict:
    
    &#34;&#34;&#34;
    Drawing a stacked barplot with or without the fisher&#39;s exact test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str or list
        The category to place in x axis. Only str values are accepted.
    hue: str or list
        Counting samples by the hue category. Only str values are accepted.
    order: list, optional
        The order of x axis labels
    hue_order: list, optional
        The order of hue labels
    scale: str, optional
        Scaling method. Available options are: fraction, percentage, absolute
    test_pairs : pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    show_number: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    show : bool, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
     
    Returns
    -------
    dict(&#34;p values&#34;:pvalues,&#34;axes&#34;:ax)
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    if df[x].isnull().values.any():
        df[x]=df[x].replace(np.nan, &#34;NA&#34;)
    
    if df[hue].isnull().values.any():
        df[hue]=df[hue].replace(np.nan, &#34;NA&#34;)
    
    data={}
    if len(order)==0:
        u=np.unique(df[x])
        keys=sorted(list(u))
    else:
        keys=order
    if len(hue_order)==0:
        u=np.unique(df[hue])
        hues=sorted(list(u))
    else:
    
        hues=hue_order
    for key in keys:
        data[key]=[]
        for h in hues:
            data[key].append(np.sum((df[x]==key) &amp; (df[hue]==h)))
    pvals={}
    if len(test_pairs) &gt;0:
        
        for i, h in enumerate(hues):
            pvals[h]=[]
            for p1,p2 in test_pairs:
                idx1=keys.index(p1)
                idx2=keys.index(p2)
                yes_total=np.sum(data[keys[idx1]])
                no_total=np.sum(data[keys[idx2]])
                yes_and_hue=data[keys[idx1]][i]
                no_and_hue=data[keys[idx2]][i]
                table=[[yes_and_hue, no_and_hue],
                       [yes_total-yes_and_hue, no_total-no_and_hue]]
                
                odd, pval=fisher_exact(table)
                pvals[h].append([idx1, idx2, pval])
    if scale==&#34;fraction&#34;:
        for key in keys:
            data[key]=np.array(data[key])/np.sum(data[key])
    elif scale==&#34;percentage&#34;:
        for key in keys:
            data[key]=np.array(data[key])/np.sum(data[key])*100
    bottom=np.zeros([len(keys)])
    cmap=plt.get_cmap(&#34;tab20b&#34;)
    fig, ax=plt.subplots(figsize=figsize)
    plt.subplots_adjust(left=0.2,right=0.6, bottom=0.17)
    if scale==&#34;absolute&#34;:
        unit=&#34;&#34;
    elif scale==&#34;fraction&#34;:
        unit=&#34;&#34;
    elif scale==&#34;percentage&#34;:
        unit=&#34;%&#34;
    pos={}
    for i, h in enumerate(hues):
        
        heights=np.array([data[key][i] for key in keys])
        
        
        plt.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h)
        if show_values==True:
            for j in range(len(keys)):
                if scale==&#34;absolute&#34;:
                    plt.text(j,bottom[j]+heights[j]/2,&#34;{}{}&#34;.format(heights[j],unit), 
                         bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                else:
                    plt.text(j,bottom[j]+heights[j]/2,&#34;{:.2f}{}&#34;.format(heights[j],unit), 
                         bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
        plt.xticks(rotation=90)
        pos[h]={key: [he, bo] for key, he, bo in zip(keys, heights, bottom)}
        bottom+=heights
    ax.legend(loc=[1.01,0])
    ax.set_xlabel(x)
    if scale==&#34;absolute&#34;:
        ylabel=&#34;Counts&#34;
    elif scale==&#34;fraction&#34;:
        ylabel=&#34;Fraction&#34;
    elif scale==&#34;percentage&#34;:
        ylabel=&#34;Percentage&#34;
    ax.set_ylabel(ylabel)
    
    if len(pvals)&gt;0:
        print(&#34;mlp stands for -log10(p value)&#34;)
        for i, h in enumerate(hues):
            _pos=pos[h]
            for idx1, idx2, pval in pvals[h]:
                if pval &lt; 0.05:
                    he1, bot1=_pos[keys[idx1]]
                    he2, bot2=_pos[keys[idx2]]
                    line, =plt.plot([idx1,idx2],[he1/2+bot1,he2/2+bot2],color=&#34;gray&#34;)
                    # r1=ax.transData.transform([idx1, he1/2+bot1])
                    # r2=ax.transData.transform([idx2, he2/2+bot2])
                    r1=np.array([idx1, he1/2+bot1])
                    r2=np.array([idx2, he2/2+bot2])
                    r=r2-r1
                    print(ax.get_xlim(),ax.get_ylim())
                    r=np.array([1,3])*r/np.array([ax.get_xlim()[1]-ax.get_xlim()[0],ax.get_ylim()[1]-ax.get_ylim()[0]])
                    #r=ax.transData.transform(r)
                    if idx2&lt;idx1:
                        r=-r
                    print(r)
                    r=r*(r @ r)**(-0.5)
                    print(h,r)
                    angle=np.arccos(r[0])
                    if r[1]&lt;0:
                        angle= -angle
                    print(angle)
                    _line_annotate( &#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)), line, (idx1+idx2)/2, color=&#34;magenta&#34;)
                    # plt.text((idx1+idx2)/2, 0.5*(he1/2+bot1+he2/2+bot2), &#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)), 
                    #          color=&#34;magenta&#34;, va=&#34;center&#34;,ha=&#34;center&#34;, rotation=360*angle/(2*np.pi),)
                    # plt.annotate(&#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)),[(r1[0]+r2[0])/2, 0.5*(r1[1]+r2[1])],   
                    #          color=&#34;magenta&#34;,ha=&#34;center&#34;, rotation=360*angle/(2*np.pi),xycoords=&#39;figure pixels&#39;)
                    #
    if show:
        plt.show()
    
    return {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.stackedlines"><code class="name flex">
<span>def <span class="ident">stackedlines</span></span>(<span>df: pandas.core.frame.DataFrame, x: str, y: list, sort: bool = True, title: str = '', inverse: bool = False, show_val: bool = False, remove_all_zero: bool = False, palette: str = 'tab20c', figsize=[7, 4], ax: Optional[matplotlib.axes._axes.Axes] = None, alpha: float = 0.75, bbox_to_anchor: list = [1.7, 1], right: float = 0.7, bottom: float = 0.12, show_legend: bool = True, xlabel: str = '', ylabel: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a scatter plot of which points are represented by pie charts. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>A wide form dataframe. Index names are used to label points
e.g.)
year
biofuel_consumption
coal_consumption
gas_consumption
hydro_consumption
nuclear_consumption
oil_consumption
90
1990
16.733
5337.998
5170.609
864.271
1723.004
9306.913
91
1991
19.389
5287.613
5283.972
849.620
1829.645
9108.509
92
1992
22.045
5324.031
5463.509
743.463
1848.197
9297.387
93
1993
25.759
5522.452
5599.419
825.742
1822.853
9376.045
94
1994
28.846
5543.144
5731.081
766.870
1912.903
9619.746
95
1995
30.942
5593.053
5979.829
920.274
2011.356
9597.527</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of a column to be the x axis of the plot.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>list</code></dt>
<dd>the names of categorical values to display as stacked lines</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>bool</code>, optional <code>(default: True)</code></dt>
<dd>Whether to sort lines based on their values</dd>
<dt><strong><code>show_val</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Whether to show percentages at the end of lines.</dd>
<dt><strong><code>remove_all_zero</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>pie_palette</code></strong> :&ensp;<code>str</code></dt>
<dd>A colormap name</dd>
<dt><strong><code>xlabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>x axis label</dd>
<dt><strong><code>ylabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>y axis label</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>Optional[plt.Axes] optional, (default: None)</code></dt>
<dd>pyplot ax to add this scatter plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stackedlines(df: pd.DataFrame, 
                x: str,
                y: list,
                sort: bool=True,
                title: str=&#34;&#34;,
                inverse: bool=False,
                show_val: bool=False,
                remove_all_zero: bool=False,
                palette: str=&#34;tab20c&#34;,
                figsize=[7,4],
                ax: Optional[plt.Axes]=None,
                alpha: float=0.75,
                bbox_to_anchor: list=[1.7, 1],
                right: float=0.7,
                bottom: float=0.120,
                show_legend: bool=True,
                xlabel: str=&#34;&#34;,
                ylabel: str=&#34;&#34;,):
    &#34;&#34;&#34;
    Drawing a scatter plot of which points are represented by pie charts. 
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide form dataframe. Index names are used to label points
        e.g.) 
              year    biofuel_consumption    coal_consumption    gas_consumption    hydro_consumption    nuclear_consumption    oil_consumption
        90    1990                 16.733            5337.998           5170.609              864.271               1723.004           9306.913
        91    1991                 19.389            5287.613           5283.972              849.620               1829.645           9108.509
        92    1992                 22.045            5324.031           5463.509              743.463               1848.197           9297.387
        93    1993                 25.759            5522.452           5599.419              825.742               1822.853           9376.045
        94    1994                 28.846            5543.144           5731.081              766.870               1912.903           9619.746
        95    1995                 30.942            5593.053           5979.829              920.274               2011.356           9597.527            
    x : str
        the name of a column to be the x axis of the plot.
        
    y: list
        the names of categorical values to display as stacked lines
    sort: bool, optional (default: True)
        Whether to sort lines based on their values
    show_val: bool, optional (default: False)
        Whether to show percentages at the end of lines.
    
    remove_all_zero: bool, optional (default: False)    
    
    pie_palette : str
        A colormap name
    xlabel: str, optional
        x axis label
    ylabel: str, optional
        y axis label
    ax: Optional[plt.Axes] optional, (default: None)
        pyplot ax to add this scatter plot


    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    df=df.fillna(0)
    X=np.array(df[x])
    Y=[]
    for col in y:
        Y.append(np.array(df[col]))
    Y=np.array(Y)
    if remove_all_zero==True:
        filter=Y.sum(axis=0)!=0
        Y=Y[:,filter]
        X=X[filter]
    Ydict={col:[] for col in y}
    if sort==True:
        for i, _x in enumerate(X):
            
            srtidx=np.argsort(Y[:,i])
            _bottom=0
            for _idx in srtidx:
                _col=y[_idx]
                yval=Y[_idx,i]
                Ydict[_col].append([_bottom, yval+_bottom])
                _bottom+=yval
    else:
        for i, _x in enumerate(X):

            _bottom=0
            for _idx,_col in enumerate(y):
                yval=Y[_idx,i]
                Ydict[_col].append([_bottom, yval+_bottom])
                _bottom+=yval
    if ax ==None:
        fig, ax=plt.subplots(figsize=figsize)
        
    cmap=plt.get_cmap(palette, len(y))
    colorlut={col: cmap(i) for i, col in enumerate(y)}
    last_vals=[]
    last_pos=[]
    for col, vals in Ydict.items():
        vals=np.array(vals)
        ax.fill_between(X, vals[:,0], vals[:,1], label=col, alpha=alpha, color=colorlut[col])
        last_vals.append(vals[-1,1]-vals[-1,0])
        last_pos.append(vals[-1,1]/2+vals[-1,0]/2)
    if show_val==True:
        last_vals=100*np.array(last_vals)/np.sum(last_vals)
        for val, pos in zip(last_vals, last_pos):
            ax.text(X[-1], pos, str(np.round(val, 1))+&#34;%&#34;)
            
    if show_legend==True:
        plt.legend(bbox_to_anchor=bbox_to_anchor)
    plt.subplots_adjust(right=right, bottom=bottom)
    if xlabel !=&#34;&#34;:
        ax.set_xlabel(xlabel)
    else:
        ax.set_xlabel(x)
    ax.set_ylabel(ylabel)
    ax.set_title(title)</code></pre>
</details>
</dd>
<dt id="omniplot.plot.triangle_heatmap"><code class="name flex">
<span>def <span class="ident">triangle_heatmap</span></span>(<span>df, grid_pos: list = [], grid_labels: list = [], show: bool = False, save: str = '') ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Creating a heatmap with 45 degree rotation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>grid_pos</code></strong> :&ensp;<code>list</code></dt>
<dd>the column name of a category that is going to be placed in the row of the dotplot</dd>
<dt><strong><code>grid_labels</code></strong> :&ensp;<code>list</code></dt>
<dd>the column name of a category that is going to be placed in the column of the dotplot</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict {"axes": ax}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_heatmap(df, 
                     grid_pos: list=[],
                     grid_labels: list=[],
                     show: bool=False, save: str=&#34;&#34;)-&gt; dict:
    
    &#34;&#34;&#34;
    Creating a heatmap with 45 degree rotation.
    
    Parameters
    ----------
    df : pandas DataFrame
    grid_pos: list
        the column name of a category that is going to be placed in the row of the dotplot
    grid_labels: list
        the column name of a category that is going to be placed in the column of the dotplot
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    dict {&#34;axes&#34;: ax}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    
    genes=df.index
    fig, ax = plt.subplots(figsize=[8,6])
    dmat=df.to_numpy()
    D = dmat
    N = dmat.shape[0]
    a=np.tril(np.zeros([N,N])-1000000, k=-1)
    # Get the lower triangle of the matrix. 
    C = np.triu(D)+a
    
    # Mask the upper triangle.
    C = np.ma.masked_array(C, C == -1000000)
    # Set the diagonal to zero.
    for i in range(N):
        C[i, i] = 0
    
    # Transformation matrix for rotating the heatmap.
    A = np.array([(y, x) for x in range(N, -1, -1) for y in range(N + 1)])
    t = np.array([[2**(-0.5), 2**(-0.5)], [-2**(-0.5), 2**(-0.5)]])
    A = np.dot(A, t)
    #t_ = np.array([[2**(-0.5), -2**(-0.5)], [2**(-0.5), 2**(-0.5)]])
    
    # -1.0 correlation is blue, 0.0 is white, 1.0 is red.
    cmap = plt.cm.Reds
    #norm = mp.colors.BoundaryNorm(np.linspace(0, 10, 14), cmap.N)
    
    # This MUST be before the call to pl.pcolormesh() to align properly.
    ax.set_xticks([])
    ax.set_yticks([])
    
    X = A[:, 1].reshape(N + 1, N + 1)
    Y = A[:, 0].reshape(N + 1, N + 1)
    caxes = plt.pcolormesh(X, Y, np.flipud(C), axes=ax, cmap=cmap, rasterized=True)
    x1s=[0]
    if len(grid_pos)&gt;0:
        for i,  grid in enumerate(grid_pos):
            x0=(grid)/(2**(0.5))
            x1=(grid)*(2**0.5)
            y0=(grid)/(2**(0.5))
            y1=0
            ax.plot([x0, x1], [y0, y1],color=&#39;gray&#39;, linewidth=1)
            ax.plot([(grid)*(2**0.5), (grid)*(2**0.5)+(N-grid)/(2**(0.5))], [0, (N-grid)/(2**(0.5))], color=&#39;gray&#39;, linewidth=1)
            x1s.append(x1)
    x1s.append(N*2**0.5)
    
    

    if len(genes) &gt;0: 
        leng=0
        for i, g in enumerate(genes):
            #ax.plot([(i+0.5)*(2**0.5), (i+0.5)*(2**0.5)], [-2**0.5, -(N/10)*2**0.5/2],color=&#39;b&#39;, linewidth=0.5)
            ax.text((i+0.5)*(2**0.5), -(N/10)*2**0.5/2*1.01, g, rotation=90,ha=&#39;center&#39;, va=&#39;top&#39;, fontsize=&#34;small&#34;)
            leng+=len(g)
        leng=leng/len(genes)
    else:
        leng=0
    spacing=(N/10)*leng*0.4
    
    
    rect=Rectangle([0, -spacing],N*(2**0.5), spacing, color=&#39;whitesmoke&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    
    rect=Rectangle([0, -(N/10)*2**0.5/2],N*(2**0.5), (N/10)*2**0.5/2, color=&#39;dimgray&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    if len(grid_labels)&gt;0:
        for i in range(len(x1s)-1):
            if i%2==1:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;silver&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            else:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;lavender&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            x=(x1s[i]+x1s[i+1])/2
            ax.text(x,-(N/10)*2**0.5/4, grid_labels[i], rotation=90,ha=&#39;center&#39;, va=&#39;center&#39;, color=&#34;w&#34;)
    

    
    
    cb = plt.colorbar(caxes, ax=ax, shrink=0.75)
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;bottom&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_visible(False)
    if save!=&#34;&#34;:
        if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
            plt.savefig(save)
        else:
            plt.savefig(save+&#34;_complexheatmap.pdf&#34;)
    if show:
        plt.show()
    return {&#34;axes&#34;: ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.violinplot"><code class="name flex">
<span>def <span class="ident">violinplot</span></span>(<span>df, x: Optional[str] = None, y: Optional[str] = None, pairs: list = [], test: str = 'ttest_ind', alternative: str = 'two-sided', significance: str = 'numeric', significance_ranges: Dict[str, float] = {'*': 1.3010299956639813, '**': 4, '***': 10}, swarm: bool = False, xorder: list = [], equal_var: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a boxplot with a statistical test </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt>x,y: str</dt>
<dt>names of variables in data</dt>
<dt><strong><code>pairs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Category pairs for the statistical test.
Examples: [["Adelie","Chinstrap" ],
["Gentoo","Chinstrap" ],
["Adelie","Gentoo" ]]</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method name for the statistical test. Defalt: ttest_ind
Available methods: ["ttest_ind",
"ttest_rel",
"kruskal",
"mannwhitneyu",
"wilcoxon",
"brunnermunzel",
"median_test"]</dd>
<dt><strong><code>alternative</code></strong> :&ensp;<code>str ['two-sided', 'less', 'greater']</code>, optional</dt>
<dd>Defines the alternative hypothesis. Defalt: "two-sided"</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>significance</code></strong> :&ensp;<code>str ['numeric', 'symbol']</code>, optional</dt>
<dd>How to show the significance. 'numeric' will show -log10(p values) in the plot and
'symbol' will represent significance as asterisks.</dd>
<dt><strong><code>significance_ranges</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>thresholds of -log10(p values) that each asterisk number represents. Ignored when
significance="numeric".
example: {"<em>":-np.log10(0.05),"</em><em>":4,"</em>**":10}</dd>
<dt><strong><code>swarm</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to superpose a swarm plot. Not recommended if the sample size is too large.</dd>
<dt><strong><code>xorder</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The order of x axis labels</dd>
<dt><strong><code>equal_var</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Related to ttest_ind method. The default is True, which will produce a p value equal to t-test in R.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any options accepted by scipy statistical test functions</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict("p values":pvalues,"axes":ax)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def violinplot(df, 
               x: Optional[str]=None, 
               y: Optional[str]=None,
               pairs: list=[], 
               test: str=&#34;ttest_ind&#34;,
               alternative: str=&#34;two-sided&#34;,
               significance: str=&#34;numeric&#34;,
               significance_ranges: Dict[str, float]={&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10},
               swarm: bool=False,
               xorder: list=[],
               equal_var: bool=False,**kwargs):
    &#34;&#34;&#34;
    Draw a boxplot with a statistical test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x,y: str
        names of variables in data
    pairs: list, optional
        Category pairs for the statistical test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    test: str, optional
        Method name for the statistical test. Defalt: ttest_ind
        Available methods: [&#34;ttest_ind&#34;,
                            &#34;ttest_rel&#34;,
                            &#34;kruskal&#34;,
                            &#34;mannwhitneyu&#34;,
                            &#34;wilcoxon&#34;,
                            &#34;brunnermunzel&#34;,
                            &#34;median_test&#34;]
    alternative: str [&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;], optional
        Defines the alternative hypothesis. Defalt: &#34;two-sided&#34;
    
    show : bool, optional
        Whether or not to show the figure.
    significance: str [&#39;numeric&#39;, &#39;symbol&#39;], optional
        How to show the significance. &#39;numeric&#39; will show -log10(p values) in the plot and 
        &#39;symbol&#39; will represent significance as asterisks.
    significance_ranges: dict, optional 
        thresholds of -log10(p values) that each asterisk number represents. Ignored when  significance=&#34;numeric&#34;.
        example: {&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10}
    swarm: bool, optional
        Whether or not to superpose a swarm plot. Not recommended if the sample size is too large.
    xorder: list, optional
        The order of x axis labels
    equal_var: bool, optional
        Related to ttest_ind method. The default is True, which will produce a p value equal to t-test in R.
    kwargs: any options accepted by scipy statistical test functions
    
     
    Returns
    -------
    dict(&#34;p values&#34;:pvalues,&#34;axes&#34;:ax)
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    tests=[&#34;ttest_ind&#34;,&#34;ttest_rel&#34;,&#34;kruskal&#34;,&#34;mannwhitneyu&#34;,&#34;wilcoxon&#34;,&#34;brunnermunzel&#34;,&#34;median_test&#34;]
    
    import scipy.stats as stats
    if len(xorder)==0:
        xorder=sorted(list(set(df[x])))
    pvals=[]
    for p1,p2 in pairs:
        
        statstest=getattr(stats, test)
        if test==&#34;wilcoxon&#34; or test==&#34;ttest_rel&#34;:
            _, pval,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;median_test&#34;:
            _, pval,_,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;ttest_ind&#34;:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,equal_var=equal_var,**kwargs)
        
        else:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        
        p1ind=xorder.index(p1)
        p2ind=xorder.index(p2)
        if pval==0:
            pval=np.inf
        else:
            pval=-np.log10(pval)
        pvals.append([np.abs(p2ind-p1ind), np.amin([p2ind, p1ind]),np.amax([p2ind, p1ind]), pval])
    pvals = sorted(pvals, key = lambda x: (x[0], x[1]))
        
    fig, ax=plt.subplots()
    sns.violinplot(data=df, x=x,y=y,inner=&#34;quartile&#34;)
    if swarm==True:
        sns.swarmplot(data=df, x=x,y=y,color=&#34;black&#34;,alpha=0.5)
    ymax=np.amax(df[y])
    newpvals={}
    for i, pval in enumerate(pvals):
        plt.plot([pval[1],pval[2]], [ymax*(1.05+i*0.05),ymax*(1.05+i*0.05)], color=&#34;black&#34;)
        p=np.round(pval[-1],2)
        
        newpvals[xorder[pval[1]]+&#34;_&#34;+xorder[pval[2]]]=p
        if significance==&#34;numeric&#34;:
            annotate=&#34;-log10(p)=&#34;+str(p)
        elif significance==&#34;symbol&#34;:
            keys=sorted(significance_ranges.keys())
            annotate=&#34;NA&#34;
            for j in range(len(keys)):
                if j==0:
                    if p &lt;= significance_ranges[keys[j]]:
                        annotate=&#34;&#34;
                        break
                else:
                    if significance_ranges[keys[j-1]] &lt; p &lt;=significance_ranges[keys[j]]:
                        annotate=keys[i]
                        break
            if annotate==&#34;NA&#34;:
                annotate=keys[-1]
        plt.text((pval[1]+pval[2])/2, ymax*(1.055+i*0.05), annotate)
    if significance==&#34;symbol&#34;:
        ax.annotate(&#34;\n&#34;.join([&#34;{}: p &lt; {:.2E}&#34;.format(k, 10**(-significance_ranges[k])) for k in keys]),
            xy=(0.9,0.9), xycoords=&#39;axes fraction&#39;,
            textcoords=&#39;offset points&#39;,
            size=12,
            bbox=dict(boxstyle=&#34;round&#34;, fc=(0.9, 0.9, 0.9), ec=&#34;none&#34;))
        plt.subplots_adjust(right=0.850)
    
    return {&#34;p values&#34;:newpvals,&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.volcanoplot"><code class="name flex">
<span>def <span class="ident">volcanoplot</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volcanoplot():
    pass</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="omniplot" href="index.html">omniplot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="omniplot.plot.clusterplot" href="#omniplot.plot.clusterplot">clusterplot</a></code></li>
<li><code><a title="omniplot.plot.complex_clustermap" href="#omniplot.plot.complex_clustermap">complex_clustermap</a></code></li>
<li><code><a title="omniplot.plot.correlation" href="#omniplot.plot.correlation">correlation</a></code></li>
<li><code><a title="omniplot.plot.decomplot" href="#omniplot.plot.decomplot">decomplot</a></code></li>
<li><code><a title="omniplot.plot.dotplot" href="#omniplot.plot.dotplot">dotplot</a></code></li>
<li><code><a title="omniplot.plot.manifoldplot" href="#omniplot.plot.manifoldplot">manifoldplot</a></code></li>
<li><code><a title="omniplot.plot.nice_piechart" href="#omniplot.plot.nice_piechart">nice_piechart</a></code></li>
<li><code><a title="omniplot.plot.nice_piechart_num" href="#omniplot.plot.nice_piechart_num">nice_piechart_num</a></code></li>
<li><code><a title="omniplot.plot.pie_scatter" href="#omniplot.plot.pie_scatter">pie_scatter</a></code></li>
<li><code><a title="omniplot.plot.radialtree" href="#omniplot.plot.radialtree">radialtree</a></code></li>
<li><code><a title="omniplot.plot.regression_single" href="#omniplot.plot.regression_single">regression_single</a></code></li>
<li><code><a title="omniplot.plot.stacked_barplot" href="#omniplot.plot.stacked_barplot">stacked_barplot</a></code></li>
<li><code><a title="omniplot.plot.stackedlines" href="#omniplot.plot.stackedlines">stackedlines</a></code></li>
<li><code><a title="omniplot.plot.triangle_heatmap" href="#omniplot.plot.triangle_heatmap">triangle_heatmap</a></code></li>
<li><code><a title="omniplot.plot.violinplot" href="#omniplot.plot.violinplot">violinplot</a></code></li>
<li><code><a title="omniplot.plot.volcanoplot" href="#omniplot.plot.volcanoplot">volcanoplot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>