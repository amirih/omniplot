<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>omniplot.plot API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>omniplot.plot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Union, Optional, Dict, List
import matplotlib.collections as mc
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd
from matplotlib import cm
from matplotlib.lines import Line2D
from scipy.cluster.hierarchy import leaves_list
from scipy.cluster import hierarchy
from collections import defaultdict
import matplotlib.colors
from natsort import natsort_keygen
from matplotlib.patches import Rectangle
import scipy.cluster.hierarchy as sch
import fastcluster as fcl

import sys 
import matplotlib as mpl
from sklearn.cluster import KMeans, DBSCAN
from sklearn.metrics import silhouette_score
from scipy.spatial.distance import pdist, squareform
from sklearn.decomposition import PCA, NMF, LatentDirichletAllocation
from scipy.stats import fisher_exact
from scipy.stats import zscore
from itertools import combinations
import os
#script_dir = os.path.dirname( __file__ )
#sys.path.append( script_dir )
from omniplot.utils import * #
import scipy.stats as stats
from joblib import Parallel, delayed
from omniplot.chipseq_utils import _calc_pearson
import itertools as it
from omniplot.scatter import *
from omniplot.proportion import *
colormap_list: list=[&#34;nipy_spectral&#34;, &#34;terrain&#34;,&#34;tab20b&#34;,&#34;tab20c&#34;,&#34;gist_rainbow&#34;,&#34;hsv&#34;,&#34;CMRmap&#34;,&#34;coolwarm&#34;,&#34;gnuplot&#34;,&#34;gist_stern&#34;,&#34;brg&#34;,&#34;rainbow&#34;,&#34;jet&#34;]
hatch_list: list = [&#39;//&#39;, &#39;\\\\&#39;, &#39;||&#39;, &#39;--&#39;, &#39;++&#39;, &#39;xx&#39;, &#39;oo&#39;, &#39;OO&#39;, &#39;..&#39;, &#39;**&#39;,&#39;/o&#39;, &#39;\\|&#39;, &#39;|*&#39;, &#39;-\\&#39;, &#39;+o&#39;, &#39;x*&#39;, &#39;o-&#39;, &#39;O|&#39;, &#39;O.&#39;, &#39;*-&#39;]
maker_list: list=[&#39;.&#39;, &#39;_&#39; , &#39;+&#39;,&#39;|&#39;, &#39;x&#39;, &#39;v&#39;, &#39;^&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;s&#39;, &#39;p&#39;, &#39;*&#39;, &#39;h&#39;, &#39;D&#39;, &#39;d&#39;, &#39;P&#39;, &#39;X&#39;,&#39;o&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;,&#39;|&#39;, &#39;_&#39;]

plt.rcParams[&#39;font.family&#39;]= &#39;sans-serif&#39;
plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Arial&#39;]
plt.rcParams[&#39;svg.fonttype&#39;] = &#39;none&#39;
sns.set_theme(font=&#34;Arial&#34;)




def radialtree(df: pd.DataFrame,
               n_clusters: int=3,
               x: str=&#34;&#34;,
               variables: List=[],
               category: Union[str, List[str]]=[],
               ztransform: bool=True,
               save: str=&#34;&#34;,
               distance_method=&#34;euclidean&#34;,
               tree_method=&#34;ward&#34;,
               title: str=&#34;&#34;,
               y: list=[],
               **kwargs) -&gt; Dict:
    &#34;&#34;&#34;
    Drawing a radial dendrogram with color labels.
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide format data. 
        
        
    n_clusters: int, optional (default: 3)
        Approximate number of clusters to produce
    x: str, optional
        the name of columns containing sample names. If not provided, the index will be considered sample names.
    variables: list, optional
        the name of columns containing variables to calculate the distances between samples
    category: str or list of str
        the column name of a category that is going to presented as colors around the dendrogram.
    ztransform: bool=True,
    save: str=&#34;&#34;,
    distance_method=&#34;euclidean&#34;,
    tree_method=&#34;ward&#34;,
    
    
    show : bool
        Whether or not to show the figure.
    fontsize : float
        A float to specify the font size
    figsize : [x, y] array-like
        1D array-like of floats to specify the figure size
    palette : string
        Matlab colormap name.
    Returns
    -------
    dict: {&#34;axes&#34;:ax, &#34;clusters&#34;: clusters}

    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if len(y)!=0:
        variables=y
    
    if x !=&#34;&#34;:
        _labels=df[x]
        df=df.drop(x, axis=1)
    else:
        _labels=df.index

    X, category=_separate_data(df, variables=variables, category=category)
    category_df=df[category]
    # if len(variables)!=0 and len(category)!=0:
    #     if type(category)==str:
    #         category=[category]
    #     category_df=df[category]
    #     df=df[variables]
    #     X = df.values
    #     #print(X)
    #     assert X.dtype==float, f&#34;{x} columns must contain only float values.&#34;
    #
    #
    # elif len(category) !=0:
    #     if type(category)==str:
    #         category=[category]
    #     category_df=df[category]
    #     df=df.drop(category, axis=1)
    #     X = df.values
    #     #print(X)
    #     assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
    #
    # else:    
    #     X = df.values
    #     assert X.dtype==float, &#34;data must contain only float values.&#34;
    
    
    
    if ztransform==True:
        X=zscore(X, axis=0)
    D=squareform(pdist(X,metric=distance_method))
    Y = sch.linkage(D, method=tree_method)
    
    Z = sch.dendrogram(Y,labels=_labels,no_plot=True)
    t=_dendrogram_threshold(Z, n_clusters)
    Z=sch.dendrogram(Y,
                        labels = _labels,
                        color_threshold=t,no_plot=True)
    sample_classes={k: list(category_df[k]) for k in category_df.columns}
    ax=_radialtree2(Z, sample_classes=sample_classes,addlabels=False, **kwargs)
    if title !=&#34;&#34;:
        ax.set_title(title)
    _save(save, &#34;radialtree&#34;)
    clusters = _get_cluster_classes(Z)
    return {&#34;axes&#34;:ax, &#34;clusters&#34;:clusters}


def correlation(df: pd.DataFrame, 
                category: Union[str, list]=[],
                variables: List=[],
                method=&#34;pearson&#34;,
                palette: str=&#34;coolwarm&#34;,
                figsize=[6,6],
                show_values=False,
                clustermap_param:dict={},
                ztransform: bool=True,
                xticklabels =False,
                yticklabels=False,
                title: str=&#34;&#34;,)-&gt;Dict:
    &#34;&#34;&#34;
    Drawing a heatmap with correlations or distances between observations 
    
    Parameters
    ----------
    df : pandas DataFrame
        
    variables: List, optional
        the names of values to calculate correlations  
    
    category: str or list, optional
        the names of categorical values to display as color labels
    mthod: str
        method for correlation/distance calculation. Defalt: &#34;pearson&#34;
        
    palette : str
        A colormap name
    show_values: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    clustermap_param : dict, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
    ztransform : bool, optional
        Whether to transform values to z-score
    xticklabels, yticklabels : bool
        Whether to show the label names in the heatmap
    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    original_index=df.index
    X, category=_separate_data(df, variables=variables, category=category)
    # if len(category) !=0:
    #
    #     if type(category)==str:
    #         category=[category]
    #     #df=df.drop(category, axis=1)
    #     valnames=list(set(df.columns) -set(category)) 
    #     X = df[valnames].values
    #     assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
    #
    # else:    
    #     X = df.values
    #     assert X.dtype==float, &#34;data must contain only float values.&#34;
    if ztransform==True:
        X=zscore(X, axis=0)
    if method==&#34;pearson&#34;:
        dmat=Parallel(n_jobs=-1)(delayed(_calc_pearson)(ind, X) for ind in list(it.combinations(range(X.shape[0]), 2)))
        dmat=np.array(dmat)
        dmat=squareform(dmat)
        print(dmat)
        dmat+=np.identity(dmat.shape[0])
    else:
        dmat=squareform(pdist(X, method))
    if method==&#34;pearson&#34;:
            ctitle=&#34;Pearson correlation&#34;
    else:
        ctitle=method+&#34; distance&#34;    
        
        
    if len(category) &gt;0:
        dfm=pd.DataFrame(data=dmat)
        colnames=dfm.columns
        for cat in category:
            dfm[cat]=df[cat].values
        res=complex_clustermap(dfm,
                               heatmap_col=colnames, 
                               row_colors=category,
                               ztranform=False,
                               xticklabels=xticklabels,
                               yticklabels=yticklabels,
                               figsize=figsize,
                               ctitle=ctitle )
        return res
    else:
        
        g=sns.clustermap(data=dmat,
                         xticklabels=xticklabels,
                         yticklabels=yticklabels,
                   method=&#34;ward&#34;, 
                   cmap=palette,
                   col_cluster=True,
                   row_cluster=True,
                   figsize=figsize,
                   rasterized=True,
                    #cbar_kws={&#34;label&#34;:&#34;Pearson correlation&#34;}, 
                   annot=show_values,
                   **clustermap_param)
        
        g.cax.set_ylabel(ctitle, rotation=-90,va=&#34;bottom&#34;)
        plt.setp(g.ax_heatmap.get_yticklabels(), rotation=0)  # For y axis
        plt.setp(g.ax_heatmap.get_xticklabels(), rotation=90) # For x axis
        return {&#34;grid&#34;:g}

def triangle_heatmap(df, 
                     grid_pos: list=[],
                     grid_labels: list=[],
                     show: bool=False, 
                     save: str=&#34;&#34;,title: str=&#34;&#34;)-&gt; dict:
    
    &#34;&#34;&#34;
    Creating a heatmap with 45 degree rotation.
    
    Parameters
    ----------
    df : pandas DataFrame
    grid_pos: list
        the column name of a category that is going to be placed in the row of the dotplot
    grid_labels: list
        the column name of a category that is going to be placed in the column of the dotplot
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    dict {&#34;axes&#34;: ax}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    
    genes=df.index
    fig, ax = plt.subplots(figsize=[8,6])
    dmat=df.to_numpy()
    D = dmat
    N = dmat.shape[0]
    a=np.tril(np.zeros([N,N])-1000000, k=-1)
    # Get the lower triangle of the matrix. 
    C = np.triu(D)+a
    
    # Mask the upper triangle.
    C = np.ma.masked_array(C, C == -1000000)
    # Set the diagonal to zero.
    for i in range(N):
        C[i, i] = 0
    
    # Transformation matrix for rotating the heatmap.
    A = np.array([(y, x) for x in range(N, -1, -1) for y in range(N + 1)])
    t = np.array([[2**(-0.5), 2**(-0.5)], [-2**(-0.5), 2**(-0.5)]])
    A = np.dot(A, t)
    #t_ = np.array([[2**(-0.5), -2**(-0.5)], [2**(-0.5), 2**(-0.5)]])
    
    # -1.0 correlation is blue, 0.0 is white, 1.0 is red.
    cmap = plt.cm.Reds
    #norm = mp.colors.BoundaryNorm(np.linspace(0, 10, 14), cmap.N)
    
    # This MUST be before the call to pl.pcolormesh() to align properly.
    ax.set_xticks([])
    ax.set_yticks([])
    
    X = A[:, 1].reshape(N + 1, N + 1)
    Y = A[:, 0].reshape(N + 1, N + 1)
    caxes = plt.pcolormesh(X, Y, np.flipud(C), axes=ax, cmap=cmap, rasterized=True)
    x1s=[0]
    if len(grid_pos)&gt;0:
        for i,  grid in enumerate(grid_pos):
            x0=(grid)/(2**(0.5))
            x1=(grid)*(2**0.5)
            y0=(grid)/(2**(0.5))
            y1=0
            ax.plot([x0, x1], [y0, y1],color=&#39;gray&#39;, linewidth=1)
            ax.plot([(grid)*(2**0.5), (grid)*(2**0.5)+(N-grid)/(2**(0.5))], [0, (N-grid)/(2**(0.5))], color=&#39;gray&#39;, linewidth=1)
            x1s.append(x1)
    x1s.append(N*2**0.5)
    
    

    if len(genes) &gt;0: 
        leng=0
        for i, g in enumerate(genes):
            #ax.plot([(i+0.5)*(2**0.5), (i+0.5)*(2**0.5)], [-2**0.5, -(N/10)*2**0.5/2],color=&#39;b&#39;, linewidth=0.5)
            ax.text((i+0.5)*(2**0.5), -(N/10)*2**0.5/2*1.01, g, rotation=90,ha=&#39;center&#39;, va=&#39;top&#39;, fontsize=&#34;small&#34;)
            leng+=len(g)
        leng=leng/len(genes)
    else:
        leng=0
    spacing=(N/10)*leng*0.4
    
    
    rect=Rectangle([0, -spacing],N*(2**0.5), spacing, color=&#39;whitesmoke&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    
    rect=Rectangle([0, -(N/10)*2**0.5/2],N*(2**0.5), (N/10)*2**0.5/2, color=&#39;dimgray&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    if len(grid_labels)&gt;0:
        for i in range(len(x1s)-1):
            if i%2==1:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;silver&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            else:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;lavender&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            x=(x1s[i]+x1s[i+1])/2
            ax.text(x,-(N/10)*2**0.5/4, grid_labels[i], rotation=90,ha=&#39;center&#39;, va=&#39;center&#39;, color=&#34;w&#34;)
    

    
    
    cb = plt.colorbar(caxes, ax=ax, shrink=0.75)
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;bottom&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_visible(False)
    if save!=&#34;&#34;:
        if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
            plt.savefig(save)
        else:
            plt.savefig(save+&#34;_complexheatmap.pdf&#34;)
    if show:
        plt.show()
    return {&#34;axes&#34;: ax}
    
    
def complex_clustermap(df: pd.DataFrame,
                       variables: list=[],
                       dfcol: Optional[pd.DataFrame]=None, 
                       row_colors: list=[],
                       col_colors: list=[],
                       row_plot: list=[],
                       col_plot: list=[],
                       row_scatter: list=[],
                       col_scatter: list=[],
                       row_bar: list=[],
                       col_bar: list=[],
                       ctitle: str=&#34;&#34;,
                       approx_clusternum: int=10,
                       approx_clusternum_col: int=3,
                       color_var: int=0,
                       merginalsum: bool=False,
                       show: bool=False,
                       method: str=&#34;ward&#34;,
                       return_col_cluster: bool=True,
                       ztranform: bool=True,
                       xticklabels: bool=True, 
                       yticklabels: bool=False,
                       show_plot_labels: bool=False,
                       figsize: list=[],
                       title: str=&#34;&#34;,
                       save: str=&#34;&#34;,
                       heatmap_palette: str=&#34;coolwarm&#34;,
                       heatmap_col: list=[],
                       **kwargs):
    &#34;&#34;&#34;
    Drawing a clustered heatmap with merginal plots.
    
    Parameters
    ----------
    df : pandas DataFrame
    variables : list
        the column names of variables for heatmap
    row_colors, col_colors: list, optional
        the column names of categorical values to be plotted as color labels. for the col_colors to be plotted, dfcol options will be needed.
    row_plot, col_plot : list, optional
        The column names for the values to be plotted as lines.
    row_scatter, col_scatter: list, optional
        The column names for the values to be plotted as points.
    row_bar, col_bar: list, optional
        The column names for the values to be plotted as bars.
    approx_clusternum : int, optional
        The approximate number of row clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.    
    approx_clusternum_col : int, optional
        The approximate number of column clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.

    color_var : int, optional
        The number of potential colors in dendrograms. If some clusters in the dendrogram share a same color (because the number of clusters is too many), 
        give this option may solve the problem. 
    merginalsum : bool, optional
        Whether or not to draw bar plots for merginal distribution.
    show : bool, optional
        Whether or not to show the figure.
    method : string, optional (default: &#34;ward&#34;)
        Method for hierarchical clustering. [&#34;ward&#34;, &#34;single&#34;, 
    return_col_cluster : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    
    ztranform: bool, optional (default: True)
    xticklabels: bool, optional (default: True)
        Whether or not to show xtick labels
    yticklabels: bool, optional (default: False)
        Whether or not to show ytick labels
    show_plot_labels: bool, optional (default: False)
        Whether or not to show plot labels.
    figsize: list, optional
        
    title: str, optional
    save: str, optional
    
    heatmap_col: list, optional
        The same as the &#34;variables&#34; option. Will be deprecated.
    Returns
    -------
        dict: {&#34;row_clusters&#34;:pd.DataFrame,&#34;col_clusters&#34;:pd.DataFrame, &#34;grid&#34;:g}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;#print(kwargs)
    rnum, cnum=df.shape
    if len(heatmap_col)==0 and len(variables)==0:
        raise Exception(&#34;Please specify the variables option&#34;)
    if len(heatmap_col)!=0:
        variables=heatmap_col
    cnum=len(variables)
    if len(figsize)==0:
        xsize=np.amin([2*cnum, 20])
        figsize=[xsize,10]
    scatterpointsize=5
    sns.set(font_scale=1)
    if ztranform==True:
        df[variables]=df[variables].apply(zscore)
        if ctitle ==&#34;&#34;:
            ctitle=&#34;zscore&#34;
    
    if len(col_plot)!=0 or len(col_scatter)!=0 or len(col_bar)!=0:
        if dfcol==None:
            raise Exception(&#34;if you want to plot along the x axis, you need provide dfcol option containing values to plot.&#34;)
    
    totalrowplot=0
    if merginalsum==True:
        totalrowplot+=1
    totalrowplot+=len(row_plot)
    totalrowplot+=len(row_colors)
    totalrowplot+=len(row_scatter)
    totalrowplot+=len(row_bar)
    totalcolplot=0
    if merginalsum==True:
        totalcolplot+=1
    totalcolplot+=len(col_plot) 
    totalcolplot+=len(col_colors)
    totalcolplot+=len(col_scatter)
    totalcolplot+=len(col_bar)
    _row_color_legend={}
    _col_color_legend={}
    colormap_index=0
    if totalrowplot + totalcolplot &gt;0:
        rowplotcount=0
        colplotcount=0
        _row_colors=[]
        _row_colors_title=[]
        _col_colors=[]
        _col_colors_title=[]
        
        if merginalsum:
            _row_colors.append(np.ones([rnum, 4]))
            _row_colors_title.append(&#34;Sum&#34;)
            _col_colors.append(np.ones([cnum, 4]))
            _col_colors_title.append(&#34;Sum&#34;)
        #print(np.shape(_col_colors))
        if len(row_colors)&gt;0:
            for k in row_colors:
                
                u=np.unique(df[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _row_color_legend[k]=lut
                colormap_index+=1
                _row_colors.append([lut[cat] for cat in df[k]])
                _row_colors_title.append(k)
                
        if len(col_colors)&gt;0:
            for k in col_colors:
                u=np.unique(dfcol[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _col_color_legend[k]=lut
                colormap_index+=1
                _col_colors.append([lut[cat] for cat in dfcol[k]])
                _col_colors_title.append(k)
        
        if len(row_plot)&gt;0:
            for k in row_plot:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_plot)&gt;0:
            for k in col_plot:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k)        
        
        if len(row_scatter)&gt;0:
            for k in row_scatter:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_scatter)&gt;0:
            for k in col_scatter:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(row_bar)&gt;0:
            for k in row_bar:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_bar)&gt;0:
            for k in col_bar:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(_row_colors) &gt;0 and len(_col_colors) &gt;0:
            #print(np.shape(_col_colors))
            g=sns.clustermap(df[variables],col_colors=_col_colors, 
                             row_colors=_row_colors,
                             method=method,xticklabels=xticklabels, yticklabels=yticklabels,
                             figsize=figsize,dendrogram_ratio=0.1,
                             cbar_kws=dict(ticks=[0, 0.50, 1],cmap=heatmap_palette, orientation=&#39;horizontal&#39;),
                             **kwargs)
            
            g.ax_col_colors.invert_yaxis()
            g.ax_row_colors.invert_xaxis()
        elif len(_col_colors) &gt;0:
           
            g=sns.clustermap(df[variables],
                             col_colors=_col_colors,
                             method=method,
                             xticklabels=xticklabels, 
                             yticklabels=yticklabels,
                             dendrogram_ratio=0.1,
                             cbar_kws=dict(ticks=[0, 0.50, 1],cmap=heatmap_palette, orientation=&#39;horizontal&#39;),
                             figsize=figsize,**kwargs)
            g.ax_col_colors.invert_yaxis()
        elif len(_row_colors) &gt;0:
            g=sns.clustermap(df[variables],
                             row_colors=_row_colors,
                             method=method,
                             xticklabels=xticklabels,
                             cmap=heatmap_palette, 
                             yticklabels=yticklabels,
                             dendrogram_ratio=0.1,
                             figsize=figsize,
                             cbar_kws=dict(orientation=&#39;horizontal&#39;),
                             **kwargs)
            g.ax_row_colors.invert_xaxis()

        
        #for spine in g.ax_cbar.spines:
        #    g.ax_cbar.spines[spine].set_linewidth(2)

        
        rowplotcount=0
        colplotcount=0
        tickpos=0.9
        row_labels=[]
        col_labels=[]
        row_ticks=[]
        col_ticks=[]
        if merginalsum:
            mat=df[variables].to_numpy()
            r=np.sum(mat, axis=1)
            row_labels.append(0)
            row_labels.append(np.amax(r))
            row_ticks.append(rowplotcount)
            row_ticks.append(rowplotcount+tickpos)
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            if row_cluster==True:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r[leaves_list(g.dendrogram_row.linkage)]/np.amax(r),height=1)
                
            else:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r/np.amax(r),height=1)
            #g.ax_row_colors.set_xticks([0,1],labels=[0,np.amax(r)])
            c=np.sum(mat, axis=0)
            #print(mat, c)
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            if col_cluster==True:
            
            #print(leaves_list(g.dendrogram_col.linkage))
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c[leaves_list(g.dendrogram_col.linkage)]/np.amax(c),width=1)
            else:
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c/np.amax(c),width=1)
            #g.ax_col_colors.set_yticks([0,1],labels=[0,np.amax(c)])
            col_labels.append(0)
            col_labels.append(np.amax(c))
            col_ticks.append(colplotcount)
            col_ticks.append(colplotcount+tickpos)
            rowplotcount=1
            colplotcount=1
        rowplotcount+=len(row_colors)
        colplotcount+=len(col_colors)
        if len(row_plot)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_plot):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)

                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
                else:
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
            
                rowplotcount+=1
                
        if len(col_plot)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_plot):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount)
                else:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r+colplotcount)
                
                colplotcount+=1
        if len(row_scatter)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_scatter):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
                else:
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
            
                rowplotcount+=1
        if len(col_scatter)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_scatter):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount,s=scatterpointsize)
                else:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r+colplotcount,s=scatterpointsize)
                
                colplotcount+=1
        
        if len(row_bar)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_bar):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                    
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    g.ax_row_colors.barh(y=np.arange(r.shape[0])+0.5, width=r[leaves_list(g.dendrogram_row.linkage)],left=[rowplotcount]*r.shape[0])
                else:
                    g.ax_row_colors.barh(r, np.arange(r.shape[0])+0.5,left=[rowplotcount]*r.shape[0])
            
                rowplotcount+=1
        if len(col_bar)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_bar):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)

                if col_cluster==True:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]/(np.amax(r)*1.1)+colplotcount)
                else:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r/(np.amax(r)*1.1)+colplotcount)
                
                colplotcount+=1
        if g.ax_row_colors!=None:
            
            g.ax_row_colors.set_xticks(np.arange(len(_row_colors_title))+0.5)
            g.ax_row_colors.set_xticklabels(_row_colors_title, rotation=90)
        if g.ax_col_colors!=None:
            colax_otherside = g.ax_col_colors.twinx()
            colax_otherside.set_yticks(0.5*(np.arange(len(_col_colors_title))+0.5),labels=_col_colors_title)
            colax_otherside.grid(False)
        if g.ax_col_dendrogram!=None:
            col = g.ax_col_dendrogram.get_position()
            g.ax_col_dendrogram.set_position([col.x0, col.y0, col.width*0.5, col.height*0.5])
        
        if show_plot_labels==True:
            
            rowax_otherside = g.ax_row_colors.twiny()
            rowax_otherside.invert_xaxis()
            rowax_otherside.grid(False)
            rowax_otherside.set_xticks(row_ticks, labels=np.round(row_labels,2), rotation=90, fontsize=8)
            col_ticks=np.array(col_ticks)
            g.ax_col_colors.set_yticks(col_ticks, labels=np.round(col_labels,2), fontsize=8)
        
        legend_num=0
        for _title, colorlut in _row_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))

            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=_title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        for _title, colorlut in _col_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))

            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=_title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        
    else:
        g=sns.clustermap(df,method=method,cbar_kws={&#34;label&#34;:ctitle},**kwargs)
    if color_var&gt;0:
        cmap = cm.nipy_spectral(np.linspace(0, 1, color_var))
    else:
        cmap = cm.nipy_spectral(np.linspace(0, 1, approx_clusternum+5))
    hierarchy.set_link_color_palette([mpl.colors.rgb2hex(rgb[:3]) for rgb in cmap])
    
    &#34;&#34;&#34;coloring the row dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    if g.dendrogram_row != None:
        t=_dendrogram_threshold(g.dendrogram_row.dendrogram,approx_clusternum)
        # lbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,:2]
        # rbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,2:]
        # thre=np.linspace(0, np.amax(g.dendrogram_row.dendrogram[&#34;dcoord&#34;]), 100)[::-1]
        # for t in thre:
        #     #print(np.sum(lbranches[:,1]&gt;t),np.sum(rbranches[:,0]&gt;t),np.sum(lbranches[:,0]&gt;t),np.sum(rbranches[:,1]&gt;t))
        #     crossbranches=np.sum(lbranches[:,1]&gt;t)+np.sum(rbranches[:,0]&gt;t)-np.sum(lbranches[:,0]&gt;t)-np.sum(rbranches[:,1]&gt;t)
        #     #print(crossbranches)
        #
        #     if crossbranches&gt;approx_clusternum:
        #         break
        
        den=hierarchy.dendrogram(g.dendrogram_row.linkage,
                                                 labels = g.data.index,
                                                 color_threshold=t,ax=g.ax_row_dendrogram,
                            orientation=&#34;left&#34;)  
        g.ax_row_dendrogram.invert_yaxis()
        clusters = _get_cluster_classes(den)
        cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        keys=list(clusters.keys())
        ckeys={}
        i=1
        for k in keys:
            if k==&#34;C0&#34;:
                ckeys[k]=&#34;C0&#34;
            else:
                ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in clusters.items():
            _c=ckeys[c]
            for _v in v:
                cdata[&#34;Cluster&#34;].append(_c)
                cdata[&#34;Index&#34;].append(_v)
                cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
        &#34;&#34;&#34;Setting the row dendrogram ends here&#34;&#34;&#34;
    
    
    &#34;&#34;&#34;coloring the col dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    col_cdata=None
    if g.dendrogram_col != None:
        t=_dendrogram_threshold(g.dendrogram_col.dendrogram,approx_clusternum_col)
        den=hierarchy.dendrogram(g.dendrogram_col.linkage,
                                                 labels = g.data.columns,
                                                 color_threshold=t,ax=g.ax_col_dendrogram,
                            orientation=&#34;top&#34;)  
        #g.ax_col_dendrogram.invert_yaxis()
        col_clusters = _get_cluster_classes(den)
        col_cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        col_keys=list(col_clusters.keys())
        col_ckeys={}
        i=1
        for k in col_keys:
            if k==&#34;C0&#34;:
                col_ckeys[k]=&#34;C0&#34;
            else:
                col_ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in col_clusters.items():
            _c=col_ckeys[c]
            for _v in v:
                col_cdata[&#34;Cluster&#34;].append(_c)
                col_cdata[&#34;Index&#34;].append(_v)
                col_cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
    &#34;&#34;&#34;Setting the col dendrogram ends here&#34;&#34;&#34;
    
    
    g.fig.subplots_adjust(bottom=0.175, right=0.70)
    
    x0, _y0, _w, _h = g.cbar_pos
    
    g.ax_cbar.set_title(ctitle)
    #g.ax_cbar.tick_params(axis=&#39;x&#39;, length=5)
    g.ax_cbar.set_position(pos=[0.80, 0.3, 0.1, 0.02], which=&#34;both&#34;)
    if title !=&#34;&#34;:
        g.fig.suptitle(title, va=&#34;bottom&#34;)
    plt.setp(g.ax_heatmap.xaxis.get_majorticklabels(), rotation=90)
   
    _save(save, &#34;complex_clustermap&#34;)
    if show:
        plt.show()
    return {&#34;data&#34;:g.data2d,&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:pd.DataFrame(col_cdata), &#34;grid&#34;:g}
 

def dotplot(df: pd.DataFrame,
            y: str=&#34;&#34;,
            x: str=&#34;&#34;,
            dfc=pd.DataFrame(),
            scaling: float=10,
            color_val: str=&#34;&#34;,
            size_val: str=&#34;&#34;,
            highlight: str=&#34;&#34;,
            color_title: str=&#34;&#34;,
            size_title: str=&#34;&#34;,
            figsize: list=[],
            save: str=&#34;&#34;,
            threshold: float=-np.log10(0.05),
            row_clustering: bool=True,
            xtickrotation: float=90,
            column_order: list=[],
            colorpalette=&#34;coolwarm&#34;,
            show: bool=False,
            title: str=&#34;&#34;,
            row: str=&#34;&#34;,
            col: str=&#34;&#34;,
            ) -&gt; Dict[str, plt.Axes]:
    &#34;&#34;&#34;
    Drawing a dotplot that can represent two different variables as dot sizes and colors on a regular grid.
    This function is assumed to plot GO enrichment analysis with multiple gene sets.
    
    Parameters
    ----------
    df : pandas DataFrame
        dataframe containing two categories and corresponding values (such as p values and odds ratio).
        e.g.:
            Cluster                   Condensate      pval      odds       FDR
        54       C1                   Cajal body -0.000000  0.000000 -0.000000
        55       C1            *DNA repair focus -0.000000  0.000000 -0.000000
        56       C1  *DNA replication condensate -0.000000  0.000000 -0.000000
        57       C1                       P-body -0.000000  0.000000 -0.000000
        58       C1                     PML body -0.000000  0.000000 -0.000000
    row: string
        the column name of a category that is going to be placed in the row of the dotplot
    col: string
        the column name of a category that is going to be placed in the column of the dotplot
    color_val : string
        The column name for the values represented as dot colors.
    size_val : string
        The column name for the values represented as dot sizes. 
    scaling: float
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    highlight : string
        A dictionary to set color labels to leaves. The key is the name of the color label. 
        The value is the list of RGB color codes, each corresponds to the color of a leaf. 
        e.g., {&#34;color1&#34;:[[1,0,0,1], ....]}   
    size_title : string
        The title for size values. If not set, &#34;size_val&#34; will be used.
    
    color_title : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    show : bool
        Whether or not to show the figure.
    Returns
    -------
    axes: dict {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if x !=&#34;&#34; and y!=&#34;&#34;:
        row=y
        col=x
    if size_val!=&#34;&#34;:
        _df=df.pivot_table(index=col,columns=row,values=size_val)
        if len(column_order)&gt;0:
            _df=_df.loc[column_order]
        else:
            _df=_df.sort_index(axis=0,key=natsort_keygen())
        _df=_df.fillna(0)
            
        if color_val!=&#34;&#34;:
            dfc=df.pivot_table(index=col,columns=row,values=color_val)
            if len(column_order)&gt;0:
                dfc=dfc.loc[column_order]
            else:
                dfc=dfc.sort_index(axis=0,key=natsort_keygen())
            dfc=dfc.fillna(0)
        if highlight !=&#34;&#34;:
            dfh=df.pivot_table(index=col,columns=row,values=highlight)
            if len(column_order)&gt;0:
                dfh=dfh.loc[column_order]
            else:
                dfh=dfh.sort_index(axis=0,key=natsort_keygen())
            dfh=dfh.fillna(0)
        
        if row_clustering==True:
            Y = fcl.linkage(_df.to_numpy().T, method=&#39;ward&#39;, metric=&#39;euclidean&#39;)
            Z1 = sch.dendrogram(Y,no_plot=True)
            idx1 = Z1[&#39;leaves&#39;]
            reorder=_df.columns[idx1]
            _df=_df[reorder]
            if color_val!=&#34;&#34;:
                dfc=dfc[reorder]
            if highlight !=&#34;&#34;:
                dfh=dfh[reorder]
        _x=_df.index
        _y=_df.columns
        mat=_df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    else:
        _x=df.index
        _y=df.columns
        mat=df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    #if minsize==0:
        #mat=mat+maxsize*0.01
    #minsize=np.amin(mat)
    
    maxsize=np.round(maxsize)
    middle0=np.round((minsize+maxsize)/3)
    middle1=np.round(2*(minsize+maxsize)/3)
    #plt.rcParams[&#34;figure.figsize&#34;] = [7.50, 3.50]
    #plt.rcParams[&#34;figure.autolayout&#34;] = True
    #x = np.arange(len(_x))
    #y = np.arange(len(_y))
    #X, Y = np.meshgrid(x, y)
    xy=[ [i,j] for i in range(len(_x)) for j in range(len(_y))]
    #num = 1000
    sizes = [mat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
    edge_colors=[]
    if highlight !=&#34;&#34;:
        hmat=dfh.to_numpy()
        hvals = [hmat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
       
        for s in hvals:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    else:
        for s in sizes:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    
    if len(dfc) !=0:
        viridis = cm.get_cmap(colorpalette, 12)
        cmat=dfc.to_numpy()
        cmat[cmat==np.inf]=0
        _cmat=cmat/np.amax(cmat)
        _colors = [viridis(_cmat[i,j]) for i in range(len(_x)) for j in range(len(_y))]
    else:
        _colors = [[0,1,0,1] for i in range(len(_x)) for j in range(len(_y))]
    #print(sizes)
    #xy = 10 * np.random.random((num, 2))
    #xy=XY
    #patches = [plt.Circle(center, size) for center, size in zip(xy, sizes)]
    
    #fig, ax = plt.subplots(ncols=2, gridspec_kw={&#39;width_ratios&#39;: [8, 2]})
    if len(figsize)==0:
        figsize=[mat.shape[0]*0.5+2,mat.shape[1]*0.5+1]
    
    fig = plt.figure(figsize=figsize)
    #fig.set_figheight(6)
    #fig.set_figwidth(6)
    
    ax1 = plt.subplot2grid(shape=(10, 6), loc=(0, 0), colspan=4, rowspan=10)
    ax2 = plt.subplot2grid(shape=(10, 6), loc=(1, 4), colspan=2, rowspan=4)
    ax3 = plt.subplot2grid(shape=(10, 6), loc=(6, 4), colspan=2, rowspan=1)
 
    collection = mc.CircleCollection(sizes,
                                     edgecolors=edge_colors, 
                                     offsets=xy, 
                                     transOffset=ax1.transData, 
                                     facecolors=_colors,
                                     linewidths=2)
    ax1.add_collection(collection)
    ax1.margins(0.1)
    ax1.set_xlim(-0.5,len(_x)-0.5)
    ax1.set_xticks(np.arange(len(_x)))
    ax1.set_xticklabels(_x,rotation=xtickrotation)
    ax1.set_yticks(np.arange(len(_y)))
    ax1.set_yticklabels(_y, rotation=0)
    if color_title==&#34;&#34;:
        color_title=color_val
    
    if len(dfc) !=0:
        norm = mpl.colors.Normalize(vmin=np.min(cmat), vmax=np.amax(cmat))
        
        cb1 = mpl.colorbar.ColorbarBase(ax3, cmap=viridis,
                                        norm=norm,
                                        orientation=&#39;horizontal&#39;)
        cb1.set_label(color_title)
    #ax[1]=fig.add_axes([1,0.3,0.1,1])
    
    lxy=[[0.5, i*0.5] for i in range(3)]
    collection2 = mc.CircleCollection([middle0*scaling,middle1*scaling, maxsize*scaling], 
                                      offsets=lxy, 
                                      transOffset=ax2.transData, 
                                      facecolors=&#39;lightgray&#39;,
                                      edgecolors=&#34;gray&#34;)
    ax2.add_collection(collection2)
    ax2.axis(&#39;off&#39;)
    ax2.margins(0.3)
    for text, (x, y) in zip([middle0,middle1, maxsize], lxy):
        ax2.text(x+0.01, y,str(text), ha=&#34;left&#34;,va=&#34;center&#34;,color=&#34;black&#34; )
    if size_title==&#34;&#34;:
        size_title=size_val
    ax2.text(0.5,-0.5, size_title,va=&#34;center&#34;,ha=&#34;center&#34;)
    #ax[1].set_yticks(np.arange(3))
    #ax[1].set_yticklabels([minsize,middle, maxsize], rotation=0)
    #plt.tight_layout()
    plt.subplots_adjust(left=0.3,bottom=0.2)
    #plt.tight_layout()
    if title !=&#34;&#34;:
        fig.suptitle(title)
    _save(save, &#34;dotplot&#34;)
    if show==True:
        plt.show()
    return {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}


def violinplot(df: pd.DataFrame, 
               x: str, 
               y: str,
               pairs: list=[], 
               test: str=&#34;ttest_ind&#34;,
               alternative: str=&#34;two-sided&#34;,
               significance: str=&#34;numeric&#34;,
               significance_ranges: Dict[str, float]={&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10},
               swarm: bool=False,
               xorder: list=[],
               equal_var: bool=False, 
               yunit: str=&#34;&#34;,
               title: str=&#34;&#34;,
               save: str=&#34;&#34;,
               ax: Optional[plt.Axes]=None,**kwargs):
    &#34;&#34;&#34;
    Draw a boxplot with a statistical test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x,y: str
        names of variables in data
    pairs: list, optional
        Category pairs for the statistical test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    test: str, optional
        Method name for the statistical test. Defalt: ttest_ind
        Available methods: [&#34;ttest_ind&#34;,
                            &#34;ttest_rel&#34;,
                            &#34;kruskal&#34;,
                            &#34;mannwhitneyu&#34;,
                            &#34;wilcoxon&#34;,
                            &#34;brunnermunzel&#34;,
                            &#34;median_test&#34;]
    alternative: str [&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;], optional
        Defines the alternative hypothesis. Defalt: &#34;two-sided&#34;
    
    show : bool, optional
        Whether or not to show the figure.
    significance: str [&#39;numeric&#39;, &#39;symbol&#39;], optional
        How to show the significance. &#39;numeric&#39; will show -log10(p values) in the plot and 
        &#39;symbol&#39; will represent significance as asterisks.
    significance_ranges: dict, optional 
        thresholds of -log10(p values) that each asterisk number represents. Ignored when  significance=&#34;numeric&#34;.
        example: {&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10}
    swarm: bool, optional
        Whether or not to superpose a swarm plot. Not recommended if the sample size is too large.
    xorder: list, optional
        The order of x axis labels
    equal_var: bool, optional
        Related to ttest_ind method. The default is True, which will produce a p value equal to t-test in R.
    kwargs: any options accepted by scipy statistical test functions
    
     
    Returns
    -------
    dict(&#34;p values&#34;:pvalues,&#34;axes&#34;:ax)
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    tests=[&#34;ttest_ind&#34;,&#34;ttest_rel&#34;,&#34;kruskal&#34;,&#34;mannwhitneyu&#34;,&#34;wilcoxon&#34;,&#34;brunnermunzel&#34;,&#34;median_test&#34;]
    if not test in tests:
        raise Exception(&#34;Available tests are &#34;+&#34;, &#34;.join(tests))
    import scipy.stats as stats
    if len(xorder)==0:
        xorder=sorted(list(set(df[x])))
    pvals=[]
    for p1,p2 in pairs:
        
        statstest=getattr(stats, test)
        if test==&#34;wilcoxon&#34; or test==&#34;ttest_rel&#34;:
            _, pval,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;median_test&#34;:
            _, pval,_,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;ttest_ind&#34;:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,equal_var=equal_var,**kwargs)
        
        else:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        
        p1ind=xorder.index(p1)
        p2ind=xorder.index(p2)
        if pval==0:
            pval=np.inf
        else:
            pval=-np.log10(pval)
        pvals.append([np.abs(p2ind-p1ind), np.amin([p2ind, p1ind]),np.amax([p2ind, p1ind]), pval])
    pvals = sorted(pvals, key = lambda x: (x[0], x[1]))
        
    fig, ax=plt.subplots()
    sns.violinplot(data=df, x=x,y=y,inner=&#34;quartile&#34;)
    if swarm==True:
        sns.swarmplot(data=df, x=x,y=y,color=&#34;black&#34;,alpha=0.5)
    ymax=np.amax(df[y])
    newpvals={}
    for i, pval in enumerate(pvals):
        plt.plot([pval[1],pval[2]], [ymax*(1.05+i*0.05),ymax*(1.05+i*0.05)], color=&#34;black&#34;)
        p=np.round(pval[-1],2)
        
        newpvals[xorder[pval[1]]+&#34;_&#34;+xorder[pval[2]]]=p
        if significance==&#34;numeric&#34;:
            annotate=&#34;-log10(p)=&#34;+str(p)
        elif significance==&#34;symbol&#34;:
            keys=sorted(significance_ranges.keys())
            annotate=&#34;NA&#34;
            for j in range(len(keys)):
                if j==0:
                    if p &lt;= significance_ranges[keys[j]]:
                        annotate=&#34;&#34;
                        break
                else:
                    if significance_ranges[keys[j-1]] &lt; p &lt;=significance_ranges[keys[j]]:
                        annotate=keys[i]
                        break
            if annotate==&#34;NA&#34;:
                annotate=keys[-1]
        plt.text((pval[1]+pval[2])/2, ymax*(1.055+i*0.05), annotate)
    if significance==&#34;symbol&#34;:
        ax.annotate(&#34;\n&#34;.join([&#34;{}: p &lt; {:.2E}&#34;.format(k, 10**(-significance_ranges[k])) for k in keys]),
            xy=(0.9,0.9), xycoords=&#39;axes fraction&#39;,
            textcoords=&#39;offset points&#39;,
            size=12,
            bbox=dict(boxstyle=&#34;round&#34;, fc=(0.9, 0.9, 0.9), ec=&#34;none&#34;))
        plt.subplots_adjust(right=0.850)
    
    if yunit!=&#34;&#34;:
        ax.text(0, 1, &#34;({})&#34;.format(yunit), transform=ax.transAxes, ha=&#34;right&#34;)
        
    _save(save, &#34;violin&#34;)
    
    return {&#34;p values&#34;:newpvals,&#34;axes&#34;:ax}



def volcanoplot():
    pass


if __name__==&#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="omniplot.plot.complex_clustermap"><code class="name flex">
<span>def <span class="ident">complex_clustermap</span></span>(<span>df: pandas.core.frame.DataFrame, variables: list = [], dfcol: Optional[pandas.core.frame.DataFrame] = None, row_colors: list = [], col_colors: list = [], row_plot: list = [], col_plot: list = [], row_scatter: list = [], col_scatter: list = [], row_bar: list = [], col_bar: list = [], ctitle: str = '', approx_clusternum: int = 10, approx_clusternum_col: int = 3, color_var: int = 0, merginalsum: bool = False, show: bool = False, method: str = 'ward', return_col_cluster: bool = True, ztranform: bool = True, xticklabels: bool = True, yticklabels: bool = False, show_plot_labels: bool = False, figsize: list = [], title: str = '', save: str = '', heatmap_palette: str = 'coolwarm', heatmap_col: list = [], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a clustered heatmap with merginal plots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>variables</code></strong> :&ensp;<code>list</code></dt>
<dd>the column names of variables for heatmap</dd>
<dt><strong><code>row_colors</code></strong>, <strong><code>col_colors</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>the column names of categorical values to be plotted as color labels. for the col_colors to be plotted, dfcol options will be needed.</dd>
<dt><strong><code>row_plot</code></strong>, <strong><code>col_plot</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The column names for the values to be plotted as lines.</dd>
<dt><strong><code>row_scatter</code></strong>, <strong><code>col_scatter</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The column names for the values to be plotted as points.</dd>
<dt><strong><code>row_bar</code></strong>, <strong><code>col_bar</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The column names for the values to be plotted as bars.</dd>
<dt><strong><code>approx_clusternum</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The approximate number of row clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won't change.</dd>
<dt><strong><code>approx_clusternum_col</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The approximate number of column clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won't change.</dd>
<dt><strong><code>color_var</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of potential colors in dendrograms. If some clusters in the dendrogram share a same color (because the number of clusters is too many),
give this option may solve the problem.</dd>
<dt><strong><code>merginalsum</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to draw bar plots for merginal distribution.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>string</code>, optional <code>(default: "ward")</code></dt>
<dd>Method for hierarchical clustering. ["ward", "single",</dd>
<dt><strong><code>return_col_cluster</code></strong> :&ensp;<code>string</code></dt>
<dd>The title for color values. If not set, "color_val" will be used.</dd>
<dt><strong><code>ztranform</code></strong> :&ensp;<code>bool</code>, optional <code>(default: True)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>xticklabels</code></strong> :&ensp;<code>bool</code>, optional <code>(default: True)</code></dt>
<dd>Whether or not to show xtick labels</dd>
<dt><strong><code>yticklabels</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Whether or not to show ytick labels</dd>
<dt><strong><code>show_plot_labels</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Whether or not to show plot labels.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>heatmap_col</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The same as the "variables" option. Will be deprecated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>dict: {"row_clusters":pd.DataFrame,"col_clusters":pd.DataFrame, "grid":g}
</code></pre>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complex_clustermap(df: pd.DataFrame,
                       variables: list=[],
                       dfcol: Optional[pd.DataFrame]=None, 
                       row_colors: list=[],
                       col_colors: list=[],
                       row_plot: list=[],
                       col_plot: list=[],
                       row_scatter: list=[],
                       col_scatter: list=[],
                       row_bar: list=[],
                       col_bar: list=[],
                       ctitle: str=&#34;&#34;,
                       approx_clusternum: int=10,
                       approx_clusternum_col: int=3,
                       color_var: int=0,
                       merginalsum: bool=False,
                       show: bool=False,
                       method: str=&#34;ward&#34;,
                       return_col_cluster: bool=True,
                       ztranform: bool=True,
                       xticklabels: bool=True, 
                       yticklabels: bool=False,
                       show_plot_labels: bool=False,
                       figsize: list=[],
                       title: str=&#34;&#34;,
                       save: str=&#34;&#34;,
                       heatmap_palette: str=&#34;coolwarm&#34;,
                       heatmap_col: list=[],
                       **kwargs):
    &#34;&#34;&#34;
    Drawing a clustered heatmap with merginal plots.
    
    Parameters
    ----------
    df : pandas DataFrame
    variables : list
        the column names of variables for heatmap
    row_colors, col_colors: list, optional
        the column names of categorical values to be plotted as color labels. for the col_colors to be plotted, dfcol options will be needed.
    row_plot, col_plot : list, optional
        The column names for the values to be plotted as lines.
    row_scatter, col_scatter: list, optional
        The column names for the values to be plotted as points.
    row_bar, col_bar: list, optional
        The column names for the values to be plotted as bars.
    approx_clusternum : int, optional
        The approximate number of row clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.    
    approx_clusternum_col : int, optional
        The approximate number of column clusters to be created. Labeling the groups of leaves with different colors. The result of hierarchical clustering won&#39;t change.

    color_var : int, optional
        The number of potential colors in dendrograms. If some clusters in the dendrogram share a same color (because the number of clusters is too many), 
        give this option may solve the problem. 
    merginalsum : bool, optional
        Whether or not to draw bar plots for merginal distribution.
    show : bool, optional
        Whether or not to show the figure.
    method : string, optional (default: &#34;ward&#34;)
        Method for hierarchical clustering. [&#34;ward&#34;, &#34;single&#34;, 
    return_col_cluster : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    
    ztranform: bool, optional (default: True)
    xticklabels: bool, optional (default: True)
        Whether or not to show xtick labels
    yticklabels: bool, optional (default: False)
        Whether or not to show ytick labels
    show_plot_labels: bool, optional (default: False)
        Whether or not to show plot labels.
    figsize: list, optional
        
    title: str, optional
    save: str, optional
    
    heatmap_col: list, optional
        The same as the &#34;variables&#34; option. Will be deprecated.
    Returns
    -------
        dict: {&#34;row_clusters&#34;:pd.DataFrame,&#34;col_clusters&#34;:pd.DataFrame, &#34;grid&#34;:g}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;#print(kwargs)
    rnum, cnum=df.shape
    if len(heatmap_col)==0 and len(variables)==0:
        raise Exception(&#34;Please specify the variables option&#34;)
    if len(heatmap_col)!=0:
        variables=heatmap_col
    cnum=len(variables)
    if len(figsize)==0:
        xsize=np.amin([2*cnum, 20])
        figsize=[xsize,10]
    scatterpointsize=5
    sns.set(font_scale=1)
    if ztranform==True:
        df[variables]=df[variables].apply(zscore)
        if ctitle ==&#34;&#34;:
            ctitle=&#34;zscore&#34;
    
    if len(col_plot)!=0 or len(col_scatter)!=0 or len(col_bar)!=0:
        if dfcol==None:
            raise Exception(&#34;if you want to plot along the x axis, you need provide dfcol option containing values to plot.&#34;)
    
    totalrowplot=0
    if merginalsum==True:
        totalrowplot+=1
    totalrowplot+=len(row_plot)
    totalrowplot+=len(row_colors)
    totalrowplot+=len(row_scatter)
    totalrowplot+=len(row_bar)
    totalcolplot=0
    if merginalsum==True:
        totalcolplot+=1
    totalcolplot+=len(col_plot) 
    totalcolplot+=len(col_colors)
    totalcolplot+=len(col_scatter)
    totalcolplot+=len(col_bar)
    _row_color_legend={}
    _col_color_legend={}
    colormap_index=0
    if totalrowplot + totalcolplot &gt;0:
        rowplotcount=0
        colplotcount=0
        _row_colors=[]
        _row_colors_title=[]
        _col_colors=[]
        _col_colors_title=[]
        
        if merginalsum:
            _row_colors.append(np.ones([rnum, 4]))
            _row_colors_title.append(&#34;Sum&#34;)
            _col_colors.append(np.ones([cnum, 4]))
            _col_colors_title.append(&#34;Sum&#34;)
        #print(np.shape(_col_colors))
        if len(row_colors)&gt;0:
            for k in row_colors:
                
                u=np.unique(df[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _row_color_legend[k]=lut
                colormap_index+=1
                _row_colors.append([lut[cat] for cat in df[k]])
                _row_colors_title.append(k)
                
        if len(col_colors)&gt;0:
            for k in col_colors:
                u=np.unique(dfcol[k])
                _cmap=plt.get_cmap(colormap_list[colormap_index],u.shape[0])
                lut={}
                for _i, _u in enumerate(u):
                    lut[_u]=_cmap(_i)
                _col_color_legend[k]=lut
                colormap_index+=1
                _col_colors.append([lut[cat] for cat in dfcol[k]])
                _col_colors_title.append(k)
        
        if len(row_plot)&gt;0:
            for k in row_plot:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_plot)&gt;0:
            for k in col_plot:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k)        
        
        if len(row_scatter)&gt;0:
            for k in row_scatter:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_scatter)&gt;0:
            for k in col_scatter:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(row_bar)&gt;0:
            for k in row_bar:
                _row_colors.append(np.ones([rnum, 4]))
                _row_colors_title.append(k)
        if len(col_bar)&gt;0:
            for k in col_bar:
                _col_colors.append(np.ones([rnum, 4]))
                _col_colors_title.append(k) 
        
        if len(_row_colors) &gt;0 and len(_col_colors) &gt;0:
            #print(np.shape(_col_colors))
            g=sns.clustermap(df[variables],col_colors=_col_colors, 
                             row_colors=_row_colors,
                             method=method,xticklabels=xticklabels, yticklabels=yticklabels,
                             figsize=figsize,dendrogram_ratio=0.1,
                             cbar_kws=dict(ticks=[0, 0.50, 1],cmap=heatmap_palette, orientation=&#39;horizontal&#39;),
                             **kwargs)
            
            g.ax_col_colors.invert_yaxis()
            g.ax_row_colors.invert_xaxis()
        elif len(_col_colors) &gt;0:
           
            g=sns.clustermap(df[variables],
                             col_colors=_col_colors,
                             method=method,
                             xticklabels=xticklabels, 
                             yticklabels=yticklabels,
                             dendrogram_ratio=0.1,
                             cbar_kws=dict(ticks=[0, 0.50, 1],cmap=heatmap_palette, orientation=&#39;horizontal&#39;),
                             figsize=figsize,**kwargs)
            g.ax_col_colors.invert_yaxis()
        elif len(_row_colors) &gt;0:
            g=sns.clustermap(df[variables],
                             row_colors=_row_colors,
                             method=method,
                             xticklabels=xticklabels,
                             cmap=heatmap_palette, 
                             yticklabels=yticklabels,
                             dendrogram_ratio=0.1,
                             figsize=figsize,
                             cbar_kws=dict(orientation=&#39;horizontal&#39;),
                             **kwargs)
            g.ax_row_colors.invert_xaxis()

        
        #for spine in g.ax_cbar.spines:
        #    g.ax_cbar.spines[spine].set_linewidth(2)

        
        rowplotcount=0
        colplotcount=0
        tickpos=0.9
        row_labels=[]
        col_labels=[]
        row_ticks=[]
        col_ticks=[]
        if merginalsum:
            mat=df[variables].to_numpy()
            r=np.sum(mat, axis=1)
            row_labels.append(0)
            row_labels.append(np.amax(r))
            row_ticks.append(rowplotcount)
            row_ticks.append(rowplotcount+tickpos)
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            if row_cluster==True:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r[leaves_list(g.dendrogram_row.linkage)]/np.amax(r),height=1)
                
            else:
                g.ax_row_colors.barh(np.arange(r.shape[0])+0.5, r/np.amax(r),height=1)
            #g.ax_row_colors.set_xticks([0,1],labels=[0,np.amax(r)])
            c=np.sum(mat, axis=0)
            #print(mat, c)
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            if col_cluster==True:
            
            #print(leaves_list(g.dendrogram_col.linkage))
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c[leaves_list(g.dendrogram_col.linkage)]/np.amax(c),width=1)
            else:
                g.ax_col_colors.bar(np.arange(c.shape[0])+0.5,c/np.amax(c),width=1)
            #g.ax_col_colors.set_yticks([0,1],labels=[0,np.amax(c)])
            col_labels.append(0)
            col_labels.append(np.amax(c))
            col_ticks.append(colplotcount)
            col_ticks.append(colplotcount+tickpos)
            rowplotcount=1
            colplotcount=1
        rowplotcount+=len(row_colors)
        colplotcount+=len(col_colors)
        if len(row_plot)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_plot):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)

                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
                else:
                    g.ax_row_colors.plot(r+rowplotcount, np.arange(r.shape[0])+0.5)
            
                rowplotcount+=1
                
        if len(col_plot)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_plot):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount)
                else:
                    g.ax_col_colors.plot(np.arange(r.shape[0])+0.5,r+colplotcount)
                
                colplotcount+=1
        if len(row_scatter)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_scatter):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    tmpindx=leaves_list(g.dendrogram_row.linkage)
                    r=r[tmpindx]
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
                else:
                    g.ax_row_colors.scatter(r+rowplotcount, np.arange(r.shape[0])+0.5,s=scatterpointsize)
            
                rowplotcount+=1
        if len(col_scatter)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_scatter):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)
                
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if col_cluster==True:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]+colplotcount,s=scatterpointsize)
                else:
                    g.ax_col_colors.bar(np.arange(r.shape[0])+0.5,r+colplotcount,s=scatterpointsize)
                
                colplotcount+=1
        
        if len(row_bar)&gt;0:
            row_cluster=True
            if &#34;row_cluster&#34; in kwargs:
                row_cluster=kwargs[&#34;row_cluster&#34;]
            
            for i, lname in enumerate(row_bar):
                r=np.array(df[lname])
                row_labels.append(np.amin(r))
                row_labels.append(np.amax(r))
                row_ticks.append(rowplotcount)
                row_ticks.append(rowplotcount+tickpos)
                    
                r=r-np.amin(r)
                r=r/np.amax(r)
                r=0.9*r
                if row_cluster==True:
                    g.ax_row_colors.barh(y=np.arange(r.shape[0])+0.5, width=r[leaves_list(g.dendrogram_row.linkage)],left=[rowplotcount]*r.shape[0])
                else:
                    g.ax_row_colors.barh(r, np.arange(r.shape[0])+0.5,left=[rowplotcount]*r.shape[0])
            
                rowplotcount+=1
        if len(col_bar)&gt;0:
            col_cluster=True
            if &#34;col_cluster&#34; in kwargs:
                col_cluster=kwargs[&#34;col_cluster&#34;]
            for i, lname in enumerate(col_bar):
                r=np.array(dfcol[lname])
                col_labels.append(np.amin(r))
                col_labels.append(np.amax(r))
                col_ticks.append(colplotcount)
                col_ticks.append(colplotcount+tickpos)

                if col_cluster==True:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r[leaves_list(g.dendrogram_col.linkage)]/(np.amax(r)*1.1)+colplotcount)
                else:
                    g.ax_col_colors.scatter(np.arange(r.shape[0])+0.5,r/(np.amax(r)*1.1)+colplotcount)
                
                colplotcount+=1
        if g.ax_row_colors!=None:
            
            g.ax_row_colors.set_xticks(np.arange(len(_row_colors_title))+0.5)
            g.ax_row_colors.set_xticklabels(_row_colors_title, rotation=90)
        if g.ax_col_colors!=None:
            colax_otherside = g.ax_col_colors.twinx()
            colax_otherside.set_yticks(0.5*(np.arange(len(_col_colors_title))+0.5),labels=_col_colors_title)
            colax_otherside.grid(False)
        if g.ax_col_dendrogram!=None:
            col = g.ax_col_dendrogram.get_position()
            g.ax_col_dendrogram.set_position([col.x0, col.y0, col.width*0.5, col.height*0.5])
        
        if show_plot_labels==True:
            
            rowax_otherside = g.ax_row_colors.twiny()
            rowax_otherside.invert_xaxis()
            rowax_otherside.grid(False)
            rowax_otherside.set_xticks(row_ticks, labels=np.round(row_labels,2), rotation=90, fontsize=8)
            col_ticks=np.array(col_ticks)
            g.ax_col_colors.set_yticks(col_ticks, labels=np.round(col_labels,2), fontsize=8)
        
        legend_num=0
        for _title, colorlut in _row_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))

            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=_title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        for _title, colorlut in _col_color_legend.items():
            legendhandles=[]
            for label, color in colorlut.items():
                legendhandles.append(Line2D([0], [0], color=color,linewidth=5, label=label))

            legend1=g.ax_heatmap.legend(handles=legendhandles, loc=[1.15,0.8-0.2*legend_num], title=_title)
            g.ax_heatmap.add_artist(legend1)
            legend_num+=1
        
    else:
        g=sns.clustermap(df,method=method,cbar_kws={&#34;label&#34;:ctitle},**kwargs)
    if color_var&gt;0:
        cmap = cm.nipy_spectral(np.linspace(0, 1, color_var))
    else:
        cmap = cm.nipy_spectral(np.linspace(0, 1, approx_clusternum+5))
    hierarchy.set_link_color_palette([mpl.colors.rgb2hex(rgb[:3]) for rgb in cmap])
    
    &#34;&#34;&#34;coloring the row dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    if g.dendrogram_row != None:
        t=_dendrogram_threshold(g.dendrogram_row.dendrogram,approx_clusternum)
        # lbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,:2]
        # rbranches=np.array(g.dendrogram_row.dendrogram[&#34;dcoord&#34;])[:,2:]
        # thre=np.linspace(0, np.amax(g.dendrogram_row.dendrogram[&#34;dcoord&#34;]), 100)[::-1]
        # for t in thre:
        #     #print(np.sum(lbranches[:,1]&gt;t),np.sum(rbranches[:,0]&gt;t),np.sum(lbranches[:,0]&gt;t),np.sum(rbranches[:,1]&gt;t))
        #     crossbranches=np.sum(lbranches[:,1]&gt;t)+np.sum(rbranches[:,0]&gt;t)-np.sum(lbranches[:,0]&gt;t)-np.sum(rbranches[:,1]&gt;t)
        #     #print(crossbranches)
        #
        #     if crossbranches&gt;approx_clusternum:
        #         break
        
        den=hierarchy.dendrogram(g.dendrogram_row.linkage,
                                                 labels = g.data.index,
                                                 color_threshold=t,ax=g.ax_row_dendrogram,
                            orientation=&#34;left&#34;)  
        g.ax_row_dendrogram.invert_yaxis()
        clusters = _get_cluster_classes(den)
        cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        keys=list(clusters.keys())
        ckeys={}
        i=1
        for k in keys:
            if k==&#34;C0&#34;:
                ckeys[k]=&#34;C0&#34;
            else:
                ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in clusters.items():
            _c=ckeys[c]
            for _v in v:
                cdata[&#34;Cluster&#34;].append(_c)
                cdata[&#34;Index&#34;].append(_v)
                cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
        &#34;&#34;&#34;Setting the row dendrogram ends here&#34;&#34;&#34;
    
    
    &#34;&#34;&#34;coloring the col dendrogram based on branch numbers crossed with the threshold&#34;&#34;&#34;
    col_cdata=None
    if g.dendrogram_col != None:
        t=_dendrogram_threshold(g.dendrogram_col.dendrogram,approx_clusternum_col)
        den=hierarchy.dendrogram(g.dendrogram_col.linkage,
                                                 labels = g.data.columns,
                                                 color_threshold=t,ax=g.ax_col_dendrogram,
                            orientation=&#34;top&#34;)  
        #g.ax_col_dendrogram.invert_yaxis()
        col_clusters = _get_cluster_classes(den)
        col_cdata={&#34;Cluster&#34;:[],&#34;Index&#34;:[],&#34;RGB&#34;:[]}
        col_keys=list(col_clusters.keys())
        col_ckeys={}
        i=1
        for k in col_keys:
            if k==&#34;C0&#34;:
                col_ckeys[k]=&#34;C0&#34;
            else:
                col_ckeys[k]=&#34;C&#34;+str(i)
                i+=1
        for c, v in col_clusters.items():
            _c=col_ckeys[c]
            for _v in v:
                col_cdata[&#34;Cluster&#34;].append(_c)
                col_cdata[&#34;Index&#34;].append(_v)
                col_cdata[&#34;RGB&#34;].append(matplotlib.colors.to_rgb(c))
    &#34;&#34;&#34;Setting the col dendrogram ends here&#34;&#34;&#34;
    
    
    g.fig.subplots_adjust(bottom=0.175, right=0.70)
    
    x0, _y0, _w, _h = g.cbar_pos
    
    g.ax_cbar.set_title(ctitle)
    #g.ax_cbar.tick_params(axis=&#39;x&#39;, length=5)
    g.ax_cbar.set_position(pos=[0.80, 0.3, 0.1, 0.02], which=&#34;both&#34;)
    if title !=&#34;&#34;:
        g.fig.suptitle(title, va=&#34;bottom&#34;)
    plt.setp(g.ax_heatmap.xaxis.get_majorticklabels(), rotation=90)
   
    _save(save, &#34;complex_clustermap&#34;)
    if show:
        plt.show()
    return {&#34;data&#34;:g.data2d,&#34;row_clusters&#34;:pd.DataFrame(cdata),&#34;col_clusters&#34;:pd.DataFrame(col_cdata), &#34;grid&#34;:g}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.correlation"><code class="name flex">
<span>def <span class="ident">correlation</span></span>(<span>df: pandas.core.frame.DataFrame, category: Union[str, list] = [], variables: List[~T] = [], method='pearson', palette: str = 'coolwarm', figsize=[6, 6], show_values=False, clustermap_param: dict = {}, ztransform: bool = True, xticklabels=False, yticklabels=False, title: str = '') ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a heatmap with correlations or distances between observations </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>variables</code></strong> :&ensp;<code>List</code>, optional</dt>
<dd>the names of values to calculate correlations</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code> or <code>list</code>, optional</dt>
<dd>the names of categorical values to display as color labels</dd>
<dt><strong><code>mthod</code></strong> :&ensp;<code>str</code></dt>
<dd>method for correlation/distance calculation. Defalt: "pearson"</dd>
<dt><strong><code>palette</code></strong> :&ensp;<code>str</code></dt>
<dd>A colormap name</dd>
<dt><strong><code>show_values</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheter to exhibit the values of fractions/counts/percentages.</dd>
<dt><strong><code>clustermap_param</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>List[int]</code>, optional</dt>
<dd>The figure size, e.g., [4, 6].</dd>
<dt><strong><code>ztransform</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to transform values to z-score</dd>
<dt><strong><code>xticklabels</code></strong>, <strong><code>yticklabels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the label names in the heatmap</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correlation(df: pd.DataFrame, 
                category: Union[str, list]=[],
                variables: List=[],
                method=&#34;pearson&#34;,
                palette: str=&#34;coolwarm&#34;,
                figsize=[6,6],
                show_values=False,
                clustermap_param:dict={},
                ztransform: bool=True,
                xticklabels =False,
                yticklabels=False,
                title: str=&#34;&#34;,)-&gt;Dict:
    &#34;&#34;&#34;
    Drawing a heatmap with correlations or distances between observations 
    
    Parameters
    ----------
    df : pandas DataFrame
        
    variables: List, optional
        the names of values to calculate correlations  
    
    category: str or list, optional
        the names of categorical values to display as color labels
    mthod: str
        method for correlation/distance calculation. Defalt: &#34;pearson&#34;
        
    palette : str
        A colormap name
    show_values: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    clustermap_param : dict, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
    ztransform : bool, optional
        Whether to transform values to z-score
    xticklabels, yticklabels : bool
        Whether to show the label names in the heatmap
    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    original_index=df.index
    X, category=_separate_data(df, variables=variables, category=category)
    # if len(category) !=0:
    #
    #     if type(category)==str:
    #         category=[category]
    #     #df=df.drop(category, axis=1)
    #     valnames=list(set(df.columns) -set(category)) 
    #     X = df[valnames].values
    #     assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
    #
    # else:    
    #     X = df.values
    #     assert X.dtype==float, &#34;data must contain only float values.&#34;
    if ztransform==True:
        X=zscore(X, axis=0)
    if method==&#34;pearson&#34;:
        dmat=Parallel(n_jobs=-1)(delayed(_calc_pearson)(ind, X) for ind in list(it.combinations(range(X.shape[0]), 2)))
        dmat=np.array(dmat)
        dmat=squareform(dmat)
        print(dmat)
        dmat+=np.identity(dmat.shape[0])
    else:
        dmat=squareform(pdist(X, method))
    if method==&#34;pearson&#34;:
            ctitle=&#34;Pearson correlation&#34;
    else:
        ctitle=method+&#34; distance&#34;    
        
        
    if len(category) &gt;0:
        dfm=pd.DataFrame(data=dmat)
        colnames=dfm.columns
        for cat in category:
            dfm[cat]=df[cat].values
        res=complex_clustermap(dfm,
                               heatmap_col=colnames, 
                               row_colors=category,
                               ztranform=False,
                               xticklabels=xticklabels,
                               yticklabels=yticklabels,
                               figsize=figsize,
                               ctitle=ctitle )
        return res
    else:
        
        g=sns.clustermap(data=dmat,
                         xticklabels=xticklabels,
                         yticklabels=yticklabels,
                   method=&#34;ward&#34;, 
                   cmap=palette,
                   col_cluster=True,
                   row_cluster=True,
                   figsize=figsize,
                   rasterized=True,
                    #cbar_kws={&#34;label&#34;:&#34;Pearson correlation&#34;}, 
                   annot=show_values,
                   **clustermap_param)
        
        g.cax.set_ylabel(ctitle, rotation=-90,va=&#34;bottom&#34;)
        plt.setp(g.ax_heatmap.get_yticklabels(), rotation=0)  # For y axis
        plt.setp(g.ax_heatmap.get_xticklabels(), rotation=90) # For x axis
        return {&#34;grid&#34;:g}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.dotplot"><code class="name flex">
<span>def <span class="ident">dotplot</span></span>(<span>df: pandas.core.frame.DataFrame, y: str = '', x: str = '', dfc=Empty DataFrame
Columns: []
Index: [], scaling: float = 10, color_val: str = '', size_val: str = '', highlight: str = '', color_title: str = '', size_title: str = '', figsize: list = [], save: str = '', threshold: float = 1.3010299956639813, row_clustering: bool = True, xtickrotation: float = 90, column_order: list = [], colorpalette='coolwarm', show: bool = False, title: str = '', row: str = '', col: str = '') ‑> Dict[str, matplotlib.axes._axes.Axes]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a dotplot that can represent two different variables as dot sizes and colors on a regular grid.
This function is assumed to plot GO enrichment analysis with multiple gene sets.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>dataframe containing two categories and corresponding values (such as p values and odds ratio).
e.g.:
Cluster
Condensate
pval
odds
FDR
54
C1
Cajal body -0.000000
0.000000 -0.000000
55
C1
<em>DNA repair focus -0.000000
0.000000 -0.000000
56
C1
</em>DNA replication condensate -0.000000
0.000000 -0.000000
57
C1
P-body -0.000000
0.000000 -0.000000
58
C1
PML body -0.000000
0.000000 -0.000000</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>string</code></dt>
<dd>the column name of a category that is going to be placed in the row of the dotplot</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>string</code></dt>
<dd>the column name of a category that is going to be placed in the column of the dotplot</dd>
<dt><strong><code>color_val</code></strong> :&ensp;<code>string</code></dt>
<dd>The column name for the values represented as dot colors.</dd>
<dt><strong><code>size_val</code></strong> :&ensp;<code>string</code></dt>
<dd>The column name for the values represented as dot sizes.</dd>
<dt><strong><code>scaling</code></strong> :&ensp;<code>float</code></dt>
<dd>The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.</dd>
<dt><strong><code>highlight</code></strong> :&ensp;<code>string</code></dt>
<dd>A dictionary to set color labels to leaves. The key is the name of the color label.
The value is the list of RGB color codes, each corresponds to the color of a leaf.
e.g., {"color1":[[1,0,0,1], ....]}</dd>
<dt><strong><code>size_title</code></strong> :&ensp;<code>string</code></dt>
<dd>The title for size values. If not set, "size_val" will be used.</dd>
<dt><strong><code>color_title</code></strong> :&ensp;<code>string</code></dt>
<dd>The title for color values. If not set, "color_val" will be used.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>axes</code></strong> :&ensp;<code>dict {"axes1":ax1,"axes2":ax2,"axes3":ax3}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dotplot(df: pd.DataFrame,
            y: str=&#34;&#34;,
            x: str=&#34;&#34;,
            dfc=pd.DataFrame(),
            scaling: float=10,
            color_val: str=&#34;&#34;,
            size_val: str=&#34;&#34;,
            highlight: str=&#34;&#34;,
            color_title: str=&#34;&#34;,
            size_title: str=&#34;&#34;,
            figsize: list=[],
            save: str=&#34;&#34;,
            threshold: float=-np.log10(0.05),
            row_clustering: bool=True,
            xtickrotation: float=90,
            column_order: list=[],
            colorpalette=&#34;coolwarm&#34;,
            show: bool=False,
            title: str=&#34;&#34;,
            row: str=&#34;&#34;,
            col: str=&#34;&#34;,
            ) -&gt; Dict[str, plt.Axes]:
    &#34;&#34;&#34;
    Drawing a dotplot that can represent two different variables as dot sizes and colors on a regular grid.
    This function is assumed to plot GO enrichment analysis with multiple gene sets.
    
    Parameters
    ----------
    df : pandas DataFrame
        dataframe containing two categories and corresponding values (such as p values and odds ratio).
        e.g.:
            Cluster                   Condensate      pval      odds       FDR
        54       C1                   Cajal body -0.000000  0.000000 -0.000000
        55       C1            *DNA repair focus -0.000000  0.000000 -0.000000
        56       C1  *DNA replication condensate -0.000000  0.000000 -0.000000
        57       C1                       P-body -0.000000  0.000000 -0.000000
        58       C1                     PML body -0.000000  0.000000 -0.000000
    row: string
        the column name of a category that is going to be placed in the row of the dotplot
    col: string
        the column name of a category that is going to be placed in the column of the dotplot
    color_val : string
        The column name for the values represented as dot colors.
    size_val : string
        The column name for the values represented as dot sizes. 
    scaling: float
        The scale of dots. If resulting dots are too large (or small), you can reduce (or increase) dot sizes by adjusting this value.
    highlight : string
        A dictionary to set color labels to leaves. The key is the name of the color label. 
        The value is the list of RGB color codes, each corresponds to the color of a leaf. 
        e.g., {&#34;color1&#34;:[[1,0,0,1], ....]}   
    size_title : string
        The title for size values. If not set, &#34;size_val&#34; will be used.
    
    color_title : string
        The title for color values. If not set, &#34;color_val&#34; will be used.
    show : bool
        Whether or not to show the figure.
    Returns
    -------
    axes: dict {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if x !=&#34;&#34; and y!=&#34;&#34;:
        row=y
        col=x
    if size_val!=&#34;&#34;:
        _df=df.pivot_table(index=col,columns=row,values=size_val)
        if len(column_order)&gt;0:
            _df=_df.loc[column_order]
        else:
            _df=_df.sort_index(axis=0,key=natsort_keygen())
        _df=_df.fillna(0)
            
        if color_val!=&#34;&#34;:
            dfc=df.pivot_table(index=col,columns=row,values=color_val)
            if len(column_order)&gt;0:
                dfc=dfc.loc[column_order]
            else:
                dfc=dfc.sort_index(axis=0,key=natsort_keygen())
            dfc=dfc.fillna(0)
        if highlight !=&#34;&#34;:
            dfh=df.pivot_table(index=col,columns=row,values=highlight)
            if len(column_order)&gt;0:
                dfh=dfh.loc[column_order]
            else:
                dfh=dfh.sort_index(axis=0,key=natsort_keygen())
            dfh=dfh.fillna(0)
        
        if row_clustering==True:
            Y = fcl.linkage(_df.to_numpy().T, method=&#39;ward&#39;, metric=&#39;euclidean&#39;)
            Z1 = sch.dendrogram(Y,no_plot=True)
            idx1 = Z1[&#39;leaves&#39;]
            reorder=_df.columns[idx1]
            _df=_df[reorder]
            if color_val!=&#34;&#34;:
                dfc=dfc[reorder]
            if highlight !=&#34;&#34;:
                dfh=dfh[reorder]
        _x=_df.index
        _y=_df.columns
        mat=_df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    else:
        _x=df.index
        _y=df.columns
        mat=df.to_numpy()
        minsize=np.amin(mat)
        maxsize=np.amax(mat)
    #if minsize==0:
        #mat=mat+maxsize*0.01
    #minsize=np.amin(mat)
    
    maxsize=np.round(maxsize)
    middle0=np.round((minsize+maxsize)/3)
    middle1=np.round(2*(minsize+maxsize)/3)
    #plt.rcParams[&#34;figure.figsize&#34;] = [7.50, 3.50]
    #plt.rcParams[&#34;figure.autolayout&#34;] = True
    #x = np.arange(len(_x))
    #y = np.arange(len(_y))
    #X, Y = np.meshgrid(x, y)
    xy=[ [i,j] for i in range(len(_x)) for j in range(len(_y))]
    #num = 1000
    sizes = [mat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
    edge_colors=[]
    if highlight !=&#34;&#34;:
        hmat=dfh.to_numpy()
        hvals = [hmat[i,j]*scaling for i in range(len(_x)) for j in range(len(_y))]
       
        for s in hvals:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    else:
        for s in sizes:
            if s&gt;=threshold*scaling:
                edge_colors.append(&#34;magenta&#34;)
            else:
                edge_colors.append(&#34;gray&#34;)
    
    if len(dfc) !=0:
        viridis = cm.get_cmap(colorpalette, 12)
        cmat=dfc.to_numpy()
        cmat[cmat==np.inf]=0
        _cmat=cmat/np.amax(cmat)
        _colors = [viridis(_cmat[i,j]) for i in range(len(_x)) for j in range(len(_y))]
    else:
        _colors = [[0,1,0,1] for i in range(len(_x)) for j in range(len(_y))]
    #print(sizes)
    #xy = 10 * np.random.random((num, 2))
    #xy=XY
    #patches = [plt.Circle(center, size) for center, size in zip(xy, sizes)]
    
    #fig, ax = plt.subplots(ncols=2, gridspec_kw={&#39;width_ratios&#39;: [8, 2]})
    if len(figsize)==0:
        figsize=[mat.shape[0]*0.5+2,mat.shape[1]*0.5+1]
    
    fig = plt.figure(figsize=figsize)
    #fig.set_figheight(6)
    #fig.set_figwidth(6)
    
    ax1 = plt.subplot2grid(shape=(10, 6), loc=(0, 0), colspan=4, rowspan=10)
    ax2 = plt.subplot2grid(shape=(10, 6), loc=(1, 4), colspan=2, rowspan=4)
    ax3 = plt.subplot2grid(shape=(10, 6), loc=(6, 4), colspan=2, rowspan=1)
 
    collection = mc.CircleCollection(sizes,
                                     edgecolors=edge_colors, 
                                     offsets=xy, 
                                     transOffset=ax1.transData, 
                                     facecolors=_colors,
                                     linewidths=2)
    ax1.add_collection(collection)
    ax1.margins(0.1)
    ax1.set_xlim(-0.5,len(_x)-0.5)
    ax1.set_xticks(np.arange(len(_x)))
    ax1.set_xticklabels(_x,rotation=xtickrotation)
    ax1.set_yticks(np.arange(len(_y)))
    ax1.set_yticklabels(_y, rotation=0)
    if color_title==&#34;&#34;:
        color_title=color_val
    
    if len(dfc) !=0:
        norm = mpl.colors.Normalize(vmin=np.min(cmat), vmax=np.amax(cmat))
        
        cb1 = mpl.colorbar.ColorbarBase(ax3, cmap=viridis,
                                        norm=norm,
                                        orientation=&#39;horizontal&#39;)
        cb1.set_label(color_title)
    #ax[1]=fig.add_axes([1,0.3,0.1,1])
    
    lxy=[[0.5, i*0.5] for i in range(3)]
    collection2 = mc.CircleCollection([middle0*scaling,middle1*scaling, maxsize*scaling], 
                                      offsets=lxy, 
                                      transOffset=ax2.transData, 
                                      facecolors=&#39;lightgray&#39;,
                                      edgecolors=&#34;gray&#34;)
    ax2.add_collection(collection2)
    ax2.axis(&#39;off&#39;)
    ax2.margins(0.3)
    for text, (x, y) in zip([middle0,middle1, maxsize], lxy):
        ax2.text(x+0.01, y,str(text), ha=&#34;left&#34;,va=&#34;center&#34;,color=&#34;black&#34; )
    if size_title==&#34;&#34;:
        size_title=size_val
    ax2.text(0.5,-0.5, size_title,va=&#34;center&#34;,ha=&#34;center&#34;)
    #ax[1].set_yticks(np.arange(3))
    #ax[1].set_yticklabels([minsize,middle, maxsize], rotation=0)
    #plt.tight_layout()
    plt.subplots_adjust(left=0.3,bottom=0.2)
    #plt.tight_layout()
    if title !=&#34;&#34;:
        fig.suptitle(title)
    _save(save, &#34;dotplot&#34;)
    if show==True:
        plt.show()
    return {&#34;axes1&#34;:ax1,&#34;axes2&#34;:ax2,&#34;axes3&#34;:ax3}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.radialtree"><code class="name flex">
<span>def <span class="ident">radialtree</span></span>(<span>df: pandas.core.frame.DataFrame, n_clusters: int = 3, x: str = '', variables: List[~T] = [], category: Union[str, List[str]] = [], ztransform: bool = True, save: str = '', distance_method='euclidean', tree_method='ward', title: str = '', y: list = [], **kwargs) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a radial dendrogram with color labels.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>A wide format data.</dd>
<dt><strong><code>n_clusters</code></strong> :&ensp;<code>int</code>, optional <code>(default: 3)</code></dt>
<dd>Approximate number of clusters to produce</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the name of columns containing sample names. If not provided, the index will be considered sample names.</dd>
<dt><strong><code>variables</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>the name of columns containing variables to calculate the distances between samples</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>the column name of a category that is going to presented as colors around the dendrogram.</dd>
<dt><strong><code>ztransform</code></strong> :&ensp;<code>bool=True,</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>str="",</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>distance_method="euclidean",
tree_method="ward",</p>
<dl>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code></dt>
<dd>A float to specify the font size</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>[x, y] array-like</code></dt>
<dd>1D array-like of floats to specify the figure size</dd>
<dt><strong><code>palette</code></strong> :&ensp;<code>string</code></dt>
<dd>Matlab colormap name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong> :&ensp;<code>{"axes":ax, "clusters": clusters}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radialtree(df: pd.DataFrame,
               n_clusters: int=3,
               x: str=&#34;&#34;,
               variables: List=[],
               category: Union[str, List[str]]=[],
               ztransform: bool=True,
               save: str=&#34;&#34;,
               distance_method=&#34;euclidean&#34;,
               tree_method=&#34;ward&#34;,
               title: str=&#34;&#34;,
               y: list=[],
               **kwargs) -&gt; Dict:
    &#34;&#34;&#34;
    Drawing a radial dendrogram with color labels.
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide format data. 
        
        
    n_clusters: int, optional (default: 3)
        Approximate number of clusters to produce
    x: str, optional
        the name of columns containing sample names. If not provided, the index will be considered sample names.
    variables: list, optional
        the name of columns containing variables to calculate the distances between samples
    category: str or list of str
        the column name of a category that is going to presented as colors around the dendrogram.
    ztransform: bool=True,
    save: str=&#34;&#34;,
    distance_method=&#34;euclidean&#34;,
    tree_method=&#34;ward&#34;,
    
    
    show : bool
        Whether or not to show the figure.
    fontsize : float
        A float to specify the font size
    figsize : [x, y] array-like
        1D array-like of floats to specify the figure size
    palette : string
        Matlab colormap name.
    Returns
    -------
    dict: {&#34;axes&#34;:ax, &#34;clusters&#34;: clusters}

    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    if len(y)!=0:
        variables=y
    
    if x !=&#34;&#34;:
        _labels=df[x]
        df=df.drop(x, axis=1)
    else:
        _labels=df.index

    X, category=_separate_data(df, variables=variables, category=category)
    category_df=df[category]
    # if len(variables)!=0 and len(category)!=0:
    #     if type(category)==str:
    #         category=[category]
    #     category_df=df[category]
    #     df=df[variables]
    #     X = df.values
    #     #print(X)
    #     assert X.dtype==float, f&#34;{x} columns must contain only float values.&#34;
    #
    #
    # elif len(category) !=0:
    #     if type(category)==str:
    #         category=[category]
    #     category_df=df[category]
    #     df=df.drop(category, axis=1)
    #     X = df.values
    #     #print(X)
    #     assert X.dtype==float, f&#34;data must contain only float values except {category} column.&#34;
    #
    # else:    
    #     X = df.values
    #     assert X.dtype==float, &#34;data must contain only float values.&#34;
    
    
    
    if ztransform==True:
        X=zscore(X, axis=0)
    D=squareform(pdist(X,metric=distance_method))
    Y = sch.linkage(D, method=tree_method)
    
    Z = sch.dendrogram(Y,labels=_labels,no_plot=True)
    t=_dendrogram_threshold(Z, n_clusters)
    Z=sch.dendrogram(Y,
                        labels = _labels,
                        color_threshold=t,no_plot=True)
    sample_classes={k: list(category_df[k]) for k in category_df.columns}
    ax=_radialtree2(Z, sample_classes=sample_classes,addlabels=False, **kwargs)
    if title !=&#34;&#34;:
        ax.set_title(title)
    _save(save, &#34;radialtree&#34;)
    clusters = _get_cluster_classes(Z)
    return {&#34;axes&#34;:ax, &#34;clusters&#34;:clusters}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.triangle_heatmap"><code class="name flex">
<span>def <span class="ident">triangle_heatmap</span></span>(<span>df, grid_pos: list = [], grid_labels: list = [], show: bool = False, save: str = '', title: str = '') ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Creating a heatmap with 45 degree rotation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>grid_pos</code></strong> :&ensp;<code>list</code></dt>
<dd>the column name of a category that is going to be placed in the row of the dotplot</dd>
<dt><strong><code>grid_labels</code></strong> :&ensp;<code>list</code></dt>
<dd>the column name of a category that is going to be placed in the column of the dotplot</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to show the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict {"axes": ax}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_heatmap(df, 
                     grid_pos: list=[],
                     grid_labels: list=[],
                     show: bool=False, 
                     save: str=&#34;&#34;,title: str=&#34;&#34;)-&gt; dict:
    
    &#34;&#34;&#34;
    Creating a heatmap with 45 degree rotation.
    
    Parameters
    ----------
    df : pandas DataFrame
    grid_pos: list
        the column name of a category that is going to be placed in the row of the dotplot
    grid_labels: list
        the column name of a category that is going to be placed in the column of the dotplot
    show : bool
        Whether or not to show the figure.
    
    Returns
    -------
    dict {&#34;axes&#34;: ax}
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    
    genes=df.index
    fig, ax = plt.subplots(figsize=[8,6])
    dmat=df.to_numpy()
    D = dmat
    N = dmat.shape[0]
    a=np.tril(np.zeros([N,N])-1000000, k=-1)
    # Get the lower triangle of the matrix. 
    C = np.triu(D)+a
    
    # Mask the upper triangle.
    C = np.ma.masked_array(C, C == -1000000)
    # Set the diagonal to zero.
    for i in range(N):
        C[i, i] = 0
    
    # Transformation matrix for rotating the heatmap.
    A = np.array([(y, x) for x in range(N, -1, -1) for y in range(N + 1)])
    t = np.array([[2**(-0.5), 2**(-0.5)], [-2**(-0.5), 2**(-0.5)]])
    A = np.dot(A, t)
    #t_ = np.array([[2**(-0.5), -2**(-0.5)], [2**(-0.5), 2**(-0.5)]])
    
    # -1.0 correlation is blue, 0.0 is white, 1.0 is red.
    cmap = plt.cm.Reds
    #norm = mp.colors.BoundaryNorm(np.linspace(0, 10, 14), cmap.N)
    
    # This MUST be before the call to pl.pcolormesh() to align properly.
    ax.set_xticks([])
    ax.set_yticks([])
    
    X = A[:, 1].reshape(N + 1, N + 1)
    Y = A[:, 0].reshape(N + 1, N + 1)
    caxes = plt.pcolormesh(X, Y, np.flipud(C), axes=ax, cmap=cmap, rasterized=True)
    x1s=[0]
    if len(grid_pos)&gt;0:
        for i,  grid in enumerate(grid_pos):
            x0=(grid)/(2**(0.5))
            x1=(grid)*(2**0.5)
            y0=(grid)/(2**(0.5))
            y1=0
            ax.plot([x0, x1], [y0, y1],color=&#39;gray&#39;, linewidth=1)
            ax.plot([(grid)*(2**0.5), (grid)*(2**0.5)+(N-grid)/(2**(0.5))], [0, (N-grid)/(2**(0.5))], color=&#39;gray&#39;, linewidth=1)
            x1s.append(x1)
    x1s.append(N*2**0.5)
    
    

    if len(genes) &gt;0: 
        leng=0
        for i, g in enumerate(genes):
            #ax.plot([(i+0.5)*(2**0.5), (i+0.5)*(2**0.5)], [-2**0.5, -(N/10)*2**0.5/2],color=&#39;b&#39;, linewidth=0.5)
            ax.text((i+0.5)*(2**0.5), -(N/10)*2**0.5/2*1.01, g, rotation=90,ha=&#39;center&#39;, va=&#39;top&#39;, fontsize=&#34;small&#34;)
            leng+=len(g)
        leng=leng/len(genes)
    else:
        leng=0
    spacing=(N/10)*leng*0.4
    
    
    rect=Rectangle([0, -spacing],N*(2**0.5), spacing, color=&#39;whitesmoke&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    
    rect=Rectangle([0, -(N/10)*2**0.5/2],N*(2**0.5), (N/10)*2**0.5/2, color=&#39;dimgray&#39; , alpha=1, linewidth=0)
    ax.add_patch(rect)
    
    if len(grid_labels)&gt;0:
        for i in range(len(x1s)-1):
            if i%2==1:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;silver&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            else:
                rect=Rectangle([x1s[i], -spacing],np.abs(x1s[i] - x1s[i+1]), spacing, color=&#39;lavender&#39; , alpha=0.3, linewidth=0)
                ax.add_patch(rect)
            x=(x1s[i]+x1s[i+1])/2
            ax.text(x,-(N/10)*2**0.5/4, grid_labels[i], rotation=90,ha=&#39;center&#39;, va=&#39;center&#39;, color=&#34;w&#34;)
    

    
    
    cb = plt.colorbar(caxes, ax=ax, shrink=0.75)
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;bottom&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_visible(False)
    if save!=&#34;&#34;:
        if save.endswith(&#34;.pdf&#34;) or save.endswith(&#34;.png&#34;) or save.endswith(&#34;.svg&#34;):
            plt.savefig(save)
        else:
            plt.savefig(save+&#34;_complexheatmap.pdf&#34;)
    if show:
        plt.show()
    return {&#34;axes&#34;: ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.violinplot"><code class="name flex">
<span>def <span class="ident">violinplot</span></span>(<span>df: pandas.core.frame.DataFrame, x: str, y: str, pairs: list = [], test: str = 'ttest_ind', alternative: str = 'two-sided', significance: str = 'numeric', significance_ranges: Dict[str, float] = {'*': 1.3010299956639813, '**': 4, '***': 10}, swarm: bool = False, xorder: list = [], equal_var: bool = False, yunit: str = '', title: str = '', save: str = '', ax: Optional[matplotlib.axes._axes.Axes] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a boxplot with a statistical test </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt>x,y: str</dt>
<dt>names of variables in data</dt>
<dt><strong><code>pairs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Category pairs for the statistical test.
Examples: [["Adelie","Chinstrap" ],
["Gentoo","Chinstrap" ],
["Adelie","Gentoo" ]]</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method name for the statistical test. Defalt: ttest_ind
Available methods: ["ttest_ind",
"ttest_rel",
"kruskal",
"mannwhitneyu",
"wilcoxon",
"brunnermunzel",
"median_test"]</dd>
<dt><strong><code>alternative</code></strong> :&ensp;<code>str ['two-sided', 'less', 'greater']</code>, optional</dt>
<dd>Defines the alternative hypothesis. Defalt: "two-sided"</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>significance</code></strong> :&ensp;<code>str ['numeric', 'symbol']</code>, optional</dt>
<dd>How to show the significance. 'numeric' will show -log10(p values) in the plot and
'symbol' will represent significance as asterisks.</dd>
<dt><strong><code>significance_ranges</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>thresholds of -log10(p values) that each asterisk number represents. Ignored when
significance="numeric".
example: {"<em>":-np.log10(0.05),"</em><em>":4,"</em>**":10}</dd>
<dt><strong><code>swarm</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to superpose a swarm plot. Not recommended if the sample size is too large.</dd>
<dt><strong><code>xorder</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The order of x axis labels</dd>
<dt><strong><code>equal_var</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Related to ttest_ind method. The default is True, which will produce a p value equal to t-test in R.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any options accepted by scipy statistical test functions</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict("p values":pvalues,"axes":ax)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def violinplot(df: pd.DataFrame, 
               x: str, 
               y: str,
               pairs: list=[], 
               test: str=&#34;ttest_ind&#34;,
               alternative: str=&#34;two-sided&#34;,
               significance: str=&#34;numeric&#34;,
               significance_ranges: Dict[str, float]={&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10},
               swarm: bool=False,
               xorder: list=[],
               equal_var: bool=False, 
               yunit: str=&#34;&#34;,
               title: str=&#34;&#34;,
               save: str=&#34;&#34;,
               ax: Optional[plt.Axes]=None,**kwargs):
    &#34;&#34;&#34;
    Draw a boxplot with a statistical test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x,y: str
        names of variables in data
    pairs: list, optional
        Category pairs for the statistical test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    test: str, optional
        Method name for the statistical test. Defalt: ttest_ind
        Available methods: [&#34;ttest_ind&#34;,
                            &#34;ttest_rel&#34;,
                            &#34;kruskal&#34;,
                            &#34;mannwhitneyu&#34;,
                            &#34;wilcoxon&#34;,
                            &#34;brunnermunzel&#34;,
                            &#34;median_test&#34;]
    alternative: str [&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;], optional
        Defines the alternative hypothesis. Defalt: &#34;two-sided&#34;
    
    show : bool, optional
        Whether or not to show the figure.
    significance: str [&#39;numeric&#39;, &#39;symbol&#39;], optional
        How to show the significance. &#39;numeric&#39; will show -log10(p values) in the plot and 
        &#39;symbol&#39; will represent significance as asterisks.
    significance_ranges: dict, optional 
        thresholds of -log10(p values) that each asterisk number represents. Ignored when  significance=&#34;numeric&#34;.
        example: {&#34;*&#34;:-np.log10(0.05),&#34;**&#34;:4,&#34;***&#34;:10}
    swarm: bool, optional
        Whether or not to superpose a swarm plot. Not recommended if the sample size is too large.
    xorder: list, optional
        The order of x axis labels
    equal_var: bool, optional
        Related to ttest_ind method. The default is True, which will produce a p value equal to t-test in R.
    kwargs: any options accepted by scipy statistical test functions
    
     
    Returns
    -------
    dict(&#34;p values&#34;:pvalues,&#34;axes&#34;:ax)
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    tests=[&#34;ttest_ind&#34;,&#34;ttest_rel&#34;,&#34;kruskal&#34;,&#34;mannwhitneyu&#34;,&#34;wilcoxon&#34;,&#34;brunnermunzel&#34;,&#34;median_test&#34;]
    if not test in tests:
        raise Exception(&#34;Available tests are &#34;+&#34;, &#34;.join(tests))
    import scipy.stats as stats
    if len(xorder)==0:
        xorder=sorted(list(set(df[x])))
    pvals=[]
    for p1,p2 in pairs:
        
        statstest=getattr(stats, test)
        if test==&#34;wilcoxon&#34; or test==&#34;ttest_rel&#34;:
            _, pval,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;median_test&#34;:
            _, pval,_,_=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        elif test==&#34;ttest_ind&#34;:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,equal_var=equal_var,**kwargs)
        
        else:
            _, pval=statstest(df[y][df[x]==p1],df[y][df[x]==p2],alternative=alternative,**kwargs)
        
        p1ind=xorder.index(p1)
        p2ind=xorder.index(p2)
        if pval==0:
            pval=np.inf
        else:
            pval=-np.log10(pval)
        pvals.append([np.abs(p2ind-p1ind), np.amin([p2ind, p1ind]),np.amax([p2ind, p1ind]), pval])
    pvals = sorted(pvals, key = lambda x: (x[0], x[1]))
        
    fig, ax=plt.subplots()
    sns.violinplot(data=df, x=x,y=y,inner=&#34;quartile&#34;)
    if swarm==True:
        sns.swarmplot(data=df, x=x,y=y,color=&#34;black&#34;,alpha=0.5)
    ymax=np.amax(df[y])
    newpvals={}
    for i, pval in enumerate(pvals):
        plt.plot([pval[1],pval[2]], [ymax*(1.05+i*0.05),ymax*(1.05+i*0.05)], color=&#34;black&#34;)
        p=np.round(pval[-1],2)
        
        newpvals[xorder[pval[1]]+&#34;_&#34;+xorder[pval[2]]]=p
        if significance==&#34;numeric&#34;:
            annotate=&#34;-log10(p)=&#34;+str(p)
        elif significance==&#34;symbol&#34;:
            keys=sorted(significance_ranges.keys())
            annotate=&#34;NA&#34;
            for j in range(len(keys)):
                if j==0:
                    if p &lt;= significance_ranges[keys[j]]:
                        annotate=&#34;&#34;
                        break
                else:
                    if significance_ranges[keys[j-1]] &lt; p &lt;=significance_ranges[keys[j]]:
                        annotate=keys[i]
                        break
            if annotate==&#34;NA&#34;:
                annotate=keys[-1]
        plt.text((pval[1]+pval[2])/2, ymax*(1.055+i*0.05), annotate)
    if significance==&#34;symbol&#34;:
        ax.annotate(&#34;\n&#34;.join([&#34;{}: p &lt; {:.2E}&#34;.format(k, 10**(-significance_ranges[k])) for k in keys]),
            xy=(0.9,0.9), xycoords=&#39;axes fraction&#39;,
            textcoords=&#39;offset points&#39;,
            size=12,
            bbox=dict(boxstyle=&#34;round&#34;, fc=(0.9, 0.9, 0.9), ec=&#34;none&#34;))
        plt.subplots_adjust(right=0.850)
    
    if yunit!=&#34;&#34;:
        ax.text(0, 1, &#34;({})&#34;.format(yunit), transform=ax.transAxes, ha=&#34;right&#34;)
        
    _save(save, &#34;violin&#34;)
    
    return {&#34;p values&#34;:newpvals,&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.plot.volcanoplot"><code class="name flex">
<span>def <span class="ident">volcanoplot</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volcanoplot():
    pass</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="omniplot" href="index.html">omniplot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="omniplot.plot.complex_clustermap" href="#omniplot.plot.complex_clustermap">complex_clustermap</a></code></li>
<li><code><a title="omniplot.plot.correlation" href="#omniplot.plot.correlation">correlation</a></code></li>
<li><code><a title="omniplot.plot.dotplot" href="#omniplot.plot.dotplot">dotplot</a></code></li>
<li><code><a title="omniplot.plot.radialtree" href="#omniplot.plot.radialtree">radialtree</a></code></li>
<li><code><a title="omniplot.plot.triangle_heatmap" href="#omniplot.plot.triangle_heatmap">triangle_heatmap</a></code></li>
<li><code><a title="omniplot.plot.violinplot" href="#omniplot.plot.violinplot">violinplot</a></code></li>
<li><code><a title="omniplot.plot.volcanoplot" href="#omniplot.plot.volcanoplot">volcanoplot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>