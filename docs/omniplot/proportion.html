<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>omniplot.proportion API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>omniplot.proportion</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Union, Optional, Dict, List
import matplotlib.collections as mc
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd
from matplotlib import cm
from matplotlib.lines import Line2D
from scipy.cluster.hierarchy import leaves_list
from scipy.cluster import hierarchy
from collections import defaultdict
import matplotlib.colors
from natsort import natsort_keygen
from matplotlib.patches import Rectangle
import scipy.cluster.hierarchy as sch
import fastcluster as fcl

import sys 
import matplotlib as mpl
from sklearn.cluster import KMeans, DBSCAN
from sklearn.metrics import silhouette_score
from scipy.spatial.distance import pdist, squareform
from sklearn.decomposition import PCA, NMF, LatentDirichletAllocation
from scipy.stats import fisher_exact
from scipy.stats import zscore
from itertools import combinations
import os
#script_dir = os.path.dirname( __file__ )
#sys.path.append( script_dir )
from omniplot.utils import * #
import scipy.stats as stats
from joblib import Parallel, delayed
from omniplot.chipseq_utils import _calc_pearson
import itertools as it
from omniplot.scatter import *
colormap_list: list=[&#34;nipy_spectral&#34;, &#34;terrain&#34;,&#34;tab20b&#34;,&#34;tab20c&#34;,&#34;gist_rainbow&#34;,&#34;hsv&#34;,&#34;CMRmap&#34;,&#34;coolwarm&#34;,&#34;gnuplot&#34;,&#34;gist_stern&#34;,&#34;brg&#34;,&#34;rainbow&#34;,&#34;jet&#34;]
hatch_list: list = [&#39;//&#39;, &#39;\\\\&#39;, &#39;||&#39;, &#39;--&#39;, &#39;++&#39;, &#39;xx&#39;, &#39;oo&#39;, &#39;OO&#39;, &#39;..&#39;, &#39;**&#39;,&#39;/o&#39;, &#39;\\|&#39;, &#39;|*&#39;, &#39;-\\&#39;, &#39;+o&#39;, &#39;x*&#39;, &#39;o-&#39;, &#39;O|&#39;, &#39;O.&#39;, &#39;*-&#39;]
maker_list: list=[&#39;.&#39;, &#39;_&#39; , &#39;+&#39;,&#39;|&#39;, &#39;x&#39;, &#39;v&#39;, &#39;^&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;s&#39;, &#39;p&#39;, &#39;*&#39;, &#39;h&#39;, &#39;D&#39;, &#39;d&#39;, &#39;P&#39;, &#39;X&#39;,&#39;o&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;,&#39;|&#39;, &#39;_&#39;]

plt.rcParams[&#39;font.family&#39;]= &#39;sans-serif&#39;
plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Arial&#39;]
plt.rcParams[&#39;svg.fonttype&#39;] = &#39;none&#39;
sns.set_theme(font=&#34;Arial&#34;)

__all__=[&#34;stacked_barplot&#34;,&#34;nice_piechart&#34;,&#34;nice_piechart_num&#34;,&#34;stackedlines&#34;]

def _stacked_barplot(df: pd.DataFrame,
                    x: Union[str, list],
                    hue: Union[str, list],
                    scale: str=&#34;fraction&#34;,
                    order: list=[],
                    hue_order: list=[],
                    test_pairs: List[List[str]]=[],
                    show_values: bool=True,
                    show: bool=False,
                    figsize: List[int]=[4,6],
                    xunit: str=&#34;&#34;,
                    yunit: str=&#34;&#34;,
                    title: str=&#34;&#34;,
                    hatch: bool=False)-&gt; Dict:
    
    &#34;&#34;&#34;
    Drawing a stacked barplot with or without the fisher&#39;s exact test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str or list
        The category to place in x axis. Only str values are accepted.
    hue: str or list
        Counting samples by the hue category. Only str values are accepted.
    order: list, optional
        The order of x axis labels
    hue_order: list, optional
        The order of hue labels
    scale: str, optional
        Scaling method. Available options are: fraction, percentage, absolute
    test_pairs : pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    show_values: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    show : bool, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
     
    Returns
    -------
    dict(&#34;p values&#34;:pvalues,&#34;axes&#34;:ax)
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    data: Dict={}
    
    if df[x].isnull().values.any():
        df[x]=df[x].replace(np.nan, &#34;NA&#34;)
    
    if df[hue].isnull().values.any():
        df[hue]=df[hue].replace(np.nan, &#34;NA&#34;)
    
    
    if len(order)==0:
        u=np.unique(df[x])
        keys=sorted(list(u))
    else:
        keys=order
    if len(hue_order)==0:
        u=np.unique(df[hue])
        hues=sorted(list(u))
    else:
    
        hues=hue_order
    for key in keys:
        data[key]=[]
        for h in hues:
            data[key].append(np.sum((df[x]==key) &amp; (df[hue]==h)))
    pvals={}
    if len(test_pairs) &gt;0:
        
        for i, h in enumerate(hues):
            pvals[h]=[]
            for p1,p2 in test_pairs:
                idx1=keys.index(p1)
                idx2=keys.index(p2)
                yes_total=np.sum(data[keys[idx1]])
                no_total=np.sum(data[keys[idx2]])
                yes_and_hue=data[keys[idx1]][i]
                no_and_hue=data[keys[idx2]][i]
                table=[[yes_and_hue, no_and_hue],
                       [yes_total-yes_and_hue, no_total-no_and_hue]]
                
                odd, pval=fisher_exact(table)
                pvals[h].append([idx1, idx2, pval])
    if scale==&#34;fraction&#34;:
        for key in keys:
            data[key]=np.array(data[key])/np.sum(data[key])
    elif scale==&#34;percentage&#34;:
        for key in keys:
            data[key]=np.array(data[key])/np.sum(data[key])*100
    bottom=np.zeros([len(keys)])
    cmap=plt.get_cmap(&#34;tab20b&#34;)
    fig, ax=plt.subplots(figsize=figsize)
    plt.subplots_adjust(left=0.2,right=0.6, bottom=0.17)
    if scale==&#34;absolute&#34;:
        unit=&#34;&#34;
    elif scale==&#34;fraction&#34;:
        unit=&#34;&#34;
    elif scale==&#34;percentage&#34;:
        unit=&#34;%&#34;
    pos={}
    #_hatch_list=[hatch_list[i] for i in range(len(keys))]
    for i, h in enumerate(hues):
        
        heights=np.array([data[key][i] for key in keys])
        
        if hatch==True:
            plt.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h, hatch=hatch_list[i])
        else:
            plt.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h)
        if show_values==True:
            for j in range(len(keys)):
                if scale==&#34;absolute&#34;:
                    plt.text(j,bottom[j]+heights[j]/2,&#34;{}{}&#34;.format(heights[j],unit), 
                         bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                else:
                    plt.text(j,bottom[j]+heights[j]/2,&#34;{:.2f}{}&#34;.format(heights[j],unit), 
                         bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
        plt.xticks(rotation=90)
        pos[h]={key: [he, bo] for key, he, bo in zip(keys, heights, bottom)}
        bottom+=heights
    ax.legend(loc=[1.01,0])
    ax.set_xlabel(x)
    if scale==&#34;absolute&#34;:
        ylabel=&#34;Counts&#34;
    elif scale==&#34;fraction&#34;:
        ylabel=&#34;Fraction&#34;
    elif scale==&#34;percentage&#34;:
        ylabel=&#34;Percentage&#34;
    ax.set_ylabel(ylabel)
    
    if len(pvals)&gt;0:
        print(&#34;mlp stands for -log10(p value)&#34;)
        for i, h in enumerate(hues):
            _pos=pos[h]
            for idx1, idx2, pval in pvals[h]:
                if pval &lt; 0.05:
                    he1, bot1=_pos[keys[idx1]]
                    he2, bot2=_pos[keys[idx2]]
                    line, =plt.plot([idx1,idx2],[he1/2+bot1,he2/2+bot2],color=&#34;gray&#34;)
                    # r1=ax.transData.transform([idx1, he1/2+bot1])
                    # r2=ax.transData.transform([idx2, he2/2+bot2])
                    r1=np.array([idx1, he1/2+bot1])
                    r2=np.array([idx2, he2/2+bot2])
                    r=r2-r1
                    print(ax.get_xlim(),ax.get_ylim())
                    r=np.array([1,3])*r/np.array([ax.get_xlim()[1]-ax.get_xlim()[0],ax.get_ylim()[1]-ax.get_ylim()[0]])
                    #r=ax.transData.transform(r)
                    if idx2&lt;idx1:
                        r=-r
                    print(r)
                    r=r*(r @ r)**(-0.5)
                    print(h,r)
                    angle=np.arccos(r[0])
                    if r[1]&lt;0:
                        angle= -angle
                    print(angle)
                    _line_annotate( &#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)), line, (idx1+idx2)/2, color=&#34;magenta&#34;)
                    # plt.text((idx1+idx2)/2, 0.5*(he1/2+bot1+he2/2+bot2), &#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)), 
                    #          color=&#34;magenta&#34;, va=&#34;center&#34;,ha=&#34;center&#34;, rotation=360*angle/(2*np.pi),)
                    # plt.annotate(&#34;mlp=&#34;+str(np.round(-np.log10(pval), decimals=1)),[(r1[0]+r2[0])/2, 0.5*(r1[1]+r2[1])],   
                    #          color=&#34;magenta&#34;,ha=&#34;center&#34;, rotation=360*angle/(2*np.pi),xycoords=&#39;figure pixels&#39;)
                    #
    if show:
        plt.show()
    if title !=&#34;&#34;:
        fig.suptitle(title)
    return {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}


def stacked_barplot(df: pd.DataFrame,
                    x: Union[str, list],
                    hue: Union[str, list],
                    scale: str=&#34;fraction&#34;,
                    order: Optional[list]=None,
                    hue_order: Optional[list]=None,
                    test_pairs: List[List[str]]=[],
                    palette: Union[str,dict]=&#34;tab20c&#34;,
                    show_values: bool=True,
                    show: bool=False,
                    figsize: List[int]=[],
                    xunit: str=&#34;&#34;,
                    yunit: str=&#34;&#34;,
                    title: str=&#34;&#34;,
                    hatch: bool=False,
                    rotation: int=90,
                    ax: Optional[plt.Axes]=None,
                    show_legend:bool=True)-&gt; Dict:
    
    &#34;&#34;&#34;
    Drawing a stacked barplot with or without the fisher&#39;s exact test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str or list
        The category to place in x axis. Multiple categories can be passed by a list.
    hue: str or list
        Counting samples by the hue category. Multiple categories can be passed by a list.
    order: list, optional
        The order of x axis labels
    hue_order: list, optional
        The order of hue labels
    scale: str, optional
        Scaling method. Available options are: fraction, percentage, absolute
    test_pairs : list, optional
        pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    palette : str or dict, optional (default: &#34;tab20c&#34;)
        A matplotlib colormap name or dictionary in which keys are values of the hue category and values are RGB array.
        e.g.) palette={&#34;&#34;}
    show_values: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    show : bool, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
     
    Returns
    -------
    dict {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    if type(x)==str:
        x=[x]
        if order!=None:
            order=[order]
    if type(hue)==str:
        hue=[hue]
        if hue_order!=None:
            hue_order=[hue_order]
    for _x in x:
        if df[_x].isnull().values.any():
            df[_x]=df[_x].replace(np.nan, &#34;NA&#34;)
    for _hue in hue:
        if df[_hue].isnull().values.any():
            df[_hue]=df[_hue].replace(np.nan, &#34;NA&#34;)

    xkeys={}
    keysx={}
    meankey_len=0
    for i, _x in enumerate(x):
        if order==None:
            u=np.unique(df[_x])
            keys=sorted(list(u))
        else:
            keys=order[i]
        meankey_len+=len(keys)
        xkeys[_x]=keys
        for k in keys:
            keysx[k]=_x
    meankey_len=meankey_len//len(x)
    huekeys={}
    for i, _hue in enumerate(hue):
        if hue_order==None:
            u=np.unique(df[_hue])
            hues=sorted(list(u))
        else:
        
            hues=hue_order[i]
        huekeys[_hue]=hues
    
    data={}
    for _x, keys in xkeys.items():
        data[_x]={}
        for key in keys:
            
            for _hue, hues in  huekeys.items():
                if _x==_hue:
                    continue
                if not _hue in data[_x]:
                    data[_x][_hue]={}
                data[_x][_hue][key]=[]
                for h in hues:
                    data[_x][_hue][key].append(np.sum((df[_x]==key) &amp; (df[_hue]==h)))

    
    pvals={}
    if len(test_pairs) &gt;0:
        print(&#34;mlp stands for -log10(p value)&#34;)
        for _hue in hue:
            
            for i, h in enumerate(huekeys[_hue]):
                
                for p1,p2 in test_pairs:
                    _x=keysx[p1]
                    __x=keysx[p2]
                    if _x!=__x:
                        raise Exception(&#34;{} and {} can not be compared.&#34;.format(p1, p2))
                    
                    if _x==_hue:
                        continue
                    
                    if not _x in pvals:
                        pvals[_x]={}
                    if not _hue in pvals[_x]:
                        pvals[_x][_hue]={}
                    if not h in pvals[_x][_hue]:
                        pvals[_x][_hue][h]=[]
                    keys=xkeys[_x]
                    idx1=xkeys[_x].index(p1)
                    idx2=xkeys[_x].index(p2)
                    yes_total=np.sum(data[_x][_hue][keys[idx1]])
                    no_total=np.sum(data[_x][_hue][keys[idx2]])
                    yes_and_hue=data[_x][_hue][keys[idx1]][i]
                    no_and_hue=data[_x][_hue][keys[idx2]][i]
                    table=[[yes_and_hue, no_and_hue],
                           [yes_total-yes_and_hue, no_total-no_and_hue]]
        
                    odd, pval=fisher_exact(table)
                    pvals[_x][_hue][h].append([idx1, idx2, pval])
    if scale==&#34;fraction&#34;:
        for _x in x:
            for _hue in hue:
                if _x==_hue:
                    continue
                for key in keys:
                    data[_x][_hue][key]=np.array(data[_x][_hue][key])/np.sum(data[_x][_hue][key])
    elif scale==&#34;percentage&#34;:
        for _x in x:
            for _hue in hue:
                if _x==_hue:
                    continue
                for key in keys:
                    data[_x][_hue][key]=np.array(data[_x][_hue][key])/np.sum(data[_x][_hue][key])*100
    if type(palette)==str:
        cmap=plt.get_cmap(palette)
        
    ncols=len(x)*len(hue)-len(set(x)&amp;set(hue))
    if ncols&lt;1:
        ncols=1
    if len(figsize)==0:
        figsize=[(4+0.1*meankey_len)*ncols, 6]
    if ax!=None:
        axes=ax
        fig=None
    else:
        fig, axes=plt.subplots(figsize=figsize,ncols=ncols)
    
    if ncols==1:
        axes=[axes]
    else:
        axes=axes.flatten()
    
    if scale==&#34;absolute&#34;:
        unit=&#34;&#34;
    elif scale==&#34;fraction&#34;:
        unit=&#34;&#34;
    elif scale==&#34;percentage&#34;:
        unit=&#34;%&#34;
    axindex=0
    pos={}
    #_hatch_list=[hatch_list[i] for i in range(len(keys))]
    for _x in x:
        pos[_x]={}
        for _hue in hue:
            if _x==_hue:
                continue
            pos[_x][_hue]={}
            keys=xkeys[_x]
            hues=huekeys[_hue]
            bottom=np.zeros([len(keys)])
            for i, h in enumerate(hues):
                ax=axes[axindex]
                
                heights=np.array([data[_x][_hue][key][i] for key in keys])
                
                if type(palette)==dict:
                    if hatch==True:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=palette[h], label=h, hatch=hatch_list[i])
                    else:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=palette[h], label=h)
                else:
                    if hatch==True:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h, hatch=hatch_list[i])
                    else:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h)
                if show_values==True:
                    for j in range(len(keys)):
                        if scale==&#34;absolute&#34;:
                            ax.text(j,bottom[j]+heights[j]/2,&#34;{}{}&#34;.format(heights[j],unit), 
                                 bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                        else:
                            ax.text(j,bottom[j]+heights[j]/2,&#34;{:.2f}{}&#34;.format(heights[j],unit), 
                                 bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                
                pos[_x][_hue][h]={key: [he, bo] for key, he, bo in zip(keys, heights, bottom)}
                bottom+=heights
            ax.set_xticks(ax.get_xticks(), labels=keys, rotation=rotation)
            #ax.set_xticklabels(ax.get_xticklabels(), rotation=90)
            if show_legend==True:
                ax.legend(loc=[1.01,0])
            ax.set_xlabel(_x)
            if scale==&#34;absolute&#34;:
                ylabel=&#34;Counts&#34;
            elif scale==&#34;fraction&#34;:
                ylabel=&#34;Fraction&#34;
            elif scale==&#34;percentage&#34;:
                ylabel=&#34;Percentage&#34;
            ax.set_ylabel(ylabel)
            axindex+=1
            if len(pvals)&gt;0 and _x in pvals:
                
                for _hue in hue:
                    if _x==_hue:
                        continue
                    if not _hue in pos[_x]:
                        continue
                    hues=huekeys[_hue]
                    for i, h in enumerate(hues):
                        #print(pos)
                        #print(pos[_x])
                        _pos=pos[_x][_hue][h]
                        for idx1, idx2, pval in pvals[_x][_hue][h]:
                            
                            he1, bot1=_pos[keys[idx1]]
                            he2, bot2=_pos[keys[idx2]]
                            line, =ax.plot([idx1,idx2],[he1/2+bot1,he2/2+bot2],color=&#34;gray&#34;)
                            # r1=ax.transData.transform([idx1, he1/2+bot1])
                            # r2=ax.transData.transform([idx2, he2/2+bot2])
                            r1=np.array([idx1, he1/2+bot1])
                            r2=np.array([idx2, he2/2+bot2])
                            r=r2-r1
                            #print(ax.get_xlim(),ax.get_ylim())
                            r=np.array([1,3])*r/np.array([ax.get_xlim()[1]-ax.get_xlim()[0],ax.get_ylim()[1]-ax.get_ylim()[0]])
                            #r=ax.transData.transform(r)
                            if idx2&lt;idx1:
                                r=-r
                            #print(r)
                            r=r*(r @ r)**(-0.5)
                            #print(h,r)
                            angle=np.arccos(r[0])
                            if r[1]&lt;0:
                                angle= -angle
                            #print(angle)
                            if pval &lt; 0.05:
                                pval_str=str(np.round(-np.log10(pval), decimals=1))
                            else:
                                pval_str=&#34;ns&#34;
                            _line_annotate( &#34;mlp=&#34;+pval_str, line, (idx1+idx2)/2, color=&#34;magenta&#34;)
    if len(x)==1 and len(hue)==1:
        plt.subplots_adjust(top=0.93,left=0.1,right=0.7, bottom=0.17)                            
    else:
        plt.tight_layout(w_pad=2)
    
    if title !=&#34;&#34; and fig !=None:
        fig.suptitle(title)
    if show:
        plt.show()
    return {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}


def nice_piechart(df: pd.DataFrame, 
                  category: Union[str, List[str]],
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True,title: str=&#34;&#34;,) -&gt;Dict:
    
    if type(category)==str:
        category=[category]
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=[ncols*2,
                                                        nrows*2])
    axes=axes.flatten()
    for cat, ax in zip(category, axes):
        u, c=np.unique(df[cat], return_counts=True)
        
        srt=np.argsort(c)[::-1]
        u=u[srt]
        c=c[srt]
        _c=c/np.sum(c)
        
        
        
        _cmap=plt.get_cmap(palette, c.shape[0])
        colors=[_cmap(i) for i in range(c.shape[0])]
        for j in range(c.shape[0]):
            if _c[j]&lt;ignore:
                colors[j]=[0,0,0,1]
                u[j]=&#34;&#34;
                continue
            if show_values==True:
                u[j]=u[j]+&#34;\n(&#34;+str(100*np.round(_c[j],1))+&#34;%)&#34;
        
        ax.pie(c, labels=u, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=10)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.9)
    return {&#34;axes&#34;:ax}


def nice_piechart_num(df: pd.DataFrame,hue: List[str],
                      category: str=&#34;&#34; ,
                  
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True,
                  title: str=&#34;&#34;,
                  figsize=[]) -&gt;Dict:
    
    if category==&#34;&#34;:
        category=list(df.index)
    else:
        df=df.set_index(category)
        category=list(df.index)
        
    df=df[hue]
    srt=np.argsort(df.sum(axis=0))[::-1]
    df=df[df.columns[srt]]
    hue=list(df.columns)
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    if len(figsize)==0:
        figsize=[ncols*2,nrows*2]
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize)
    axes=axes.flatten()
    _cmap=plt.get_cmap(palette, len(hue))
    colors=[_cmap(i) for i in range(len(hue))]
    for cat, ax in zip(category, axes):
        c=df.loc[cat]
        _c=c/np.sum(c)
        ax.pie(c, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=8)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.95, right=0.81)
    
    legend_elements = [Line2D([0], [0], marker=&#39;o&#39;, color=&#39;lavender&#39;, label=huelabel,markerfacecolor=color, markersize=10)
                      for color, huelabel in zip(colors, hue)]
    
    fig.legend(handles=legend_elements,bbox_to_anchor=(1, 1))
    return {&#34;axes&#34;:ax}


def stackedlines(df: pd.DataFrame, 
                x: str,
                y: list,
                sort: bool=True,
                inverse: bool=False,
                show_values: bool=False,
                remove_all_zero: bool=False,
                palette: str=&#34;tab20c&#34;,
                figsize=[7,4],
                ax: Optional[plt.Axes]=None,
                alpha: float=0.75,
                bbox_to_anchor: list=[1.7, 1],
                right: float=0.7,
                bottom: float=0.120,
                show_legend: bool=True,
                xlabel: str=&#34;&#34;,
                ylabel: str=&#34;&#34;,
                yunit: str=&#34;&#34;,
                xunit: str=&#34;&#34;,
                title: str=&#34;&#34;,
                hatch: bool=False):
    &#34;&#34;&#34;
    Drawing a scatter plot of which points are represented by pie charts. 
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide form dataframe. Index names are used to label points. It accepts negative values, but not recommended as 
        it does not make sense.
        e.g.) 
              year    biofuel_consumption    coal_consumption    gas_consumption    hydro_consumption    nuclear_consumption    oil_consumption
        90    1990                 16.733            5337.998           5170.609              864.271               1723.004           9306.913
        91    1991                 19.389            5287.613           5283.972              849.620               1829.645           9108.509
        92    1992                 22.045            5324.031           5463.509              743.463               1848.197           9297.387
        93    1993                 25.759            5522.452           5599.419              825.742               1822.853           9376.045
        94    1994                 28.846            5543.144           5731.081              766.870               1912.903           9619.746
        95    1995                 30.942            5593.053           5979.829              920.274               2011.356           9597.527            
    x : str
        the name of a column to be the x axis of the plot.
        
    y: list
        the names of values to display as stacked lines
    sort: bool, optional (default: True)
        Whether to sort lines based on their values
    show_values: bool, optional (default: False)
        Whether to show percentages at the end of lines.
    
    remove_all_zero: bool, optional (default: False)    
    
    pie_palette : str
        A colormap name
    xlabel: str, optional
        x axis label
    ylabel: str, optional
        y axis label
    ax: Optional[plt.Axes] optional, (default: None)
        pyplot ax to add this scatter plot


    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    df=df.fillna(0)
    X=np.array(df[x])
    Y=[]
    for col in y:
        Y.append(np.array(df[col]))
    Y=np.array(Y)
    if remove_all_zero==True:
        _filter=Y.sum(axis=0)!=0
        Y=Y[:,_filter]
        X=X[_filter]
    Ydict={col:[] for col in y}
    if sort==True:
        
        if inverse==True:
            for i, _x in enumerate(X):
                _Y=Y[:,i]
                srtidx=np.argsort(_Y)[::-1]
                _bottom=0
                _bottom_neg=0
                for _idx in srtidx:
                    _col=y[_idx]
                    yval=Y[_idx,i]
                    if yval&gt;=0:
                        Ydict[_col].append([_bottom, yval+_bottom])
                        _bottom+=yval
                    else:
                        Ydict[_col].append([_bottom_neg, yval+_bottom_neg])
                        _bottom_neg+=yval
        else:
            for i, _x in enumerate(X):
                _Y=Y[:,i]
                srtidx=np.argsort(_Y)
                _bottom=0
                _bottom_neg=0
                for _idx in srtidx:
                    _col=y[_idx]
                    yval=Y[_idx,i]
                    if yval&gt;=0:
                        Ydict[_col].append([_bottom, yval+_bottom])
                        _bottom+=yval
                    else:
                        Ydict[_col].append([_bottom_neg, yval+_bottom_neg])
                        _bottom_neg+=yval
    else:
        for i, _x in enumerate(X):
            _Y=Y[:,i]
            _bottom=0
            _bottom_neg=0
            for _idx,_col in enumerate(y):
                yval=Y[_idx,i]
                if yval&gt;=0:
                    Ydict[_col].append([_bottom, yval+_bottom])
                    _bottom+=yval
                else:
                    Ydict[_col].append([_bottom_neg, yval+_bottom_neg])
                    _bottom_neg+=yval
    if ax ==None:
        fig, ax=plt.subplots(figsize=figsize)
        
    cmap=plt.get_cmap(palette, len(y))
    colorlut={col: cmap(i) for i, col in enumerate(y)}
    last_vals=[]
    last_pos=[]
    i=0
    for col, vals in Ydict.items():
        vals=np.array(vals)
        if hatch==True:
            ax.fill_between(X, vals[:,0], vals[:,1], label=col, alpha=alpha, color=colorlut[col], hatch=hatch_list[i])
        else:
            ax.fill_between(X, vals[:,0], vals[:,1], label=col, alpha=alpha, color=colorlut[col])
        last_vals.append(vals[-1,1]-vals[-1,0])
        last_pos.append(vals[-1,1]/2+vals[-1,0]/2)
        i+=1
    if show_values==True:
        last_vals=100*np.array(last_vals)/np.sum(last_vals)
        for val, pos in zip(last_vals, last_pos):
            ax.text(X[-1], pos, str(np.round(val, 1))+&#34;%&#34;)
            
    if show_legend==True:
        plt.legend(bbox_to_anchor=bbox_to_anchor)
    plt.subplots_adjust(right=right, bottom=bottom)
    if xlabel !=&#34;&#34;:
        ax.set_xlabel(xlabel)
    else:
        ax.set_xlabel(x)
    ax.set_ylabel(ylabel)
    ax.set_title(title)
    if yunit!=&#34;&#34;:
        ax.text(0, 1, &#34;({})&#34;.format(yunit), transform=ax.transAxes, ha=&#34;right&#34;)
    if xunit!=&#34;&#34;:
        ax.text(1, 0, &#34;({})&#34;.format(xunit), transform=ax.transAxes, ha=&#34;left&#34;,va=&#34;top&#34;)
    if inverse==True:
        ax.invert_yaxis()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="omniplot.proportion.nice_piechart"><code class="name flex">
<span>def <span class="ident">nice_piechart</span></span>(<span>df: pandas.core.frame.DataFrame, category: Union[str, List[str]], palette: str = 'tab20c', ncols: int = 2, ignore: float = 0.05, show_values: bool = True, title: str = '') ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nice_piechart(df: pd.DataFrame, 
                  category: Union[str, List[str]],
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True,title: str=&#34;&#34;,) -&gt;Dict:
    
    if type(category)==str:
        category=[category]
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=[ncols*2,
                                                        nrows*2])
    axes=axes.flatten()
    for cat, ax in zip(category, axes):
        u, c=np.unique(df[cat], return_counts=True)
        
        srt=np.argsort(c)[::-1]
        u=u[srt]
        c=c[srt]
        _c=c/np.sum(c)
        
        
        
        _cmap=plt.get_cmap(palette, c.shape[0])
        colors=[_cmap(i) for i in range(c.shape[0])]
        for j in range(c.shape[0]):
            if _c[j]&lt;ignore:
                colors[j]=[0,0,0,1]
                u[j]=&#34;&#34;
                continue
            if show_values==True:
                u[j]=u[j]+&#34;\n(&#34;+str(100*np.round(_c[j],1))+&#34;%)&#34;
        
        ax.pie(c, labels=u, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=10)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.9)
    return {&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.proportion.nice_piechart_num"><code class="name flex">
<span>def <span class="ident">nice_piechart_num</span></span>(<span>df: pandas.core.frame.DataFrame, hue: List[str], category: str = '', palette: str = 'tab20c', ncols: int = 2, ignore: float = 0.05, show_values: bool = True, title: str = '', figsize=[]) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nice_piechart_num(df: pd.DataFrame,hue: List[str],
                      category: str=&#34;&#34; ,
                  
                  palette: str=&#34;tab20c&#34;,
                  ncols: int=2,
                  ignore: float=0.05,
                  show_values: bool=True,
                  title: str=&#34;&#34;,
                  figsize=[]) -&gt;Dict:
    
    if category==&#34;&#34;:
        category=list(df.index)
    else:
        df=df.set_index(category)
        category=list(df.index)
        
    df=df[hue]
    srt=np.argsort(df.sum(axis=0))[::-1]
    df=df[df.columns[srt]]
    hue=list(df.columns)
    nrows=len(category)//ncols+int(len(category)%ncols!=0)
    if len(figsize)==0:
        figsize=[ncols*2,nrows*2]
    fig, axes=plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize)
    axes=axes.flatten()
    _cmap=plt.get_cmap(palette, len(hue))
    colors=[_cmap(i) for i in range(len(hue))]
    for cat, ax in zip(category, axes):
        c=df.loc[cat]
        _c=c/np.sum(c)
        ax.pie(c, 
               counterclock=False,
               startangle=90, 
               colors=colors,
               labeldistance=0.6,
               radius=1.25)
        ax.set_title(cat,backgroundcolor=&#39;lavender&#39;,pad=8)
    if len(category)%ncols!=0:
        for i in range(len(category)%ncols-2):
            fig.delaxes(axes[-(i+1)])
    plt.tight_layout(h_pad=1)
    plt.subplots_adjust(top=0.95, right=0.81)
    
    legend_elements = [Line2D([0], [0], marker=&#39;o&#39;, color=&#39;lavender&#39;, label=huelabel,markerfacecolor=color, markersize=10)
                      for color, huelabel in zip(colors, hue)]
    
    fig.legend(handles=legend_elements,bbox_to_anchor=(1, 1))
    return {&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.proportion.stacked_barplot"><code class="name flex">
<span>def <span class="ident">stacked_barplot</span></span>(<span>df: pandas.core.frame.DataFrame, x: Union[str, list], hue: Union[str, list], scale: str = 'fraction', order: Optional[list] = None, hue_order: Optional[list] = None, test_pairs: List[List[str]] = [], palette: Union[str, dict] = 'tab20c', show_values: bool = True, show: bool = False, figsize: List[int] = [], xunit: str = '', yunit: str = '', title: str = '', hatch: bool = False, rotation: int = 90, ax: Optional[matplotlib.axes._axes.Axes] = None, show_legend: bool = True) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a stacked barplot with or without the fisher's exact test </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>The category to place in x axis. Multiple categories can be passed by a list.</dd>
<dt><strong><code>hue</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>Counting samples by the hue category. Multiple categories can be passed by a list.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The order of x axis labels</dd>
<dt><strong><code>hue_order</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>The order of hue labels</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Scaling method. Available options are: fraction, percentage, absolute</dd>
<dt><strong><code>test_pairs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.
Examples: [["Adelie","Chinstrap" ],
["Gentoo","Chinstrap" ],
["Adelie","Gentoo" ]]</dd>
<dt><strong><code>palette</code></strong> :&ensp;<code>str</code> or <code>dict</code>, optional <code>(default: "tab20c")</code></dt>
<dd>A matplotlib colormap name or dictionary in which keys are values of the hue category and values are RGB array.
e.g.) palette={""}</dd>
<dt><strong><code>show_values</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheter to exhibit the values of fractions/counts/percentages.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the figure.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>List[int]</code>, optional</dt>
<dd>The figure size, e.g., [4, 6].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict {"pval":pvals,"axes":ax}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stacked_barplot(df: pd.DataFrame,
                    x: Union[str, list],
                    hue: Union[str, list],
                    scale: str=&#34;fraction&#34;,
                    order: Optional[list]=None,
                    hue_order: Optional[list]=None,
                    test_pairs: List[List[str]]=[],
                    palette: Union[str,dict]=&#34;tab20c&#34;,
                    show_values: bool=True,
                    show: bool=False,
                    figsize: List[int]=[],
                    xunit: str=&#34;&#34;,
                    yunit: str=&#34;&#34;,
                    title: str=&#34;&#34;,
                    hatch: bool=False,
                    rotation: int=90,
                    ax: Optional[plt.Axes]=None,
                    show_legend:bool=True)-&gt; Dict:
    
    &#34;&#34;&#34;
    Drawing a stacked barplot with or without the fisher&#39;s exact test 
    
    Parameters
    ----------
    df : pandas DataFrame
    
    x: str or list
        The category to place in x axis. Multiple categories can be passed by a list.
    hue: str or list
        Counting samples by the hue category. Multiple categories can be passed by a list.
    order: list, optional
        The order of x axis labels
    hue_order: list, optional
        The order of hue labels
    scale: str, optional
        Scaling method. Available options are: fraction, percentage, absolute
    test_pairs : list, optional
        pairs of categorical values related to x. It will calculate -log10 (p value) (mlp) of the fisher exact test.
        Examples: [[&#34;Adelie&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Gentoo&#34;,&#34;Chinstrap&#34; ],
                    [&#34;Adelie&#34;,&#34;Gentoo&#34; ]]
    palette : str or dict, optional (default: &#34;tab20c&#34;)
        A matplotlib colormap name or dictionary in which keys are values of the hue category and values are RGB array.
        e.g.) palette={&#34;&#34;}
    show_values: bool, optional
        Wheter to exhibit the values of fractions/counts/percentages.
    
    show : bool, optional
        Whether or not to show the figure.
    
    figsize : List[int], optional
        The figure size, e.g., [4, 6].
     
    Returns
    -------
    dict {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    
    if type(x)==str:
        x=[x]
        if order!=None:
            order=[order]
    if type(hue)==str:
        hue=[hue]
        if hue_order!=None:
            hue_order=[hue_order]
    for _x in x:
        if df[_x].isnull().values.any():
            df[_x]=df[_x].replace(np.nan, &#34;NA&#34;)
    for _hue in hue:
        if df[_hue].isnull().values.any():
            df[_hue]=df[_hue].replace(np.nan, &#34;NA&#34;)

    xkeys={}
    keysx={}
    meankey_len=0
    for i, _x in enumerate(x):
        if order==None:
            u=np.unique(df[_x])
            keys=sorted(list(u))
        else:
            keys=order[i]
        meankey_len+=len(keys)
        xkeys[_x]=keys
        for k in keys:
            keysx[k]=_x
    meankey_len=meankey_len//len(x)
    huekeys={}
    for i, _hue in enumerate(hue):
        if hue_order==None:
            u=np.unique(df[_hue])
            hues=sorted(list(u))
        else:
        
            hues=hue_order[i]
        huekeys[_hue]=hues
    
    data={}
    for _x, keys in xkeys.items():
        data[_x]={}
        for key in keys:
            
            for _hue, hues in  huekeys.items():
                if _x==_hue:
                    continue
                if not _hue in data[_x]:
                    data[_x][_hue]={}
                data[_x][_hue][key]=[]
                for h in hues:
                    data[_x][_hue][key].append(np.sum((df[_x]==key) &amp; (df[_hue]==h)))

    
    pvals={}
    if len(test_pairs) &gt;0:
        print(&#34;mlp stands for -log10(p value)&#34;)
        for _hue in hue:
            
            for i, h in enumerate(huekeys[_hue]):
                
                for p1,p2 in test_pairs:
                    _x=keysx[p1]
                    __x=keysx[p2]
                    if _x!=__x:
                        raise Exception(&#34;{} and {} can not be compared.&#34;.format(p1, p2))
                    
                    if _x==_hue:
                        continue
                    
                    if not _x in pvals:
                        pvals[_x]={}
                    if not _hue in pvals[_x]:
                        pvals[_x][_hue]={}
                    if not h in pvals[_x][_hue]:
                        pvals[_x][_hue][h]=[]
                    keys=xkeys[_x]
                    idx1=xkeys[_x].index(p1)
                    idx2=xkeys[_x].index(p2)
                    yes_total=np.sum(data[_x][_hue][keys[idx1]])
                    no_total=np.sum(data[_x][_hue][keys[idx2]])
                    yes_and_hue=data[_x][_hue][keys[idx1]][i]
                    no_and_hue=data[_x][_hue][keys[idx2]][i]
                    table=[[yes_and_hue, no_and_hue],
                           [yes_total-yes_and_hue, no_total-no_and_hue]]
        
                    odd, pval=fisher_exact(table)
                    pvals[_x][_hue][h].append([idx1, idx2, pval])
    if scale==&#34;fraction&#34;:
        for _x in x:
            for _hue in hue:
                if _x==_hue:
                    continue
                for key in keys:
                    data[_x][_hue][key]=np.array(data[_x][_hue][key])/np.sum(data[_x][_hue][key])
    elif scale==&#34;percentage&#34;:
        for _x in x:
            for _hue in hue:
                if _x==_hue:
                    continue
                for key in keys:
                    data[_x][_hue][key]=np.array(data[_x][_hue][key])/np.sum(data[_x][_hue][key])*100
    if type(palette)==str:
        cmap=plt.get_cmap(palette)
        
    ncols=len(x)*len(hue)-len(set(x)&amp;set(hue))
    if ncols&lt;1:
        ncols=1
    if len(figsize)==0:
        figsize=[(4+0.1*meankey_len)*ncols, 6]
    if ax!=None:
        axes=ax
        fig=None
    else:
        fig, axes=plt.subplots(figsize=figsize,ncols=ncols)
    
    if ncols==1:
        axes=[axes]
    else:
        axes=axes.flatten()
    
    if scale==&#34;absolute&#34;:
        unit=&#34;&#34;
    elif scale==&#34;fraction&#34;:
        unit=&#34;&#34;
    elif scale==&#34;percentage&#34;:
        unit=&#34;%&#34;
    axindex=0
    pos={}
    #_hatch_list=[hatch_list[i] for i in range(len(keys))]
    for _x in x:
        pos[_x]={}
        for _hue in hue:
            if _x==_hue:
                continue
            pos[_x][_hue]={}
            keys=xkeys[_x]
            hues=huekeys[_hue]
            bottom=np.zeros([len(keys)])
            for i, h in enumerate(hues):
                ax=axes[axindex]
                
                heights=np.array([data[_x][_hue][key][i] for key in keys])
                
                if type(palette)==dict:
                    if hatch==True:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=palette[h], label=h, hatch=hatch_list[i])
                    else:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=palette[h], label=h)
                else:
                    if hatch==True:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h, hatch=hatch_list[i])
                    else:
                        ax.bar(keys, heights,width=0.5, bottom=bottom, color=cmap(i/len(hues)), label=h)
                if show_values==True:
                    for j in range(len(keys)):
                        if scale==&#34;absolute&#34;:
                            ax.text(j,bottom[j]+heights[j]/2,&#34;{}{}&#34;.format(heights[j],unit), 
                                 bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                        else:
                            ax.text(j,bottom[j]+heights[j]/2,&#34;{:.2f}{}&#34;.format(heights[j],unit), 
                                 bbox=dict(boxstyle=&#34;round,pad=0.3&#34;, fc=&#34;white&#34;, ec=&#34;y&#34;, lw=1, alpha=0.8))
                
                pos[_x][_hue][h]={key: [he, bo] for key, he, bo in zip(keys, heights, bottom)}
                bottom+=heights
            ax.set_xticks(ax.get_xticks(), labels=keys, rotation=rotation)
            #ax.set_xticklabels(ax.get_xticklabels(), rotation=90)
            if show_legend==True:
                ax.legend(loc=[1.01,0])
            ax.set_xlabel(_x)
            if scale==&#34;absolute&#34;:
                ylabel=&#34;Counts&#34;
            elif scale==&#34;fraction&#34;:
                ylabel=&#34;Fraction&#34;
            elif scale==&#34;percentage&#34;:
                ylabel=&#34;Percentage&#34;
            ax.set_ylabel(ylabel)
            axindex+=1
            if len(pvals)&gt;0 and _x in pvals:
                
                for _hue in hue:
                    if _x==_hue:
                        continue
                    if not _hue in pos[_x]:
                        continue
                    hues=huekeys[_hue]
                    for i, h in enumerate(hues):
                        #print(pos)
                        #print(pos[_x])
                        _pos=pos[_x][_hue][h]
                        for idx1, idx2, pval in pvals[_x][_hue][h]:
                            
                            he1, bot1=_pos[keys[idx1]]
                            he2, bot2=_pos[keys[idx2]]
                            line, =ax.plot([idx1,idx2],[he1/2+bot1,he2/2+bot2],color=&#34;gray&#34;)
                            # r1=ax.transData.transform([idx1, he1/2+bot1])
                            # r2=ax.transData.transform([idx2, he2/2+bot2])
                            r1=np.array([idx1, he1/2+bot1])
                            r2=np.array([idx2, he2/2+bot2])
                            r=r2-r1
                            #print(ax.get_xlim(),ax.get_ylim())
                            r=np.array([1,3])*r/np.array([ax.get_xlim()[1]-ax.get_xlim()[0],ax.get_ylim()[1]-ax.get_ylim()[0]])
                            #r=ax.transData.transform(r)
                            if idx2&lt;idx1:
                                r=-r
                            #print(r)
                            r=r*(r @ r)**(-0.5)
                            #print(h,r)
                            angle=np.arccos(r[0])
                            if r[1]&lt;0:
                                angle= -angle
                            #print(angle)
                            if pval &lt; 0.05:
                                pval_str=str(np.round(-np.log10(pval), decimals=1))
                            else:
                                pval_str=&#34;ns&#34;
                            _line_annotate( &#34;mlp=&#34;+pval_str, line, (idx1+idx2)/2, color=&#34;magenta&#34;)
    if len(x)==1 and len(hue)==1:
        plt.subplots_adjust(top=0.93,left=0.1,right=0.7, bottom=0.17)                            
    else:
        plt.tight_layout(w_pad=2)
    
    if title !=&#34;&#34; and fig !=None:
        fig.suptitle(title)
    if show:
        plt.show()
    return {&#34;pval&#34;:pvals,&#34;axes&#34;:ax}</code></pre>
</details>
</dd>
<dt id="omniplot.proportion.stackedlines"><code class="name flex">
<span>def <span class="ident">stackedlines</span></span>(<span>df: pandas.core.frame.DataFrame, x: str, y: list, sort: bool = True, inverse: bool = False, show_values: bool = False, remove_all_zero: bool = False, palette: str = 'tab20c', figsize=[7, 4], ax: Optional[matplotlib.axes._axes.Axes] = None, alpha: float = 0.75, bbox_to_anchor: list = [1.7, 1], right: float = 0.7, bottom: float = 0.12, show_legend: bool = True, xlabel: str = '', ylabel: str = '', yunit: str = '', xunit: str = '', title: str = '', hatch: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Drawing a scatter plot of which points are represented by pie charts. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>A wide form dataframe. Index names are used to label points. It accepts negative values, but not recommended as
it does not make sense.
e.g.)
year
biofuel_consumption
coal_consumption
gas_consumption
hydro_consumption
nuclear_consumption
oil_consumption
90
1990
16.733
5337.998
5170.609
864.271
1723.004
9306.913
91
1991
19.389
5287.613
5283.972
849.620
1829.645
9108.509
92
1992
22.045
5324.031
5463.509
743.463
1848.197
9297.387
93
1993
25.759
5522.452
5599.419
825.742
1822.853
9376.045
94
1994
28.846
5543.144
5731.081
766.870
1912.903
9619.746
95
1995
30.942
5593.053
5979.829
920.274
2011.356
9597.527</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of a column to be the x axis of the plot.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>list</code></dt>
<dd>the names of values to display as stacked lines</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>bool</code>, optional <code>(default: True)</code></dt>
<dd>Whether to sort lines based on their values</dd>
<dt><strong><code>show_values</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Whether to show percentages at the end of lines.</dd>
<dt><strong><code>remove_all_zero</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>pie_palette</code></strong> :&ensp;<code>str</code></dt>
<dd>A colormap name</dd>
<dt><strong><code>xlabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>x axis label</dd>
<dt><strong><code>ylabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>y axis label</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>Optional[plt.Axes] optional, (default: None)</code></dt>
<dd>pyplot ax to add this scatter plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="see-also">See Also</h2>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stackedlines(df: pd.DataFrame, 
                x: str,
                y: list,
                sort: bool=True,
                inverse: bool=False,
                show_values: bool=False,
                remove_all_zero: bool=False,
                palette: str=&#34;tab20c&#34;,
                figsize=[7,4],
                ax: Optional[plt.Axes]=None,
                alpha: float=0.75,
                bbox_to_anchor: list=[1.7, 1],
                right: float=0.7,
                bottom: float=0.120,
                show_legend: bool=True,
                xlabel: str=&#34;&#34;,
                ylabel: str=&#34;&#34;,
                yunit: str=&#34;&#34;,
                xunit: str=&#34;&#34;,
                title: str=&#34;&#34;,
                hatch: bool=False):
    &#34;&#34;&#34;
    Drawing a scatter plot of which points are represented by pie charts. 
    
    Parameters
    ----------
    df : pandas DataFrame
        A wide form dataframe. Index names are used to label points. It accepts negative values, but not recommended as 
        it does not make sense.
        e.g.) 
              year    biofuel_consumption    coal_consumption    gas_consumption    hydro_consumption    nuclear_consumption    oil_consumption
        90    1990                 16.733            5337.998           5170.609              864.271               1723.004           9306.913
        91    1991                 19.389            5287.613           5283.972              849.620               1829.645           9108.509
        92    1992                 22.045            5324.031           5463.509              743.463               1848.197           9297.387
        93    1993                 25.759            5522.452           5599.419              825.742               1822.853           9376.045
        94    1994                 28.846            5543.144           5731.081              766.870               1912.903           9619.746
        95    1995                 30.942            5593.053           5979.829              920.274               2011.356           9597.527            
    x : str
        the name of a column to be the x axis of the plot.
        
    y: list
        the names of values to display as stacked lines
    sort: bool, optional (default: True)
        Whether to sort lines based on their values
    show_values: bool, optional (default: False)
        Whether to show percentages at the end of lines.
    
    remove_all_zero: bool, optional (default: False)    
    
    pie_palette : str
        A colormap name
    xlabel: str, optional
        x axis label
    ylabel: str, optional
        y axis label
    ax: Optional[plt.Axes] optional, (default: None)
        pyplot ax to add this scatter plot


    Returns
    -------
    dict
    
    Raises
    ------
    Notes
    -----
    References
    ----------
    See Also
    --------
    Examples
    --------
    &#34;&#34;&#34;
    df=df.fillna(0)
    X=np.array(df[x])
    Y=[]
    for col in y:
        Y.append(np.array(df[col]))
    Y=np.array(Y)
    if remove_all_zero==True:
        _filter=Y.sum(axis=0)!=0
        Y=Y[:,_filter]
        X=X[_filter]
    Ydict={col:[] for col in y}
    if sort==True:
        
        if inverse==True:
            for i, _x in enumerate(X):
                _Y=Y[:,i]
                srtidx=np.argsort(_Y)[::-1]
                _bottom=0
                _bottom_neg=0
                for _idx in srtidx:
                    _col=y[_idx]
                    yval=Y[_idx,i]
                    if yval&gt;=0:
                        Ydict[_col].append([_bottom, yval+_bottom])
                        _bottom+=yval
                    else:
                        Ydict[_col].append([_bottom_neg, yval+_bottom_neg])
                        _bottom_neg+=yval
        else:
            for i, _x in enumerate(X):
                _Y=Y[:,i]
                srtidx=np.argsort(_Y)
                _bottom=0
                _bottom_neg=0
                for _idx in srtidx:
                    _col=y[_idx]
                    yval=Y[_idx,i]
                    if yval&gt;=0:
                        Ydict[_col].append([_bottom, yval+_bottom])
                        _bottom+=yval
                    else:
                        Ydict[_col].append([_bottom_neg, yval+_bottom_neg])
                        _bottom_neg+=yval
    else:
        for i, _x in enumerate(X):
            _Y=Y[:,i]
            _bottom=0
            _bottom_neg=0
            for _idx,_col in enumerate(y):
                yval=Y[_idx,i]
                if yval&gt;=0:
                    Ydict[_col].append([_bottom, yval+_bottom])
                    _bottom+=yval
                else:
                    Ydict[_col].append([_bottom_neg, yval+_bottom_neg])
                    _bottom_neg+=yval
    if ax ==None:
        fig, ax=plt.subplots(figsize=figsize)
        
    cmap=plt.get_cmap(palette, len(y))
    colorlut={col: cmap(i) for i, col in enumerate(y)}
    last_vals=[]
    last_pos=[]
    i=0
    for col, vals in Ydict.items():
        vals=np.array(vals)
        if hatch==True:
            ax.fill_between(X, vals[:,0], vals[:,1], label=col, alpha=alpha, color=colorlut[col], hatch=hatch_list[i])
        else:
            ax.fill_between(X, vals[:,0], vals[:,1], label=col, alpha=alpha, color=colorlut[col])
        last_vals.append(vals[-1,1]-vals[-1,0])
        last_pos.append(vals[-1,1]/2+vals[-1,0]/2)
        i+=1
    if show_values==True:
        last_vals=100*np.array(last_vals)/np.sum(last_vals)
        for val, pos in zip(last_vals, last_pos):
            ax.text(X[-1], pos, str(np.round(val, 1))+&#34;%&#34;)
            
    if show_legend==True:
        plt.legend(bbox_to_anchor=bbox_to_anchor)
    plt.subplots_adjust(right=right, bottom=bottom)
    if xlabel !=&#34;&#34;:
        ax.set_xlabel(xlabel)
    else:
        ax.set_xlabel(x)
    ax.set_ylabel(ylabel)
    ax.set_title(title)
    if yunit!=&#34;&#34;:
        ax.text(0, 1, &#34;({})&#34;.format(yunit), transform=ax.transAxes, ha=&#34;right&#34;)
    if xunit!=&#34;&#34;:
        ax.text(1, 0, &#34;({})&#34;.format(xunit), transform=ax.transAxes, ha=&#34;left&#34;,va=&#34;top&#34;)
    if inverse==True:
        ax.invert_yaxis()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="omniplot" href="index.html">omniplot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="omniplot.proportion.nice_piechart" href="#omniplot.proportion.nice_piechart">nice_piechart</a></code></li>
<li><code><a title="omniplot.proportion.nice_piechart_num" href="#omniplot.proportion.nice_piechart_num">nice_piechart_num</a></code></li>
<li><code><a title="omniplot.proportion.stacked_barplot" href="#omniplot.proportion.stacked_barplot">stacked_barplot</a></code></li>
<li><code><a title="omniplot.proportion.stackedlines" href="#omniplot.proportion.stackedlines">stackedlines</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>